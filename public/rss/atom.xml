<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://permit.io/blog</id>
    <title>Permit.io Blog</title>
    <updated>2023-10-22T11:56:37.852Z</updated>
    <generator>Permit.io RSS gen</generator>
    <author>
        <name>Permit.io</name>
        <email>help@permit.io</email>
        <uri>https://permit.io</uri>
    </author>
    <link rel="alternate" href="http://permit.io/blog"/>
    <link rel="self" href="https://permit.io/rss/atom.xml"/>
    <subtitle>Permit.io Blog</subtitle>
    <logo>http://permit.io/open-grhpe.png</logo>
    <icon>http://permit.io/favicon.ico</icon>
    <rights>All rights reserved Permit.io</rights>
    <entry>
        <title type="html"><![CDATA[DevSecOps is nothing without DevEx]]></title>
        <id>devsecops-is-nothing-without-devex</id>
        <link href="https://www.permit.io/blog/devsecops-is-nothing-without-devex"/>
        <updated>2023-10-17T00:00:00.000Z</updated>
        <summary type="html"><![CDATA["Shift-Left" is great, but often results in endless tasks and tools for devs instead of addressing the real issues. How can we avoid it? Implement good DevEx. ]]></summary>
        <content type="html"><![CDATA[<h2>Introduction</h2><p>&quot;Shift-Left&quot; is great. Having a proactive mindset that puts an emphasis on integrating security early in the software development process makes it easier to prevent problems rather than deal with them after they occur. </p><p>The thing is, this DevSecOps (Development, Security, and Operations) mindset often creates a reality in which developers find themselves buried under a mountain of extra tasks and tools. This is primarily due to the fact that DevSecOps tools, especially in the context of application security, tend to <strong>measure </strong>rather than actively <strong>influence </strong>the security posture of the application you’re building. This mostly results in an endless backlog of security findings, instead of providing you with the tools required to make your app more secure.</p><img src="https://media.graphassets.com/Mest4Zz7S2KhxedWPJ7M" alt="image (26).png" title="image (26).png" width="578" height="431" /><h2>Proactive DevSecOps</h2><p>We talked about the importance of turning <a title="https://www.permit.io/blog/shift-left-best-practices" href="https://www.permit.io/blog/shift-left-best-practices"><u><strong>proactive measurement </strong></u><u>into </u><u><strong>proactive design</strong></u></a> in a previous article. This time we want to focus on a crucial aspect of making that happen: Putting an emphasis on <strong>Developer Experience </strong>(DevEx).</p><p>As a dev tool company in the application security field, we&#39;ve learned a lot about what developers come to expect when dealing with the implementation of new tools into their workflow. In this blog, we want to outline these expectations in the form of <strong>best practices</strong> you might want to consider when building security features (or adopting existing security tools) that help your developers create a more secure application and DevSecOps pipeline instead of frustrating them. </p><p>With the help of a practical example from the world of application-level access control, we&#39;ll explore how improved DevEx can lead to safer applications and happier developers. </p><p>First things first - let’s understand what DevEx actually is.</p><h2>What is Developer Experience (DevEx)</h2><p>Much like how <strong>User Experience</strong> (UX) focuses on the end user&#39;s interaction with software products, <strong>Developer Experience</strong> (DevEx) focuses on the <strong>tools</strong>, <strong>practices</strong>, and <strong>processes </strong>used by developers during the development process. </p><p>The platforms, tools, and environments used by developers need to be intuitive, efficient, and streamlined, making the development process smoother and more productive. In the context of integrating security measures like &quot;Shift-Left&quot;, good DevEx means that security tools and protocols seamlessly blend into a developer&#39;s workflow, rather than disrupt or complicate it. When security becomes a natural part of the development process, it&#39;s more likely to be implemented consistently and effectively.</p><p>Giving our developers a good DevEx is key to encouraging this type of proactive approach toward application security. It does so by replacing the endless backlog generated by measurement-based tools with the ability to actively influence their application’s security posture as part of their development workflow. </p><p>To better understand how let’s look into a concrete example: application-level access control. </p><h2>The case study: Application-level access control</h2><p>Access control is comprised of two significant steps in your application’s workflow - </p><p>Authentication, which is about identifying who is trying to access your application, and Authorization, which is about enforcing what they’re allowed to do once they’re in. </p><p>As <a title="https://www.permit.io/blog/authn-vs-authz" href="https://www.permit.io/blog/authn-vs-authz"><u>similar as the two may sound</u></a>, there is not only a crucial difference between the functionality of these two elements but also a major difference in the way these are handled in the development process. </p><p>Many companies offer <strong>authentication </strong>services, allowing developers to easily verify user identities. Determining what actions a user can take after they log in, or, <strong>authorization</strong>, poses a bigger challenge.</p><p>Most <strong>authentication </strong>tools provide developers with straightforward code to integrate into their applications. They often supply an SDK, which gives developers a <strong>user </strong>object, based on which they can make the decision of allowed/denied. In authorization, the same kind of &quot;if&quot; statement we can use to make an allow/deny decision is much harder to make. </p><table><tbody><tr><td><p><strong>Authentication</strong></p></td><td><p><strong>Authorization </strong></p></td></tr><tr><td><p><strong>Verify who the user is </strong></p></td><td><p><strong>Check what they can do</strong></p></td></tr><tr><td><pre><code>if (!user) {
   return;}</code></pre></td><td><pre><code>if (!allowed(
      user,
      action,
      resource
   )) {
   return;
}</code></pre></td></tr></tbody></table><p>Few tools support this nuanced level of user permission checking, especially when it comes to dealing with authorization models more complex than basic Access Control Lists (ASL), such as <a title="https://www.permit.io/blog/rbac-with-permit" href="https://www.permit.io/blog/rbac-with-permit"><u>RBAC</u></a>, <a title="https://www.permit.io/blog/what-is-abac" href="https://www.permit.io/blog/what-is-abac"><u>ABAC</u></a>, and <a title="https://www.permit.io/blog/what-is-rebac" href="https://www.permit.io/blog/what-is-rebac"><u>ReBAC</u></a>. This usually results in developers home-brewing <a title="https://www.permit.io/blog/roll-your-own-rbac" href="https://www.permit.io/blog/roll-your-own-rbac"><u>their own authorization solutions</u></a> - leading to problematic results, with only measurement-based tools available to amend them.</p><p>In the traditional &quot;Shift-Left&quot; approach of handling application-level <strong>authorization</strong>, a tool would usually be applied to check the code of the access control layer for mistakes. This often creates extra work for the developer, instead of aiding them with the implementation process.</p><h2>The Issue with Homebrew Security</h2><p>Let’s look at a typical way of implementing application-level authorization: </p><pre><code>// Middleware
if (req.user.roles.indexOf(role) === -1) {
    return res.send(403);
}

// Endpoint
@authz(&#39;admin&#39;)
const Document = () =&gt; {
    ...
}</code></pre><p>It typically begins with decorators. By employing a decorator, a developer can set security requirements, such as ensuring that only admin users can execute certain operations on specific resources. To achieve this, the developer constructs a <strong>middleware</strong>—a function that operates right before the endpoint is called—to verify if a user possesses the &quot;admin&quot; role.</p><p>Application security and usability requirements are, however, usually more nuanced than this. This usually leads to developers writing more complex code in the middleware, allowing decorators to assign multiple permission models to endpoints.</p><p>As the authorization code evolves, it becomes difficult to ensure in a &quot;Shift-Left&quot; approach that authorization is adequately secure due to its decentralized nature, and we&#39;re often left in the dark about how to thoroughly analyze and review the decisions made during the authorization process.</p><p>Without a dedicated authorization system in place, a security engineer would examine the code, see the middleware, and recognize the framework that was promised to be secure, but the code offers no clarity on the breach&#39;s origin.</p><p>So how can we avoid that? By either creating or adopting authorization tools that follow DevEx best practices.</p><h2>Best Practices for Security DevEx</h2><p>In designing an optimal authorization system, a focus on developer experience (DevEx) is crucial. The system should be built in a way that developers find convenient and efficient to use, rather than an obstacle to their workflow. Here are some best practices we decided to follow while creating Permit.io we think can help you achieve that:</p><ul><li><div><p><strong>Platform Independence:</strong> The authorization system should be cross-platform, ensuring developers don&#39;t have to build extensive, unique layers for each application just to enforce permissions.</p></div></li><li><div><p><strong>Performance:</strong> Developers enforce permissions across various stages of their processes. Therefore, the authorization system needs to be high-performing, ensuring it doesn&#39;t hinder or delay API calls or other operations.</p></div></li><li><div><p><strong>Zero-Effort Deployment:</strong> Developers are more likely to embrace an authorization system that is easy to deploy. If setting up the system feels like a hefty project, it will most likely never be prioritized. The deployment process needs to be as streamlined and hassle-free as possible.</p></div></li><li><div><p><strong>Decentralized Architecture:</strong> With the rise of microservices and diverse deployment environments, an ideal authorization system should support decentralized applications. While the policy system might be unified or centralized, it should cater to applications scattered across different environments.</p></div></li><li><div><p><strong>Seamless Data &amp; Configuration Syncing:</strong> For effective policy analysis, the authorization system should integrate seamlessly with various data sources. Developers should be confident that the system is always up-to-date with the latest permission configurations, ensuring data and settings synchronization without hitches.</p></div></li></ul><p>For an authorization system to be widely adopted by developers, it should seamlessly fit into their workflow. The system should be efficient, flexible, and not add additional burdens to the development process. When these conditions are met, developers are more likely to prioritize and integrate the authorization system in a proper manner, enhancing overall application security.</p><h2>Bottom line: DevEx is Key!</h2><p>Looking at the <a title="https://owasp.org/www-project-top-ten/" href="https://owasp.org/www-project-top-ten/"><u>OWASP top 10 Security risks</u></a> in the past years, we can see the highest-ranked access control vulnerabilities changed from authentication to authorization. Today, authorization alone holds three of the top 10 places on the <a title="https://www.permit.io/blog/owasp-2023" href="https://www.permit.io/blog/owasp-2023"><u>OWASP top 10 API Security risks for 2023</u></a> list. </p><p>Authentication has changed, taking a significant leap toward providing developers with tools that help them impact their application’s security posture instead of just measuring it by providing them with a good developer experience. It’s time authorization goes through the same process. </p><p>We hope these best practices help you choose better tools that make good use of the “Shift-Left” trend, focusing on impacting development from day one. </p><p>Want to learn more about Authorization and access control? Join our <a title="https://io.permit.io/permitslack" href="https://io.permit.io/permitslack"><u>Slack Community</u></a>, where world-class authorization specialists and hundreds of devs are discussing, building, and implementing authorization together.</p>]]></content>
        <author>
            <name>Daniel Bass</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Attribute-Based Access Control (ABAC) VS. Relationship-Based Access Control (ReBAC)]]></title>
        <id>abac-vs-rebac</id>
        <link href="https://www.permit.io/blog/abac-vs-rebac"/>
        <updated>2023-10-04T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[ABAC vs. ReBAC - A comprehensive guide to the pros, cons, use cases, and implementation of these common authorization models]]></summary>
        <content type="html"><![CDATA[<h1>Attribute-Based Access Control (ABAC) VS. Relationship-Based Access Control (ReBAC)</h1><p>Every app out there needs an authorization layer, but choosing which authorization model to implement/build can be challenging. In this article, we will dive into two common authorization models - <a title="https://www.permit.io/blog/what-is-abac" href="https://www.permit.io/blog/what-is-abac"><u>ABAC</u></a> and <a title="https://www.permit.io/blog/what-is-rebac" href="https://www.permit.io/blog/what-is-rebac"><u>ReBAC</u></a>, discuss their pros and cons, and try to guide you in the decision of which one is right for your application. </p><p>Before we start, let’s cover some basics - </p><h2>Intro: What is Authorization</h2><p>Authorization is a complex challenge that basically every developer building an application has to face. It plays the crucial role of ensuring that <strong>the right people and services have the right access to the right resources</strong>. </p><p>It’s important to distinguish between <a title="https://www.permit.io/blog/authn-vs-authz" href="https://www.permit.io/blog/authn-vs-authz"><u>Authorization and Authentication</u></a> - Authentication handles who can log in to your application, while authorization handles what they can do once they are inside. </p><p>Application-level Authorization can be managed through different <strong>authorization models</strong>, and it’s up to developers to pick the most suitable authorization model for their application at each moment in time. </p><p>In this blog, we will explore and compare two commonly used models: <br><strong>Attribute-Based Access Control (ABAC), and Relationship-Based Access Control (ReBAC)</strong>. </p><p>You can also read our comparison between <strong>Relationship-Based Access Control (ReBAC)</strong></p><p>and <strong>Role-Based Access Control (RBAC) </strong><a title="https://www.permit.io/blog/rbac-vs-rebac" href="https://www.permit.io/blog/rbac-vs-rebac"><u>here</u></a>. </p><h2>What is ABAC?</h2><p><a title="https://www.permit.io/blog/what-is-abac" href="https://www.permit.io/blog/what-is-abac"><u><strong>Attribute-Based Access Control (ABAC)</strong></u></a> is an authorization model where access control is determined based on <strong>conditions applied to attributes</strong> (or characteristics). This expands basic <a title="https://www.permit.io/blog/rbac-with-permit" href="https://www.permit.io/blog/rbac-with-permit"><u><strong>RBAC </strong></u></a>roles adding attributes into the mix, allowing the creation of much more granular authorization policies. </p><p>Here’s a rather simple example of an ABAC policy in plain English - </p><p><strong>Employees </strong>based within the <strong>European Union</strong> can <strong>Edit Documents</strong> that are<strong> GDPR Protected</strong>.</p><p>In this example:</p><ul><li><div><p><strong>Employee </strong>is a <strong>Role</strong></p></div></li><li><div><p>The <strong>location </strong>of the employee in the <strong>European Union</strong> is a <strong>User Attribute</strong></p></div></li><li><div><p><strong>Edit </strong>is the <strong>Action</strong></p></div></li><li><div><p><strong>Document </strong>is the <strong>Resource</strong></p></div></li><li><div><p><strong>GDPR Protected</strong> is the <strong>Resource Attribute</strong></p></div></li></ul><p>ABAC’s use of attributes allows the creation of very fine-grained authorization policies. Common attributes include (But are not limited to): Time, Location, Billing Status, and many more - all depending on the specific needs of your application. </p><p>Below is a simple example of an ABAC policy written in <strong>Rego</strong>, the policy language of <a title="https://www.permit.io/blog/introduction-to-opa" href="https://www.permit.io/blog/introduction-to-opa"><u><strong>Open Policy Agent (OPA)</strong></u></a>. OPA is an open-source policy engine for controlling access to systems and resources. It allows separating policy logic from application code, enabling easy policy management and updates without requiring code changes or deployments.</p><pre><code>package abac

# User attributes
user_attributes := {
    &quot;User1&quot;: {&quot;location&quot;: &quot;EU&quot;, &quot;title&quot;: &quot;employee&quot;},
    &quot;User2&quot;: {&quot;location&quot;: &quot;US&quot;, &quot;title&quot;: &quot;employee&quot;},
    &quot;User3&quot;: {&quot;location&quot;: &quot;EU&quot;, &quot;title&quot;: &quot;manager&quot;}
}
# Document attributes
document_attributes := {
    &quot;Doc1&quot;: {&quot;classification&quot;: &quot;GDPR Protected&quot;},
    &quot;Doc2&quot;: {&quot;classification&quot;: &quot;Non-sensitive&quot;}
}
# Default deny
default allow = false
# EU employees can perform any action on GDPR Protected Document
allow {
    # Lookup the user&#39;s attributes
    user := user_attributes[input.user]
    # Check that the user is an employee
    user.title == &quot;employee&quot;
    # Check that the employee is based in the EU
    user.location == &quot;EU&quot;
    # Check that the document is GDPR Protected
    document_attributes[input.document].classification == &quot;GDPR Protected&quot;
}
# Allow any employee to access non-GDPR-protected documents
allow {
    # Lookup the user&#39;s attributes
    user := user_attributes[input.user]
    # Check that the user is an employee
    user.title == &quot;employee&quot;
    # Lookup the document&#39;s attributes
    document := document_attributes[input.document]
    # Check that the document is not GDPR Protected
    document.classification = &quot;Non-sensitive&quot;
}</code></pre><p>To learn more about implementing ABAC with OPA’s Rego, <a title="https://www.permit.io/blog/implement-abac-using-opa" href="https://www.permit.io/blog/implement-abac-using-opa"><u>check out this guide</u></a>.</p><h2>What is ReBAC?</h2><p><a title="https://www.permit.io/blog/what-is-rebac" href="https://www.permit.io/blog/what-is-rebac"><u><strong>Relationship-Based Access Control (ReBAC)</strong></u></a> is a policy model focused exclusively on the relationships, or how resources and identities (aka users) are connected to each other and between themselves. The consideration of these relationships allows us to create authorization policies for <strong>hierarchical structures</strong>.</p><p>ReBAC allows us to <strong>derive </strong>authorization policies <strong>based on existing application-level relationships.</strong> Put in the simplest way, it allows us to create a policy like this:</p><p>A <strong>user</strong> who is<strong> </strong>the <strong>Owner </strong>of a <strong>folder </strong>will also get <strong>Owner </strong>access to every <strong>file </strong>within that <strong>folder</strong>. </p><p>Creating policies based on relationships, rather than roles or attributes, saves us from having to create authorization policies on a per-instance basis. </p><p>To create ReBAC policies, we need to create roles specific to a given resource. This means that the role, and the permissions it carries, are only relevant in the context of that specific resource. A resource role is commonly denoted as <strong>Resource#Role</strong>.</p><p>The most common relationship types ReBAC allows us to handle include:</p><ul><li><div><p><strong>Parent-child hierarchies</strong> - relationships where resources are <strong>nested </strong>under other resources. This allows us to create a policy such as:<em><br><br>A </em><em><strong>user </strong></em><em>who is</em><em><strong> </strong></em><em>assigned the role of an </em><em><strong>Owner </strong></em><em>on a </em><em><strong>folder </strong></em><em>will also get the </em><em><strong>Owner </strong></em><em>role on every </em><em><strong>file </strong></em><em>within that </em><em><strong>folder</strong></em><em>. <br><br></em>We can see that the user&#39;s access to the files is derived from the combination of two elements: The <strong>nesting </strong>of the files within the folder, and their <strong>role </strong>on the folder. </p></div></li></ul><ul><li><div><p><strong>Organizations</strong> - relationships based on <strong>grouping </strong>together <strong>users</strong>. This allows us to create a policy like:<em><br><br>A </em><em><strong>user </strong></em><em>who is</em><em><strong> </strong></em><em>assigned the role of </em><em><strong>Member </strong></em><em>on</em><em><strong> RnD Team </strong></em><em>will also be assigned the role of </em><em><strong>Editor </strong></em><em>on a </em><em><strong>File</strong></em><em> when the </em><em><strong>RnD Team</strong></em><em> is the </em><em><strong>Parent </strong></em><em>of a </em><em><strong>File</strong></em><em>.</em><br><br>Putting several users in one group allows us to derive policies based on their group membership instead of per individual user.</p></div></li></ul><p>Here’s a simple example of ReBAC in Rego: </p><pre><code># return a full graph mapping of each subject to the object it has reference to
full_graph[subject] := ref_object {
	some subject, object_instance in object.union_n([files, teams,organizations])
	# get the parent_id the subject is referring
	ref_object := [object.get(object_instance, “parent_id”, null)]
}
# … see full Rego code at https://play.openpolicyagent.org/p/4qkNc0GtPP
# rule to return a list of allowed assignments
allowing_assignments[assignment] {
	# iterate the user assignments
	some assignment in input_user.assignments
	# check that the required action from the input is allowed by the current role
	input.action in data.roles[assignment.role].grants
	# check that the required resource from the input is reachable in the graph
	# by the current team
	assignment.resource in graph.reachable(full_graph, {input.resource})
}</code></pre><p>The full rego code for this example is available in the <a title="https://play.openpolicyagent.org/p/4qkNc0GtPP" href="https://play.openpolicyagent.org/p/4qkNc0GtPP"><u>OPA Playground</u></a>. For more information about implementing ReBAC with OPA, <a title="https://www.permit.io/blog/oparebac" href="https://www.permit.io/blog/oparebac"><u>check out this guide</u></a>. </p><h2>ABAC vs. ReBAC: Pros and Cons</h2><table><tbody><tr><td><p></p></td><td><p>ABAC </p></td><td><p>ReBAC</p></td></tr><tr><td><p>Use case</p></td><td><p>ABAC allows the creation of fine-grained policies based on user and resource attributes, significantly extending upon basic RBAC.</p></td><td><p>ReBAC is designed to represent hierarchies and nested relationships, making it the most suitable choice for managing permissions for complex hierarchical relationships. </p></td></tr><tr><td><p>Representation of Relationships</p></td><td><p>Can be cumbersome and verbose when managing access to hierarchical structures where the nesting of resources under other resources is present.</p></td><td><p>Excellent for representing hierarchies and nested relationships</p></td></tr><tr><td><p>Reverse Indices (who has access to y, instead of does x have access to y)</p></td><td><p>Implementing reverse indices is very difficult</p></td><td><p>Naturally supports reverse indices (Thanks to ReBAC’s graph-like nature).</p></td></tr><tr><td><p>Performance</p></td><td><p>Often provides better query performance but can be heavier on data mapping and loading.</p></td><td><p>Data mapping is usually easier, but the recursive nature of relationships can produce inefficient queries.</p></td></tr><tr><td><p>Homebrew-Implementation Complexity</p></td><td><p>Medium complexity compared to other models<strong>*</strong></p></td><td><p>Highly complex</p></td></tr><tr><td><p>Granularity</p></td><td><p>Extremely high level of granularity</p></td><td><p>Higher granularity than RBAC, not as granular as ABAC<strong>**</strong></p></td></tr><tr><td><p>Policy definition</p></td><td><p>Permissions can be defined en masse instead of individually for every single resource by using teams and groups. They can also be added/removed from an application without requiring complex data migrations (e.g., adding/removing permissions for each individual user record)<strong>***</strong></p></td></tr><tr><td><p>Auditing difficulty</p></td><td><p>More complex than RBAC, yet still easily auditable if set up correctly.</p></td><td><p>The complexity and recursive nature of ReBAC policies can make auditing challenging.</p></td></tr></tbody></table><p><strong>*</strong> While less complicated than ReBAC, ABAC can still be quite challenging to implement, especially in large and complex applications that require support for a large number of roles, users, and attributes. When designing and implementing ABAC it is crucial to <a title="https://www.permit.io/blog/5-best-practices-for-building-cloud-native-permissions" href="https://www.permit.io/blog/5-best-practices-for-building-cloud-native-permissions"><u>follow established best practices</u></a>. </p><p><strong>**</strong>Though much more granular than RBAC, ReBAC still struggles with truly fine-grained, or dynamic permissions - such as rules dependent on dynamic attributes like time, location, and quotas.</p><p>***The challenge of getting all the relevant attribute data into your decision point in time can be daunting (though tools like <a title="https://www.permit.io/blog/introduction-to-opal" href="https://www.permit.io/blog/introduction-to-opal"><u>OPAL</u></a> can elevate this).</p><h2>Making the choice: ABAC vs. ReBAC</h2><p><strong>ReBAC’s role derivation</strong> allows us to construct authorization policies that are <strong>far more efficient for hierarchies than ABAC. </strong></p><p>Take the following example: <br></p><img src="https://media.graphassets.com/P4p3QqC8QBm3ED6wQJlP" alt="pasted image 0.png" title="pasted image 0.png" width="1510" height="754" /><p>Say we want to grant user Bob access to his files based on his ownership of them. </p><p>Using ABAC, we would add an “Owner” <strong>attribute </strong>to each of the files and folders, and grant Bob a role that allows him to access all files and folders in which an “Owner” attribute references Bob’s ID. </p><p>ReBAC allows us to avoid that by leveraging existing application-level relationships and creating simple policies based on hierarchies and groupings.</p><p>(Yes, we could implement the attribute of ownership on the files to point to `Bob’s files` instead of to Bob, and recursively check if `Bob’s files` are connected to Bob - but that would basically be implementing ReBAC on top of ABAC.)</p><p>On the other hand, ABAC allows us to create far more granular rules by using attributes than ReBAC. </p><p>At the end of the day, authorization models are more thinking tools than concrete guidelines, and most applications end up mixing between them (especially as time passes and the applications evolve). The most important thing is <strong>how you design them</strong> so that they&#39;re flexible, scalable, and continue to evolve along with your application&#39;s needs.</p><h2>Flexible, Scalable Implementation</h2><p>Setting up and managing complex authorization frameworks like RBAC, ABAC, or ReBAC can pose a challenge for developers and other stakeholders, potentially leading to bottlenecks in the process. On top of that, as the requirements of your application change, there may be a need to quickly transition away from basic authorization methods such as ACLs, potentially causing delays that could take months to resolve. </p><p>The work you put into implementing an authorization layer doesn’t end at the point of implementation either - as creating additional roles, attributes, and policies requires complex R&amp;D work and steep learning curves. </p><h2>Why not both?</h2><p>The solution is implementing and managing your RBAC, ABAC, or ReBAC policies using an <a title="https://www.permit.io/blog/authorization-as-a-service" href="https://www.permit.io/blog/authorization-as-a-service"><u>authorization service</u></a> that allows for flexible transition between authorization models and provides a simple API and no-code UI that makes permission management accessible to all stakeholders. </p><p>That’s where Permit comes in - </p><h2>Permit.io: RBAC, ABAC, and ReBAC with a no-code UI</h2><p>Permit provides developers with a permission management solution that allows for both smooth transitioning between <a title="https://www.permit.io/rbac" href="https://www.permit.io/rbac"><u>RBAC</u></a>, <a title="https://www.permit.io/abac" href="https://www.permit.io/abac"><u>ABAC</u></a>, or <a title="https://www.permit.io/rebac" href="https://www.permit.io/rebac"><u>ReBAC</u></a> without any changes to your application code, and the ability to create and manage policies using an accessible no-code UI. </p><p>Permit’s UI allows us to define our required roles, attributes, and role derivation logic, generates code for us, and pushes any updates or changes to our application in real time. Implementing authorization with Permit ensures everyone is included in the permission management process, preventing developers from becoming bottlenecks. </p><p>Want to learn more about Authorization? Join our <a title="https://io.permit.io/permitslack" href="https://io.permit.io/permitslack"><u>Slack community</u></a>, where there are hundreds of devs building and implementing authorization.</p>]]></content>
        <author>
            <name>Daniel Bass</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[401 vs. 403 Error Codes: What's the Difference? When to Use Each? (Updated 2023)]]></title>
        <id>401-vs-403-error-whats-the-difference</id>
        <link href="https://www.permit.io/blog/401-vs-403-error-whats-the-difference"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Learn the Difference Between 401 and 403 Errors: Authentication vs. Authorization in HTTP Status Codes. Clear guidelines for developers.]]></summary>
        <content type="html"><![CDATA[<h2>Introduction</h2><p>Understanding HTTP status codes is crucial when developing websites and APIs. These codes, returned by servers, provide insight into the success or failure of a request. Two of the most commonly encountered status codes are 401 (Unauthorized) and 403 (Forbidden). While they might seem similar at first glance, they serve distinct purposes. This article delves into the nuances of these two status codes, helping software developers discern when and how to use them.</p><p>While many articles on the internet attempt to differentiate between these errors, modern application development standards require us to take a closer look at them. As web application development evolves with new trends and techniques every day, it is important to stay up to date while working with standards such as the 401 and 403 error codes.</p><h2>The Basics of HTTP Status Codes</h2><p>HTTP status codes are three-digit numbers returned by servers to indicate the outcome of a request. They are grouped into five classes, with the first digit defining the class. For instance, <strong>4xx </strong>codes signify <strong>client errors</strong>, while <strong>5xx </strong>codes indicate <strong>server errors</strong>.</p><img src="https://media.graphassets.com/resize=width:1088,height:1483/OXpZVq9jTAGvK6BO9qh0" alt="HTTP Response status codes table" title="image.png" width="1088" height="1483" /><p>In the 4xx class, <strong>401 </strong>and <strong>403 </strong>are particularly noteworthy. The &quot;<strong>401 Unauthorized</strong>&quot; status code indicates that the request lacks valid authentication credentials. On the other hand, the &quot;<strong>403 Forbidden</strong>&quot; status code signifies that the server understands the request but refuses to fulfill it. These two stages in access control are usually considered as <a title="https://www.permit.io/blog/authn-vs-authz" href="https://www.permit.io/blog/authn-vs-authz"><u>authentication and authorization</u></a>.</p><p>The error 401 Unauthorized can be a bit confusing. While 401 is an authentication error code, its description labels it as Unauthorized. Let’s dive into the 401 code to understand it in detail.</p><h2>Diving Deeper into 401 Unauthorized</h2><p>When a server returns a 401 status code, it&#39;s essentially saying, &quot;<strong>I don’t recognize you</strong>.&quot; This code is used when authentication is required and has failed or hasn&#39;t been provided. The response must include a WWW-Authenticate header field, requiring the client to provide valid credentials.</p><p>For instance, consider an API endpoint that requires a valid API key. If a request to this endpoint doesn&#39;t include the key or provides an invalid one, the server will respond with a 401 status.</p><pre><code>HTTP/1.1 401 Unauthorized
⁠
WWW-Authenticate: Basic realm=&quot;Example&quot;</code></pre><p>When used correctly, the 401 error helps our API users understand what the next steps are for a successful response. For example, if we just want to get stronger authentication for a particular endpoint (MFA, for example) it should be declared in the response.</p><p>With the authentication stage handled, it is time to dive into the later stage, authorization, and <strong>403 </strong>error code.</p><h2>Understanding 403 Forbidden</h2><p>The 403 status code has a different implication. It tells the client, &quot;<strong>I know who you are, but you&#39;re not allowed here.</strong>&quot; Even if the client provides valid authentication credentials, the server can still return a 403 if the client doesn&#39;t have permission to access the requested resource.</p><p>For example, a user might be authenticated to access a website but lack the necessary permissions to view an admin page. In such cases, a 403 status would be appropriate.</p><pre><code>HTTP/1.1 403 Forbidden</code></pre><p>As you can see, the 403 code does not include a reason for the error. This is due to the person who should be taking action. In the authentication example, the user usually should be made aware of the error and the reasoning for it, fixing it by providing the required credentials. In authorization, it is up to the API user to decide what should be done with the current state of permissions. For example, they may wish to toggle forbidden features in the application for certain users.</p><p>A further distinction is the generic nature of the steps that follow an error. In authentication, there is only one way to get access to the relevant endpoint - getting the correct credentials. In authorization, the reasons are independent of the access to the resource - users without admin roles may not be able to obtain them.</p><h2>RFC References and Their Importance</h2><p>After understanding the differences between the error codes, it is now time to check the source of those errors and follow the basic guidelines to make sure application security and compliance are maintained.</p><p>RFCs (Request for Comments) are documents that describe various aspects of the internet, including protocols, procedures, and programs. For HTTP status codes, <a title="https://datatracker.ietf.org/doc/html/rfc7235#section-3.1" href="https://datatracker.ietf.org/doc/html/rfc7235#section-3.1"><u>RFC 7235</u></a> specifically addresses the 401 Unauthorized status, while <a title="https://datatracker.ietf.org/doc/html/rfc7231#section-6.5.3" href="https://datatracker.ietf.org/doc/html/rfc7231#section-6.5.3"><u>RFC 7231</u></a> details the 403 Forbidden status.</p><p>By referring to these RFCs, developers can gain a deeper understanding of their intended use and the implications of these status codes. It&#39;s always a good practice to refer back to the official documentation when in doubt.</p><p>RFCs are not new, but the world of application development is changing rapidly and daily. With this in mind, we need to adopt a dynamic mindset that adapts the principles of RFCs to the evolving situation of modern APIs.</p><h2>User vs. Service Access Control</h2><p>One of the things that changed significantly from the days of the status codes RFC, is the way services connected to each other. Back then, when the RFC was written, the most common server consumer was a user via a frontend application. In the modern world of microservices and software built by 3rd party APIs, a lot of the RPC calls are made from one service to another.</p><p>In regards to these status codes, the main difference between these kinds of consumers is the actions that should be taken after one of these codes is returned. While for user sessions the application should notify them to bring credentials again for their identity, different instructions apply for service sessions (such as token refreshment).</p><p>With this difference in mind, the relevant information needs to be assigned for each type of session. Occasionally, we would like to differentiate status codes between user and service sessions for the same error.</p><h2>Common Misconceptions</h2><p>In spite of the clear distinction between 401 and 403 in access control, the dichotomy between those stages may cause some misconceptions and misuse.</p><p>From the 401 side, many developers can think of it as a status for missing credentials, while the code should also be used in case the credentials are incorrect or need refresh. In modern applications, asking for stronger authentication for authenticated users is a valid flow for the 401 code.</p><p>On the other hand, with the 403 code, permissions are not always tied to credentials or authenticated users. For example, an application should use 403 code for anonymous actions that can be performed only in particular circumstances (time-based, for example).</p><p>With a proper understanding of the stags of access control and differentiating between authentication and authorization, you can easily find the right error code for each endpoint and scenario.</p><h2>When to Use Which</h2><p>With these distinctions, RFC, and misconceptions in mind, let’s try to find some guidelines that will help us decide when to use each.</p><p>The first point to remember is that while both codes relate to authentication and authorization, they address different aspects of the process.</p><p>With this distinction in mind, we can proceed with the effect the code has on the application’s behavior and experience. Considering it together with the experience we would like to give to our API users - the developers using our HTTP APIs. These result in the following guidelines:</p><ul><li><div><p>Use 401 when the application principal needs to authenticate itself to get a response.</p></div></li><li><div><p>Use 403 when the application principal doesn&#39;t have the required privileges to perform an action on a resource.</p></div></li></ul><h2>Real-world Scenarios</h2><p>Let’s imagine a cloud storage service (such as Google Drive, for example). Such services usually ask users to log in to see and edit resources on the service but also allow some operations for unauthenticated users. Here is an example of various codes for various operations:</p><ul><li><div><p>If a user tries to create a file without logging in, they should get a 401 error</p></div></li><li><div><p>If a user tries to create a file while logged in but has no permission to create files in a particular folder, they should get a 403 error</p></div></li><li><div><p>If a user wants to create a file, but the owner of this particular folder is required to pass an MFA test for it, they should get a 401 error</p><img src="https://media.graphassets.com/resize=width:1717,height:1410/0anyTqQGQXe4Sj2625v8" alt="Example of 401 vs 403 Decision Flow" title="image.png" width="1717" height="1410" /></div></li><li><div><p>If a user is trying to get access to a public shared link, but the owner hides the file, they should get a 403 error</p></div></li></ul><h2>Conclusion</h2><p>Understanding the difference between 401 and 403 is essential for developers. While both indicate authentication and authorization issues, they serve distinct purposes. By using them appropriately, developers can provide clearer error messages, leading to better user experiences and easier debugging.</p><p>Always remember to refer to the official RFCs when in doubt and ensure that your applications handle these status codes gracefully. With the knowledge from this guide, you&#39;re well-equipped to navigate the intricacies of HTTP 401 vs. 403.<br><br>Looking to make sense of your application&#39;s access control? Permit.io provides authorization as a service, allowing you to <a title="https://www.permit.io/blog/rbac-with-permit" href="https://www.permit.io/blog/rbac-with-permit">implement authorization into your app within minutes</a> and manage it with a no-code UI.</p>]]></content>
        <author>
            <name>Gabriel L. Manor</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Role-Based Access Control (RBAC) VS. Relationship-Based Access Control (ReBAC)]]></title>
        <id>rbac-vs-rebac</id>
        <link href="https://www.permit.io/blog/rbac-vs-rebac"/>
        <updated>2023-09-21T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[RBAC vs. ReBAC - A comprehensive guide to the pros, cons, use cases, and implementation of these common authorization models]]></summary>
        <content type="html"><![CDATA[<h1>Role-Based Access Control (RBAC) VS. Relationship-Based Access Control (ReBAC)</h1><p>Almost every app out there needs an authorization layer, but choosing which authorization model to implement/build can be challenging. In this article, we will dive into two common authorization models - <a title="https://www.permit.io/blog/rbac-with-permit" href="https://www.permit.io/blog/rbac-with-permit"><u>RBAC</u></a> and <a title="https://www.permit.io/blog/what-is-rebac" href="https://www.permit.io/blog/what-is-rebac"><u>ReBAC</u></a>, discuss their pros and cons, and try to guide you in the decision of which one is right for your application. </p><p>Before we start, let’s cover some basics - </p><h2>Intro: What is Authorization</h2><p>Authorization is a complex challenge that basically every developer building an application has to face. It plays the crucial role of ensuring that <strong>the right people and services have the right access to the right resources</strong>. </p><p>It’s important to distinguish between <a title="https://www.permit.io/blog/authn-vs-authz" href="https://www.permit.io/blog/authn-vs-authz"><u>Authorization and Authentication</u></a> - Authentication handles who can log in to your application, while authorization handles what they can do once they are inside.</p><p>Application-level Authorization can be managed through different <strong>authorization models</strong>, and it’s up to developers to pick the most suitable authorization model for their application at each moment in time. </p><p>In this blog, we will explore and compare two commonly used models: <br><strong>Role-Based Access Control (RBAC), and Relationship-Based Access Control (ReBAC)</strong>.</p><h2>What is RBAC?</h2><p><a title="https://www.permit.io/blog/rbac-with-permit" href="https://www.permit.io/blog/rbac-with-permit"><u><strong>Role-Based Access Control (RBAC)</strong></u></a> is an authorization model where access control is determined based on predefined (or dynamic) <strong>roles</strong>. Users are assigned roles, such as “Admin” or “Editor”, with each role associated with specific permissions. </p><p>For example, here’s a rather simple example of an RBAC policy in simple English - </p><p><strong>Employees </strong>can <strong>View </strong>and <strong>Edit </strong>Documents, while <strong>Admins </strong>can <strong>View</strong>, <strong>Edit</strong>, <strong>Create</strong>, and <strong>Delete </strong>them.</p><p>RBAC provides a rather simple solution for controlling access to resources based on a predefined set of roles that can, for example, correlate with an individual&#39;s job function or responsibilities.</p><p>Below is a simple example of an RBAC policy written in <strong>Rego</strong>, the policy language of <a title="https://www.permit.io/blog/introduction-to-opa" href="https://www.permit.io/blog/introduction-to-opa"><u><strong>Open Policy Agent (OPA)</strong></u></a>. OPA is an open-source policy engine for controlling access to systems and resources. It allows separating policy logic from application code, enabling easy policy management and updates without requiring code changes or deployments.</p><pre><code>default allow = false
allow {
    # Lookup the list of roles for the user
    roles := user_roles[input.user]
    # For each role in that list
    r := roles[_]
    # Lookup the permissions list for role r
    permissions := role_permissions[r]
    # For each permission
    p := permissions[_]
    # Check if the permission granted to r matches the user&#39;s request
    p == {&quot;action&quot;: input.action, &quot;object&quot;: input.object}
}</code></pre><p>A detailed example of how to implement RBAC using OPA is available <a title="https://www.permit.io/blog/implement-rbac-using-opa" href="https://www.permit.io/blog/implement-rbac-using-opa"><u>here</u></a>. </p><h2>What is ReBAC?</h2><p><a title="https://www.permit.io/blog/what-is-rebac" href="https://www.permit.io/blog/what-is-rebac"><u><strong>Relationship-Based Access Control (ReBAC)</strong></u></a> is a policy model focused exclusively on the relationships, or how resources and identities (aka users) are connected to each other and between themselves. The consideration of these relationships allows us to create authorization policies for <strong>hierarchical structures</strong>.</p><p>ReBAC allows us to <strong>derive </strong>authorization policies <strong>based on existing application-level relationships.</strong> Put in the simplest way, it allows us to create a policy like this:<br><br>A <strong>user </strong>who is<strong> </strong>assigned the role of an <strong>Owner </strong>on a <strong>folder </strong>will also get the <strong>Owner </strong>role on every <strong>file </strong>within that <strong>folder</strong>. </p><p>Creating policies based on relationships rather than roles or attributes saves us from having to create authorization policies on a per-instance basis. </p><p>To create ReBAC policies, we need to create roles specific to a given resource. This means that the role, and the permissions it carries, are only relevant in the context of that specific resource. A resource role is commonly denoted as <strong>Resource#Role</strong>.</p><p>The most common relationship types ReBAC allows us to handle include:</p><ul><li><div><p><strong>Parent-child hierarchies</strong> are relationships where resources are <strong>nested </strong>under other resources. This allows us to create a policy such as:<em><br><br>A </em><em><strong>user </strong></em><em>who is</em><em><strong> </strong></em><em>assigned the role of an </em><em><strong>Owner </strong></em><em>on a </em><em><strong>folder </strong></em><em>will also get the </em><em><strong>Owner </strong></em><em>role on every </em><em><strong>file </strong></em><em>within that </em><em><strong>folder</strong></em><em>. </em><br><br>We can see that the user&#39;s access to the files is derived from the combination of two elements: The <strong>nesting </strong>of the files within the folder, and their <strong>role </strong>on the folder. </p></div></li></ul><ul><li><div><p><strong>Organizations</strong> are relationships based on <strong>grouping </strong>together <strong>users</strong>. This allows us to create a policy like:<em><br><br>A </em><em><strong>user </strong></em><em>who is</em><em><strong> </strong></em><em>assigned the role of </em><em><strong>Member </strong></em><em>on</em><em><strong> RnD Team </strong></em><em>will also be assigned the role of </em><em><strong>Editor </strong></em><em>on </em><em><strong>RnD File</strong></em><em> when the </em><em><strong>RnD Team</strong></em><em> is the </em><em><strong>Parent </strong></em><em>of </em><em><strong>RnD File</strong></em><em>.</em><br><br>Putting several users in one group allows us to derive policies based on their group membership instead of per individual user.</p></div></li></ul><p>Here’s a simple example of ReBAC in Rego: </p><pre><code># return a full graph mapping of each subject to the object it has reference to
full_graph[subject] := ref_object {
	some subject, object_instance in object.union_n([files, teams,organizations])
	# get the parent_id the subject is referring
	ref_object := [object.get(object_instance, “parent_id”, null)]
}
# … see full Rego code at https://play.openpolicyagent.org/p/4qkNc0GtPP
# rule to return a list of allowed assignments
allowing_assignments[assignment] {
	# iterate the user assignments
	some assignment in input_user.assignments
	# check that the required action from the input is allowed by the current role
	input.action in data.roles[assignment.role].grants
	# check that the required resource from the input is reachable in the graph
	# by the current team
	assignment.resource in graph.reachable(full_graph, {input.resource})
}
</code></pre><p>The full rego code for this example is available in the <a title="https://play.openpolicyagent.org/p/4qkNc0GtPP" href="https://play.openpolicyagent.org/p/4qkNc0GtPP"><u>OPA Playground</u></a>. For more information about implementing ReBAC with OPA, <a title="https://www.permit.io/blog/oparebac" href="https://www.permit.io/blog/oparebac"><u>check out this guide</u></a>. </p><h2>RBAC vs. ReBAC: Pros and Cons</h2><table><tbody><tr><td><p></p></td><td><p>RBAC </p></td><td><p>ReBAC</p></td></tr><tr><td><p><strong>Use case</strong></p></td><td><p>RBAC allows administrators to define roles and assign permissions, without having to manage permissions for individual users</p><p>This makes RBAC a good alternative to simpler models like ACL</p></td><td><p>ReBAC is designed to represent hierarchies and nested relationships, making it the most suitable choice for managing permissions for complex hierarchical relationships</p></td></tr><tr><td><p><strong>Representation of relationships</strong></p></td><td><p>Ineffective when managing access to hierarchical structures where the nesting of resources under other resources is present</p></td><td><p>Excellent for representing hierarchies and nested relationships</p></td></tr><tr><td><p><strong>Reverse indices</strong></p></td><td><p>Does not support reverse indices</p></td><td><p>Can support reverse indices (not only does x have access to y, but also who has access to y).</p></td></tr><tr><td><p><strong>Performance</strong></p></td><td><p>Generally high performance - due to simple policy execution</p></td><td><p>Potentially lower performance compared to RBAC, large hierarchies requiring significant processing power and time</p></td></tr><tr><td><p><strong>Implementation complexity</strong></p></td><td><p>Low complexity compared to other models<strong>*</strong></p></td><td><p>Highly complex</p></td></tr><tr><td><p><strong>Scalability </strong></p></td><td><p>Granular permissions and newly added roles can easily result in </p><p>‘Role explosion’ in complex systems</p></td><td><p>Easily scales for large applications thanks to the combined use of relationships with roles.</p></td></tr><tr><td><p><strong>Granularity</strong></p></td><td><p>Limited granularity as the result of the dependency on roles </p></td><td><p>Higher granularity thanks to the support of hierarchies, still not as granular as ABAC<strong>**</strong></p></td></tr><tr><td><p><strong>Policy definition</strong></p></td><td><p>Better than simpler models - </p><p>Permissions can be added/removed from an application without requiring complex data migrations (e.g., adding/removing permissions for each individual user record)</p></td><td><p>Better than RBAC - </p><p>Permissions can be defined en masse instead of individually for every single resource by using teams and groups</p></td></tr><tr><td><p><strong>Auditing difficulty</strong></p></td><td><p>Easily auditable if set up correctly.</p></td><td><p>The complexity and recursive nature of ReBAC policies can make auditing challenging</p></td></tr></tbody></table><p><br><strong>*</strong> While less complex than other models, RBAC can still be quite challenging to implement, especially in large and complex applications that require support for a large number of roles and users. Designing and implementing RBAC requires <a title="https://www.permit.io/blog/planning-app-rbac" href="https://www.permit.io/blog/planning-app-rbac"><u>a thorough understanding of the application&#39;s requirements</u></a>, and the roles and permissions needed to support them. It is also crucial to <a title="https://www.permit.io/blog/5-best-practices-for-building-cloud-native-permissions" href="https://www.permit.io/blog/5-best-practices-for-building-cloud-native-permissions"><u>follow established best practices</u></a> when doing so.</p><p><strong>**</strong>Though much more granular than RBAC, ReBAC still struggles with truly fine-grained, or dynamic permissions - such as rules dependent on attributes like time, location, quotas, etc.</p><h2>Making the choice: RBAC vs. ReBAC</h2><p><strong>ReBAC’s role derivation</strong> allows us to construct authorization policies that are <strong>far more efficient for hierarchies than RBAC. </strong>In RBAC, we would have to assign users roles that grant them direct access to each folder and file. ReBAC allows us to avoid that by leveraging existing application-level relationships and creating simple policies based on hierarchies and groupings.</p><img src="https://media.graphassets.com/ycbYilWITCS5AHA4uFgS" alt="pasted image 0 (2).png" title="pasted image 0 (2).png" width="1511" height="754" /><p><em>A visual representation of a key difference between RBAC and ReBAC</em></p><p>With RBAC, in order to grant Bob editor access to all files and folders, we would have to assign Bob the Editor role per each individual file and folder. With ReBAC, we can define a policy such as: “A <strong>user </strong>who is<strong> </strong>assigned the role <strong>Folder#Editor </strong>will also be assigned the <strong>File#Editor </strong>when the <strong>Folder </strong>instance is the <strong>Parent </strong>of a <strong>FIle </strong>instance”. This allows us to handle this hierarchical structure in a far more efficient way. </p><p>At the end of the day, authorization models are more thinking tools than concrete guidelines, and most applications end up mixing between them (especially as time passes and the applications evolve). The most important thing is <strong>how you implement them</strong> so that they&#39;re flexible, scalable, and continue to evolve along with your application&#39;s needs.</p><h2>Flexible, Scalable Implementation</h2><p>As application requirements evolve, the need to shift from a simple authorization model (like ACLs) to more advanced models like RBAC, ABAC, or ReBAC can arise rapidly. Implementing and managing such complex authorization systems can be challenging for developers and other stakeholders, potentially leading to bottlenecks and inflexibility. </p><p>Setting up these policy models can take months of work, which doesn’t end at the point of implementation - as creating additional roles, attributes, and policies requires complex R&amp;D work and steep learning curves. </p><h2>Why not both?</h2><p>The solution is implementing and managing your RBAC, ABAC, or ReBAC policies using an <a title="https://www.permit.io/blog/authorization-as-a-service" href="https://www.permit.io/blog/authorization-as-a-service"><u>authorization service</u></a> that allows for flexible transition between authorization models and provides a simple no-code UI that makes permission management accessible to other stakeholders. </p><p></p><img src="https://media.graphassets.com/P9HAzE43QXKtl55FW5Zk" alt="ezgif-2-da9d983523.gif" title="ezgif-2-da9d983523.gif" width="498" height="313" /><p>That’s where Permit comes in - </p><h2>Permit.io: RBAC, ABAC, and ReBAC with a no-code UI</h2><p>Permit provides developers with a permission management solution that allows for both smooth transitioning between <a title="https://www.permit.io/rbac" href="https://www.permit.io/rbac"><u>RBAC</u></a>, <a title="https://www.permit.io/abac" href="https://www.permit.io/abac"><u>ABAC</u></a>, or <a title="https://www.permit.io/rebac" href="https://www.permit.io/rebac"><u>ReBAC</u></a> without any changes to your application code and the ability to create and manage policies using an accessible no-code UI. </p><p>Permit’s UI allows us to define our required roles, attributes, and role derivation logic, generates code for us, and pushes any updates or changes to our application in real time. Implementing authorization with Permit ensures that everyone is included in the permission management process, preventing developers from becoming bottlenecks. </p><p>Want to learn more about Authorization? Join our <a title="https://io.permit.io/permitslack" href="https://io.permit.io/permitslack"><u>Slack community</u></a>, where there are hundreds of devs building and implementing authorization.</p>]]></content>
        <author>
            <name>Daniel Bass</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[How we got our Dev Tool ‘Product of the Day’ in Product Hunt (And Survived)]]></title>
        <id>producthunt-howto</id>
        <link href="https://www.permit.io/blog/producthunt-howto"/>
        <updated>2023-09-15T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[We just launched our developer tool on Product Hunt and got 'Product of the Day'. Here's how we did it. Some useful growth hacking tips. ]]></summary>
        <content type="html"><![CDATA[<p><em>This article was co-written by </em><a title="https://www.linkedin.com/in/gmanor/" href="https://www.linkedin.com/in/gmanor/"><em>Gabriel Manor</em></a><em> and </em><a title="https://www.linkedin.com/in/daniel-bass-8b2bb81ab/" href="https://www.linkedin.com/in/daniel-bass-8b2bb81ab/"><em>Daniel Bass</em></a></p><p>We just launched on <a title="https://www.producthunt.com/" href="https://www.producthunt.com/"><u>Product Hunt</u></a> two days ago and got ranked <strong>No. 1 Product of the Day</strong> (Aiming for Product of the Week - fingers crossed). Following the launch, we decided to share our thoughts and experiences in this blog to help other developer tool companies. So, without further ado, here’s <strong>how we got ‘Product of the Day’ and survived</strong> - <br></p><iframe
          width="500"
          height="405"
          frameBorder="0"
          allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
          allowFullScreen
          title="https://cards.producthunt.com/cards/posts/412562?v=1"
          src="https://cards.producthunt.com/cards/posts/412562?v=1"
        ></iframe><h2>What is Product Hunt, and why does it matter?</h2><p>In case you are not familiar, <a title="https://www.producthunt.com/" href="https://www.producthunt.com/"><u>Product Hunt</u></a> is a curation platform for new products. It allows you to post about what you&#39;re building, get some eyes on it, and gain some important resources for every new product out there - <strong>reviews</strong>, <strong>opinions</strong>, and, most importantly, <strong>potential users</strong>. </p><p>There are several <a title="https://publer.io/blog/products-that-started-off-on-product-hunt/" href="https://publer.io/blog/products-that-started-off-on-product-hunt/"><u>major players who started off in ProductHunt</u></a>, including <a title="https://www.producthunt.com/products/zapier#zapier" href="https://www.producthunt.com/products/zapier#zapier"><u><strong>Zapier</strong></u></a>, <a title="https://www.producthunt.com/products/slack#slack" href="https://www.producthunt.com/products/slack#slack"><u><strong>Slack</strong></u></a>, and <a title="https://www.producthunt.com/products/notion#notion-beta" href="https://www.producthunt.com/products/notion#notion-beta"><u><strong>Notion </strong></u></a>- to name a few. Getting &quot;Discovered&quot; on Product Hunt can often serve as a really great push to get people to know your product.</p><p>The thing is, Product Hunt is quite generic and is usually used to promote classic B2C products, which often deters developer tool teams to try and promote their own products there, seeing the platform as unfitting for their target audience. </p><p>That being said, after some research into other developer tools that had successful launches, we decided to try and get in on the action. </p><p>Basically, here’s how it works:</p><ul><li><div><p>A ‘Hunter’ suggests your product to be showcased on Product Hunt. In most cases, this is done by someone who is very active on the platform and has a good following. You can also put in some extra effort and do it yourself.</p></div></li><li><div><p>Once your product is live, people can <strong>comment</strong>, <strong>review</strong>, and <strong>upvote</strong>. The ratings are not shown for the first four hours of the day to keep things fair, and the goal is to reach the highest amount of upvotes in the first 24 hours. </p></div></li><li><div><p>Got 1st place? You get awarded <strong>“Product of the Day”</strong> - a title that grants you a feature in Product Hunt’s newsletter, some social media attention, and usually <strong>lots of traffic </strong>(Which hopefully translates into actual customers).</p></div></li></ul><h2>Who are we?</h2><p>Before we dive into our experience, a few words about us - <a title="https://www.permit.io/" href="https://www.permit.io/"><u>Permit.io</u></a> is a cloud service that simplifies creating and managing application-level permissions through a user-friendly low-code UI interface. We support all permission models (<a title="https://www.permit.io/rbac" href="https://www.permit.io/rbac"><u>RBAC</u></a>/<a title="https://www.permit.io/abac" href="https://www.permit.io/abac"><u>ABAC</u></a>/<a title="https://www.permit.io/rebac" href="https://www.permit.io/rebac"><u>ReBAC</u></a>) and seamlessly integrate with your application using our SDK, providing real-time insights into your permissions. Permit.io has been around for a couple of years now, but after finally <a title="https://www.businesswire.com/news/home/20230830907160/en/Permit.io-Unveils-Support-for-Relationship-Based-Access-Control-Streamlining-Google-Zanzibar-Styled-Authorization-with-a-No-Code-UI" href="https://www.businesswire.com/news/home/20230830907160/en/Permit.io-Unveils-Support-for-Relationship-Based-Access-Control-Streamlining-Google-Zanzibar-Styled-Authorization-with-a-No-Code-UI"><u>releasing our support in all three permission models</u></a> we felt it was a good time to make an official announcement and put ourselves out there - hence this launch. </p><h2>What did we achieve? </h2><p>Let’s talk about how we did (before we dive into how we did it) -</p><ul><li><div><p><a title="https://twitter.com/permit_io/status/1702646162371518970" href="https://twitter.com/permit_io/status/1702646162371518970"><u>Product Hunt “Product of the Day”</u></a> for 13/09/2023. </p><img src="https://media.graphassets.com/QJ5baGQKRweFzEfUBxdi" alt="Screenshot_2.png" title="Screenshot_2.png" width="842" height="180" /><p></p></div></li><li><div><p>A feature in the Product Hunt newsletter. </p></div></li><li><div><p>Our <a title="https://www.youtube.com/watch?v=-2B0oBCseUg" href="https://www.youtube.com/watch?v=-2B0oBCseUg"><u>launch video</u></a> got 100K+ views on YouTube and got <a title="https://twitter.com/ProductHunt/status/1701611810166894686" href="https://twitter.com/ProductHunt/status/1701611810166894686"><u>Tweeted by Product Hunt</u></a> (500K + followers).</p><img src="https://media.graphassets.com/NKqF0HDTxOjrn0cNZQmo" alt="pasted image 01.png" title="pasted image 01.png" width="738" height="565" /></div></li></ul><ul><li><div>We achieved X4 times more votes than previous launches by competitors. </div></li></ul><h2>How did this affect us? </h2><ul><li><div><p>1.3K hits on a dedicated Product Hunt landing page on our website within 24 hours.</p></div></li><li><div><p>A spike of 500% in signups for our platform (Double to similar marketing activities/feature launches).<br></p><img src="https://media.graphassets.com/LHkCeOZ2RUSs7uki5g03" alt="pasted image 0 (1).png" title="pasted image 0 (1).png" width="1600" height="701" /></div></li></ul><p><em>A graph showing new signups to the Permit.io platform, with the launch day spike.</em></p><ul><li><div><p>Seven new potential customer meetings within 24 hours of the launch (Compared to one on average in similar marketing activities).</p></div></li></ul><p>The conclusion - <strong>The launch was effective in supplying us with quality “Leads”. <br></strong></p><h2>Product Hunt for Developer Tools</h2><p>Managing a Product Hunt launch for a developer tool is tricky business. Considering we are a <a title="https://openviewpartners.com/product-led-growth/" href="https://openviewpartners.com/product-led-growth/"><u>PLG</u></a>-focused company, we don’t really do the classic sales pitches and commercials. Our goal is to have developers believe our tool is useful after they have tried it, and not because someone convinced them it is (Which, knowing developers, is close to impossible). </p><p>The classic tricks, tips, and growth hacks usually suggested for B2C products don’t reallywork when you are marketing to a developer audience - just try posting anything that smells even remotely promotional on <a title="https://www.reddit.com/r/programming/" href="https://www.reddit.com/r/programming/"><u>r/programming</u></a>, or running massive ad campaigns like there’s a single developer out there not using an ad blocker. <br><br>Considering these factors, here’s what we decided to do -</p><h2>Our Product Hunt launch to-do list: </h2><h3><a title="https://www.youtube.com/watch?v=-2B0oBCseUg" href="https://www.youtube.com/watch?v=-2B0oBCseUg"><u>The Launch Video:</u></a></h3><p>Authorization, like various other concepts in the development space, has two main issues when it comes to marketing: </p><ul><li><div><p>It gets <strong>REALLY </strong>complicated <strong>REALLY </strong>quickly and is very difficult to explain in simple terms. </p></div></li><li><div><p>It can be very hard to pour <strong>fun</strong>, <strong>excitement</strong>, and <strong>intrigue </strong>into a concept developers find <strong>dreadfully annoying and tedious</strong> to begin with (which is kind of the reason we exist). </p></div></li></ul><p>For those two reasons, we had two main goals our video had to achieve: </p><ul><li><div><p>It needed to explain what we do <strong>in the simplest way possible</strong> (a good measurement is asking someone with zero development background to watch it and ask “What does this company do” - if they give even a vaguely accurate answer, you’re on the right track).</p></div></li><li><div><p><strong>It needed to be</strong> <strong>fun</strong>. No developer likes watching ads, even if it&#39;s for an amazing product they desperately need. If you want to grab anyone&#39;s attention - make sure you are creating something that’s genuinely designated for them to enjoy, and not just sell your thing. </p></div></li></ul><p>To create our video, we wrote a simple script and employed the narration and editing skills of our very own talented developer advocate <a title="https://www.youtube.com/@developerfilip" href="https://www.youtube.com/@developerfilip"><u>Filip Grebowski</u></a>.</p><h3>Social media, and community outreach (Message and visuals)</h3><p>We prepared some social media content to announce on launch day, leveraging every channel we have a significant following in to try and grab people’s attention. </p><h3>A company Q&amp;A cheat sheet</h3><p>This one is pretty self-explanatory - as votes and comments start pouring in, there tend to be a lot of comments and questions about your product. We created a sort of guide to assist our team in replying to as many comments and questions as possible. No question should remain unanswered.</p><h3><a title="http://permit.io/producthunt" href="http://permit.io/producthunt"><u>A dedicated landing page</u></a></h3><p>We created a designated landing page for the launch, to which a user clicking the link from Product Hunt will be redirected. This page was more designated to drive <strong>conversion </strong>rather than getting us more upvotes. This page must answer three key questions:</p><ul><li><div><strong>What is the issue</strong> we are here to solve (Again, explained in the simplest way possible).</div></li><li><div><strong>How </strong>we solve it.</div></li><li><div>Why you should solve it by using <strong>our </strong>product. </div></li></ul><h3><u>A specialized launch day kit</u></h3><p>To make it easier for our community members, users, influencers, friends, or anyone else who wants to help spread the word, we created a launch day kit consisting of graphics, our video, explainer materials, Tweet/LinkedIn post ideas, basically anything they can use to get the word out.</p><h3>Website banners</h3><p>To encourage existing website visitors and users of our app to upvote us, we added a simple banner at the top, asking users to support the upcoming launch. </p><h3>An engaging blog to generate more traffic</h3><p>More on this in the “Growth Hacking” section. </p><h2>How much did we spend?</h2><p>As most of the work was done by our in-house marketing team, the total sum invested in the launch amounted to<strong> 800 USD</strong>. This sum was invested in three activities: </p><ul><li><div><p>A Twitter Space with an influencer from the developer space which we know has an audience interested in dev tool-related content and news. </p></div></li><li><div><p>A campaign on Instagram for the launch video. This one is only really relevant if your company (Or, in our case, the developer advocate working in the company) has an actual Instagram presence, followers, engagement, and a regular content cadence. </p></div></li><li><div><p>A YouTube campaign for the launch video. Even though, as we said, most developers tend to employ various tools to avoid seeing these types of ads, we decided to invest a minor sum into it just as a ‘hail mary’. </p></div></li></ul><h2>Our growth hacking tips:</h2><p>From our measurement of the launch aftermath, here are some ‘growth hacking’ tips we can recommend - </p><h3>Reach out to your community</h3><p>If you are not a brand-new product, and you at least have some users who use and enjoy your product, don’t be afraid to reach out to them and ask for their support. This can of course be done with a simple cold email (Which doesn’t tend to do well), but if you have a channel through which you can contact users who are more active - make sure to do that. </p><p>In <a title="https://io.permit.io/permitslack" href="https://io.permit.io/permitslack">our Slack community</a>, many members who we reached out to and asked to support us during the launch did so gladly, sharing it on their social media and within their own communities. </p><p>Reaching out to people in adjacent communities who are open to collaborating can also be a great way to broaden your reach (i.e. if your tool is built on top of an open-source component, and you have a good standing with the maintainers of that project). </p><h3>Cooperate with influencers</h3><p>Find as many influencers related to your space, and try to build a relationship of cooperation with them. This can be generally useful when you announce new features and want to make a splash. It’s also important to note that not all of these relationships have to be business-focused. If developers genuinely like your product and find it useful, they would often love to share it with other people in their field. </p><h3>A blog covering “<a title="https://www.permit.io/blog/10-exceptional-developer-tools-launched-in-2023" href="https://www.permit.io/blog/10-exceptional-developer-tools-launched-in-2023"><u>10 Exceptional Developer Tools Launched in 2023</u></a>” </h3><p>As part of our content strategy for the launch, we decided to showcase other tools that the developers in our company use. This type of content is a win for you as well as the other tools you mention, and it&#39;s a great way to give each other a boost. Articles on these topics tend to do very well on both social media and news outlets. This served as a great incentive for other dev tool companies to help us out during the launch. </p><h3>Organize a company-wide launch meeting</h3><p><strong>The first two hours of your launch are golden</strong>. For a successful launch, you need to get to the first place on Product Hunt before the initial voting results are published (Four hours into the day). If you manage to get to the top within that time frame - it’s going to be very hard to knock you down from the first place. It’s no surprise people tend to upvote the project in the first place (Especially those coming to the Product Hunt website organically), so once the initial results get published it can already be too late to make a significant jump up. </p><p>Having everyone in the office reaching out to friends, colleagues, and communities they are a part of at once served as a crucial game-changer which allowed us to<strong> gain over 300 upvotes within the first two hours of the launch</strong>. </p><h3>Adapting to time zones</h3><p>It’s important to realize there could be major voting spikes depending on your time zone. A Product Hunt day starts at 00:30 AM PST. We managed our launch in GMT+3, meaning our initial post was at 08:30 AM. In the US East Coast, however, it was 01:30 AM. That meant we had to prepare a second wave of content for around 15:30 (08:30 EDT) when people in the US wake up and go online. Preparing for this in advance helped us leverage the full potential of our community reach-out effectively. </p><h3>A low-budget ad campaign for our video on YouTube and Instagram</h3><p>The YouTube and Instagram campaigns we ran did surprisingly well, giving us a nice boost in upvotes and traffic. This can be attributed to the launch video that generated lots of positive attention, as well as our Developer advocate’s significant Instagram presence. </p><h2>Pitfalls to Avoid </h2><ul><li><div><p>Before the launch, we considered a few different marketing agencies that offered us to manage the launch as a paid service. From analyzing the strategies that were offered to employ, we quickly understood that the methods they use are often -<br><br>A)<strong> Irrelevant when trying to promote a product targeted to developers</strong>, as most of them have little experience in doing so and little understanding of the developer audience. <br><br>B) <strong>Not exactly ethical</strong>. Agencies tend to apply methods like using bots / false accounts to help inflate your voting numbers. Using strategies such as these <strong>will hurt your scoring</strong>, and you might not get picked for Product of the Day even if you have the most upvotes. </p></div></li><li><div><p>Don’t waste your time on cold calls/emails/DMs. Reach out to people who know you and your product, and ask them to reach out to people they know. Once we focused on reaching out to people who we knew would love to support us, it brought in great results. </p></div></li></ul><h2>Conclusion</h2><p>People tend to be skeptical about the efficiency of doing a Product Hunt launch for developer tools. With our experience, we can say with a pretty high level of certainty that it was not only very beneficial in bringing in more users for our product, but it also taught us a lot about marketing for our audience in general. We hope that this blog will serve to aid those contemplating if it&#39;s worth putting in the effort into it and help you make a more informed decision. </p><h2>Last note - We’d still appreciate your support</h2><p>Even though we managed to achieve the Product of the Day ranking, we still continue to aim for the Product of the Week award. If you enjoyed this article,<strong> </strong><a title="https://www.producthunt.com/posts/permit-io" href="https://www.producthunt.com/posts/permit-io"><u><strong>please consider supporting us with a vote</strong></u></a> ♥️</p>]]></content>
        <author>
            <name>Daniel Bass</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[10 Exceptional Developer Tools Launched in 2023]]></title>
        <id>10-exceptional-developer-tools-launched-in-2023</id>
        <link href="https://www.permit.io/blog/10-exceptional-developer-tools-launched-in-2023"/>
        <updated>2023-09-11T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Explore New Developer Tools and Trends in 2023 - Enhance Your Workflow with the Latest Developer Tools]]></summary>
        <content type="html"><![CDATA[<h2>The 2023 Trends in Developer Tools</h2><p>During a retrospective meeting recently, we noted that we used more developer tools in the first half of this year than we did in the whole of 2021 and 2022 combined. The way developers like us use various tools to enhance our work seems to have shifted significantly in 2023.</p><p>Initially, it might appear that Large Language Models (LLM) and Artificial Intelligence (AI) are the primary drivers behind this surge in developer tool usage. On closer inspection, we discovered that only about 20% of the tools we are using are related to LLM and AI.</p><iframe
          width="500"
          height="405"
          frameBorder="0"
          allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
          allowFullScreen
          title="https://cards.producthunt.com/cards/posts/412562?v=1"
          src="https://cards.producthunt.com/cards/posts/412562?v=1"
        ></iframe><p>In this inspection, we uncovered a few emerging trends that have been shaping the developer landscape in 2023. These include serverless computing, observability platforms, event-driven architectures, and many others. We have focused on tools that demonstrate how these emerging trends boost developers&#39; productivity and enable them to create software more efficiently.</p><p>In this article, we aim to showcase the most exciting developer tools that were launched in 2023. Each of these tools reflects the innovative spirit driven by these new trends in the software industry. If you&#39;re a software developer looking to enhance your productivity, these tools are certainly worth exploring.</p><h2>1. From Product to Code - <a target='_blank' title="https://www.lottielab.com/" href="https://www.lottielab.com/"><u>Lottielab</u></a></h2><p>While web browsers are becoming increasingly robust and capable of handling complex animations, the process of creating them remains a challenge. Lottie is an interactive web application that provides a user-friendly interface for creating animations for your web applications, with no prior coding experience required. What&#39;s more, Lottie supports the import of vector files from other popular tools and even offers a Figma plugin that streamlines collaboration between product and engineering teams.</p><p>Our initial expectations for Lottie were modest, as is often the case with tools in this category. However, we were pleasantly surprised to find that Lottie leverages every web development trend to create a state-of-the-art product. Many features that were previously inaccessible to us are now just a few clicks away.</p><img src="https://media.graphassets.com/VtlOzHutSkCtaVJBrro0" alt="lottie.png" title="lottie.png" width="2486" height="1460" /><h2>2. Writing Code - <a target='_blank' title="https://docs.github.com/en/copilot/github-copilot-chat/using-github-copilot-chat" href="https://docs.github.com/en/copilot/github-copilot-chat/using-github-copilot-chat"><u>GitHub Copilot Chat</u></a></h2><p>In October 2021, GitHub released Copilot, fundamentally changing the way developers write code. It&#39;s rare to find a developer today who isn&#39;t using Copilot or one of the other AI-powered code assistants in their daily work. In 2023, just when we thought nothing could surprise us, GitHub introduced Copilot Chat. With a simple VSCode plugin, developers can now obtain answers to their daily tasks from Copilot Chat.</p><p>While it may seem like a natural extension of Copilot, we discovered that Copilot Chat has the potential to revolutionize our workflow. For instance, when developing SDKs for various programming languages, we can seek design input in languages we&#39;re not familiar with and receive answers from Copilot Chat. Moreover, for deeper insights, we can inquire about the reasons behind its decisions, providing us with objective answers.</p><img src="https://media.graphassets.com/ECOfELRsSnCkDcr36ZDM" alt="ui-demo.webp" title="ui-demo.webp" width="2500" height="1552" /><h2>3. Debugging - <a target='_blank' title="http://www.mirrord.dev/" href="http://www.mirrord.dev/"><u>mirrord</u></a></h2><p>While Kubernetes and other Cloud-Native technologies open up new possibilities in cloud architectures, they also make debugging much more challenging. If you&#39;re developing a distributed product that extensively relies on Kubernetes features, you&#39;re likely familiar with the challenges of debugging Kubernetes architectures on your local machine.</p><p>Mirrord, an open-source tool, offers a novel approach to debugging k8s clusters locally by mirroring only the relevant parts of the cluster to your local machine. Leveraging context from the cloud and remote access to other services, mirrord provides a comprehensive view of your cluster without the need to run it locally. We found that the more we embrace the cloud-native paradigm, the more we rely on mirrord to debug our services locally, saving us valuable developer hours every week.</p><h2>4. Deploying - <a target='_blank' title="https://www.winglang.io/" href="https://www.winglang.io/"><u>Wing Language</u></a></h2><p>Infrastructure as code and defining deployment configurations isn&#39;t a new concept. However, just when we thought this space couldn&#39;t see disruption, Wing Language emerged with the intention of transforming everything. Wing&#39;s approach is to replace the imperative code used for application runtime and the declarative code used for infrastructure deployment with a new language that combines both aspects.</p><p>Wing doesn&#39;t aim to replace all your application code but excels in what can be called the &quot;Frontend of the Backend.&quot; It provides a robust SDK for all things related to cloud infrastructure, along with an imperative language for the operations your API typically performs. When we adopted Wing for our new project, we found that it significantly reduced our time to production and facilitated the creation of flexible, easily maintainable code.</p><h2>5. Integrate - <a target='_blank' title="https://runalloy.com/unified-api/" href="https://runalloy.com/unified-api/"><u>Alloy Unified API</u></a></h2><p>It&#39;s common for modern applications to rely on other apps for extra functionality. These applications may include payment gateways, authentication systems, analytics tools, and more. While integrating with such APIs is relatively straightforward initially, it can become a maintenance and scaling nightmare as your application grows.</p><p>Alloy Unified API is a new tool designed to solve this problem by providing a unified API for all the integrations you need. With Alloy, you can define a single data model that connects multiple APIs, ensuring that you always receive relevant real-time data. We found Alloy to be invaluable when integrating our marketing and customer metrics with our product APIs, saving us considerable time and resources.</p><h2>6. Authenticate - <a target='_blank' title="https://www.descope.com" href="https://www.descope.com"><u>Descope</u></a></h2><p>While authentication SaaS toolkits have been around for a while, they often fall short of addressing the fundamental needs of modern distributed applications. Descope is a new authentication-as-a-service solution that prioritizes defining authentication workflows as first-class citizens.</p><p>With Descope, you don&#39;t configure each part of the service as a separate entity but instead define the authentication flow and let Descope handle the rest. For instance, if you want your application to support login via email, phone, and social media, you can define the authentication flow for each and let Descope take care of the rest. Furthermore, Descope employs passwordless methods (biometrics, magic links, etc.) to enhance security and user-friendliness. Descope checks almost every item on the modern authentication checklist, making it a valuable tool for any contemporary application.</p><h2>7. Authorize - <a target='_blank' title="https://io.permit.io/blog-ph" href="https://io.permit.io/blog-ph"><u>Permit.io</u></a></h2><p>Authorization is an integral part of almost any application out there, yet building it yourself in the context of modern architectures, and distributed systems can be challenging, not to mention time-consuming. Almost every permission decision in today&#39;s applications is based on multiple factors, including the user, the device, the location, the time, and more. Moreover, they often move away from using Role-Based Access Control (RBAC) in favor of more complex models (Such as Relationship and Attribute-Based Access Control -ReBAC/ABAC) to define permissions.</p><p>Permit.io, <a target='_blank' title="https://io.permit.io/blog-ph" href="https://io.permit.io/blog-ph"><u>recently launched on Product Hunt</u></a>, is a cloud service that simplifies permission definition through a user-friendly low-code UI interface. It supports all permission models (RBAC/ABAC/ReBAC) and seamlessly integrates with your application using their SDK, providing real-time insights into your permissions. Permit.io also offers detailed audit logs, Policy as Code for configuring permissions, GitOps features, rapid authorization decision times, and more - potentially saving months of development time.</p><img src="https://media.graphassets.com/uHFIbH5oQSOgRp0DnGPQ" alt="Low-Code UI Simplification (5).png" title="Low-Code UI Simplification (5).png" width="2540" height="1520" /><h2>8. Observe - <a target='_blank' title="https://www.keephq.dev" href="https://www.keephq.dev"><u>Keep</u></a></h2><p>In recent years, our application observability stacks have grown with an abundance of tools, each addressing different aspects of the observability puzzle. While these tools are essential for staying on top of the cloud game, they often flood us with data and alerts, turning observability into a full-time job.</p><p>Keep, an open-source tool that recently started offering a cloud service, takes a unique approach to address this issue through workflow automation. Instead of drowning in complex dashboards, you can create workflows that trigger when anomalies occur, allowing Keep to manage the rest. We initially used Keep to automate Slack messages for a specific use case in our application, but we soon realized its power in simplifying our dashboard complexity and reducing alert noise.</p><img src="https://media.graphassets.com/bmP4WNUhQXGAJo8KGH7M" alt="2UsV4cKmxMClrRWzqWBAfPORydU_builder.png" title="2UsV4cKmxMClrRWzqWBAfPORydU_builder.png" width="1880" height="1137" /><h2>9. Listen - <a target='_blank' title="https://trigger.dev/" href="https://trigger.dev/"><u>Trigger.dev</u></a></h2><p>While event-driven architecture isn&#39;t a novel concept, it has gained significant traction in recent years. With the native support of platforms like Vercel (Next.js) and Serverless, building event-driven applications has become more accessible. However, one crucial aspect was missing: creating long-running jobs that listen to events and trigger additional events based on business logic.</p><p>Trigger.dev is an open-source framework (with a cloud service) that simplifies the creation of event-driven applications. You can easily download their SDK and build long-running jobs directly into your codebase, complete with features like API integrations, webhooks, scheduling, and delays. We found Trigger.dev invaluable when developing a simple application that listens to events from our marketing tools and triggers events in our application, saving us significant time and resources.</p><h2>10. AI Agents - <a target='_blank' title="https://www.fine.dev" href="https://www.fine.dev"><u>Fine.dev</u></a></h2><p>While LLM and AI have gained popularity for solving various developer challenges, the user experience of these tools often focuses on the AI component rather than the developer&#39;s needs. Fine.dev seeks to bridge this gap by introducing AI agents into the realm of developers.</p><p>With Fine.dev, you can define custom AI agents that help developers with specific tasks tailored to their unique problems. Think of it as a chat agent but one that can be customized for specific stacks, technologies, applications, and more. We recently started using Fine.dev, and it feels like the missing piece in the AI puzzle. </p><h2>Conclusion</h2><p>In this article, we&#39;ve showcased the most exciting developer tools launched in 2023. Each of these tools embodies the innovative spirit driven by new trends in the software industry. Whether or not you intend to use them in production immediately, supporting early-stage developer tools has a significant impact on the industry. It fosters innovation and contributes to the future of our field.</p><p>Want to learn more about useful dev tools? <a target='_blank' title="https://io.permit.io/slack" href="https://io.permit.io/slack">Join our Slack community</a> and chat with other developers using low-code tools to create better applications.</p>]]></content>
        <author>
            <name>Gabriel L. Manor</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[You're Doing Shift-Left Wrong]]></title>
        <id>shift-left-best-practices</id>
        <link href="https://www.permit.io/blog/shift-left-best-practices"/>
        <updated>2023-09-07T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Learn from a real case study how to Shift-Left in a way that will impact the product's security. Minimize friction between security and development teams.]]></summary>
        <content type="html"><![CDATA[<h2>Introduction</h2><p>Shift left is everywhere. While it could be interpreted in many different ways, originating in the security space, implementing security features right from the start of your software development process is at the “Shift-Left” core. </p><p>There are security tools available for the early planning stages as well as the development stage, both helping you to make sure our application is safe from the very beginning.</p><h2>The Problem with Shift Left</h2><p><strong>But there&#39;s an inherent problem with &quot;Shift-Left&quot; works today</strong> - Developers don&#39;t like having their work measured all the time, and a lot of the tools promoting “shift left” just create more and more work for them. Instead of these tools assisting in the development process, they just become one more task on their to-do list. </p><p>Therefore, we must ask: Is it good to push security measurements into engineering? Or does it just create more unnecessary work for the development team?<br><br>The answer to this question presents as an alternative - focus on measurable intrinsic <strong>impact </strong>rather than broad-based <strong>measurement</strong>.</p><img src="https://media.graphassets.com/resize=width:1108,height:706/oPgoyXaoRKWgYzuU5CcC" alt="Image Source: INOVO Venture Partners" title="devsecops.png" width="1108" height="706" /><p><em>A comprehensive list of DevSecOps tools, most of them just measure security with no impact on the application.</em></p><p>Instead of endlessly measuring and analyzing our application’s security, we should strive to impact it in a meaningful way, by guiding and helping the developer to create an intrinsically more secure application; Turning <strong>proactive measurement</strong> into <strong>proactive design.</strong> To see how this can be achieved, let’s look at the example of application-level access control. </p><h2>The case study: Application-level access control</h2><p>In the traditional way &quot;Shift-Left&quot; of handling application-level authorization, a tool would be applied to check the access control layer to make sure that there are no mistakes in it and probe the API trying to get unauthorized access. This often creates extra work for the developer - constantly chasing around alerts, instead of aiding them with the implementation process. Before we dive into the alternative, let’s better understand what application-level control is. </p><h2>Authentication vs. Authorization</h2><p>Let’s start by making an important distinction: Access control consists of two main components: <a title="https://www.permit.io/blog/authn-vs-authz" href="https://www.permit.io/blog/authn-vs-authz"><u><strong>Authentication </strong></u><u>and </u><u><strong>Authorization</strong></u></a>. Many companies offer authentication services, allowing developers to easily verify user identities. Determining what actions a user can take after they log in (authorization) poses a bigger challenge.</p><p>Most authentication tools provide developers with straightforward code to integrate into their applications. They often supply an SDK, which gives developers a <strong>user </strong>object, based on which they can make the decision of allowed/denied. These products usually include a wide variety of pre-built features that developers can easily integrate into their code, such as MFA, User management, Login/Signup flows, etc. Not having to build these features from scratch saves a ton of valuable time and allows developers to incorporate secure, tested features into their applications with very minimal effort.</p><p>The existence of pre-built authentication tools creates a de-facto standard for building and implementing authentication. Instead of developers building it themselves, and security engineers providing them with ways to measure their own code, this standard directly <strong>impacts </strong>the way in which developers implement authentication, creating robust, industry-tested solutions.</p><p>Moving to authorization, the same kind of allow/deny decision is not only much harder to build, but the lack of unified industry standards only leaves us with measurement-based tools. In this reality, developers tend to <a title="https://www.permit.io/blog/roll-your-own-rbac" href="https://www.permit.io/blog/roll-your-own-rbac"><u>build their own homebrew authorization solutions</u></a> - leading to problematic results, with only measurement-based tools available to amend them.</p><h2>The Issue with Homebrew Authorization</h2><p>Let’s look at a typical way of implementing application-level authorization: </p><pre><code>// Middleware
if (req.user.roles.indexOf(role) === -1) {
    return res.send(403);
}

// Endpoint
@authz(&#39;admin&#39;)
const Document = () =&gt; {
    ...
}</code></pre><p>It typically begins with decorators. By employing a decorator, a developer can set security requirements, such as ensuring that only admin users can execute certain operations on specific resources. To achieve this, the developer constructs a <strong>middleware</strong>—a function that operates right before the endpoint is called—to verify if a user possesses the &quot;admin&quot; role.</p><p>Application security and usability requirements are, however, usually more nuanced than this. Developers usually end up writing more complex code in the middleware, allowing decorators to assign multiple permission models to endpoints.</p><p>As the authorization code evolves, it becomes difficult to ensure in a &quot;Shift-Left&quot; approach that authorization is adequately secure due to its decentralized nature, and we&#39;re often left in the dark about how to thoroughly analyze and review the decisions made during the authorization process.</p><p>Think of this example - We&#39;ve opted to let developers craft their own authorization layer. Then, the unthinkable happens: <strong>someone gains unauthorized access to our system</strong>.</p><p>Without a dedicated authorization system in place, a security engineer would examine the code, see the middleware, and recognize the framework that was promised to be secure, but the code offers no clarity on the breach&#39;s origin.</p><p>Vulnerabilities like this often occur when, for example, a well-intentioned developer deviates from the framework, deciding to introduce a simplistic &#39;if&#39; statement to decide user access. Unfortunately, such ad-hoc solutions can unintentionally grant unauthorized users access to protected resources.</p><p>In today&#39;s era of shift-left and DevSecOps, the tools at our disposal primarily help us assess and <strong>measure </strong>access control. However, our primary objective now should be to consider how we can positively <strong>impact </strong>and <strong>guide </strong>our developers toward crafting a more robust and efficient authorization system. This can be achieved by understanding the autonomous authorization lifecycle.</p><h2>The autonomous authorization lifecycle </h2><p>To create an autonomous authorization system that helps positively <strong>impact apps </strong>and <strong>guide </strong>our developers instead of just offering measurements, it needs to adhere to the following standards:</p><ul><li><div><p><strong>Policy Authorship:</strong> The initial step is giving our security engineers, or any other relevant stakeholders in the organization a straightforward process through which they can create authorization policies.</p></div></li><li><div><p><strong>Auditability</strong>: Once policies are in place, we must be able to review them consistently. A crucial aspect of any authorization system is the ability to perform audits on decisions made, ensuring that policies are being followed correctly and no unauthorized actions are taking place.</p></div></li><li><div><p><strong>Autonomy</strong>: A key feature of the system is its self-sufficiency. We should be able to manage the entire authorization lifecycle without constantly altering the application&#39;s code. Whether it&#39;s auditing or authoring policies, these actions should not be coupled with the application&#39;s intricacies.<br><br></p><img src="https://media.graphassets.com/SFhMib6mSjWml3YL99lH" alt="policy_lifecycle.png" title="policy_lifecycle.png" width="1074" height="1097" /></div></li></ul><p>In essence, as we plan our authorization system, our foremost goal should be to establish a robust, self-reliant authorization lifecycle, decoupled from the application itself. This ensures agility, security, and efficiency in managing access rights and privileges. Understanding the autonomous authorization life cycle can help us guide developers toward implementing high security standards from the very beginning of the systems development life cycle without any extra measurement and effort.</p><h2>How can we build such an authorization system?</h2><p>The first step in creating an authorization system such as the one we described earlier is to establish two Contracts: </p><ul><li><div><p>A contract between the <strong>Security team </strong>and the <strong>Development team </strong></p></div></li><li><div><p>A contract between the <strong>Authorization system </strong>and the <strong>Application</strong></p></div></li></ul><p>Both of these contracts require us to establish a clear agreement on <strong>how we configure authorization policies </strong>and how we <strong>execute these configurations</strong>. </p><p>Both of these contracts can be achieved by employing a <strong>policy engine</strong>. A policy engine allows us to adhere to several important authorization best practices: </p><ul><li><div><p><strong>Decoupling Policy from Code:</strong> Utilizing a Policy Engine helps us keep the policy separate from the application code. Embedding authorization logic directly in code can lead to oversights and complications, especially when changes are made. By decoupling, we also ensure that developers don&#39;t inadvertently create untraceable policies.</p></div></li><li><div><p><strong>Achieving Centralized Policy Management with Decentralized Architecture:</strong> Utilizing a Policy Engine allows us to keep policy management centralized for better control, uniformity, and ease of updates, and the architecture itself decentralized. This ensures the system is robust, scalable, and can work across various deployment environments, especially in a microservices-based architecture. </p></div></li><li><div><p><strong>Model Agnosticism:</strong> Policy engines allow support for the authorization system to work with different permission models, whether it&#39;s <a title="https://www.permit.io/blog/implement-rbac-using-opa" href="https://www.permit.io/blog/implement-rbac-using-opa"><u>RBAC</u></a>, <a title="https://www.permit.io/blog/what-is-abac" href="https://www.permit.io/blog/what-is-abac"><u>ABAC</u></a>, <a title="https://www.permit.io/blog/what-is-rebac" href="https://www.permit.io/blog/what-is-rebac"><u>ReBAC</u></a>, or any other model. This ensures longevity and adaptability, allowing for changes in security requirements without necessitating a system overhaul. Note that different policy engines are better suited to handle different authorization models. </p></div></li><li><div><p><strong>Developer Experience (DevEx) First: </strong>Prioritizing developer experience is crucial. A system that&#39;s difficult or cumbersome to use will be resisted or improperly implemented. The system should seamlessly integrate into a developer&#39;s workflow, not disrupt it.</p></div></li></ul><p>There are<a title="https://www.permit.io/blog/policy-engines" href="https://www.permit.io/blog/policy-engines"><u> several options </u></a>when it comes to picking a policy engine. Each offers unique features and benefits, catering to different use cases and organizational needs. In this article, we want to focus on how you can achieve an autonomous, modern, and robust authorization system with AWS Cedar.</p><h2>AWS Cedar</h2><p><a title="https://www.permit.io/blog/oss-aws-cedar-is-a-gamechanger-for-iam" href="https://www.permit.io/blog/oss-aws-cedar-is-a-gamechanger-for-iam"><u>Cedar</u></a> is a language for writing authorization policies, together with an engine for evaluating those policies to make authorization decisions, offering a unique approach to <a title="https://www.permit.io/blog/opa-vs-cedar#the-benefits-of-using-pac" href="https://www.permit.io/blog/opa-vs-cedar#the-benefits-of-using-pac"><u>Policy-as-Code</u></a>. While other policy languages (like <a title="https://www.permit.io/blog/introduction-to-opa" href="https://www.permit.io/blog/introduction-to-opa"><u>Rego</u></a>) tend to offer a multi-propose language that could fit into application-level authorization, Cedar is built with application-level authorization in mind. </p><p>Aside from impressive performance, one of the most significant advantages of Cedar is its readability. The language is designed to be extremely readable, empowering even non-technical stakeholders to read it (if not write it) for auditing purposes. Cedar policies are written in a declarative language, which means they can be easily understood and audited. It is also possible to ensure that policies are enforced correctly with Cedar&#39;s policy testing and simulation features.</p><p></p><img src="https://media.graphassets.com/csyKHKrzTuqAq1yYPYUd" alt="lifecycle_cedar.png" title="lifecycle_cedar.png" width="1074" height="1097" /><p><em>Cedar autonomous lifecycle</em></p><p>Considering the authorization cycle with Cedar at its center:</p><ol><li><div>The Cedar File: This is the policy blueprint, essentially the foundation where rules and permissions are defined. You can read more about how a Cedar policy is designed <a title="https://www.permit.io/blog/cedar-rbac" href="https://www.permit.io/blog/cedar-rbac"><u>here</u></a>.</div></li><li><div><a title="https://github.com/permitio/cedar-agent" href="https://github.com/permitio/cedar-agent"><u>Cedar Agent</u></a>: an open-source project that allows for easy deployment of Cedar policies within your application. Acting as an HTTP server, Cedar Agent efficiently manages a policy store and a data store, allowing you to easily control and monitor access to your application&#39;s resources.</div></li><li><div>Cedar Agent Logs: Post-decision, the agent maintains a log, capturing the specifics of every verdict. This log serves as a pivotal audit trail.</div></li><li><div>At the heart of this setup is the application, which can seamlessly interact with the Cedar agent using an agnostic HTTP API. Whether it&#39;s to access audit logs, fetch the Cedar file, or liaise with the agent, the application&#39;s connection ensures an optimized authorization lifecycle that remains independent of the application’s intrinsic operations.</div></li></ol><h2>Why use Cedar?</h2><p>By using Cedar, we can leverage all the previously mentioned best practices in one solution:</p><ul><li><div><p>The Cedar language gives us a coherent way to define <strong>policies</strong> and <strong>decouple</strong> them from the <strong>application code</strong>. </p></div></li><li><div><p>Cedar is a <strong>model-agnostic</strong> language. This allows engineers to use it to <a title="https://www.permit.io/blog/cedar-rbac" href="https://www.permit.io/blog/cedar-rbac"><u>define RBAC</u></a>, ABAC, and even simple ReBAC, using simple structuring guidelines.</p></div></li><li><div><p>The Cedar agent, together with <a title="https://www.permit.io/blog/gitops-today-why-and-how" href="https://www.permit.io/blog/gitops-today-why-and-how"><u>GitOps best practices</u></a>, allows us to keep the configuration in a <strong>central</strong> environment. At the same time, the Cedar agent can run in a <strong>decentralized</strong> fashion across our deployments, maintaining the same config everywhere. </p></div></li><li><div><p>Cedar agent supports rich <strong>audit logs</strong> that give us an easy overview of the authorization layer when trying to <strong>analyze</strong> and understand the reasoning behind a decision. </p></div></li><li><div><p>At its heart, Cedar is a policy language created for application-level authorization, unlike other general-purpose languages. Using Cedar and its ecosystem gives the developer building access control <strong>exactly what they need</strong>, instead of creating more friction with useless features and steep learning curves. </p></div></li></ul><h2>Bottom line: Don’t just measure - Impact! </h2><p>Looking at the <a title="https://owasp.org/www-project-top-ten/" href="https://owasp.org/www-project-top-ten/"><u>OWASP top 10 Security risks</u></a> in the past years, we can see the highest-ranked access control vulnerabilities changed from authentication to authorization. Today, authorization alone holds three of the top 10 places on the <a title="https://www.permit.io/blog/owasp-2023" href="https://www.permit.io/blog/owasp-2023"><u>OWASP top 10 API Security risks for 2023</u></a> list. </p><p>Authentication has changed, focusing on impacting developers instead of “Shifting-left” by measuring them. It’s time authorization goes through the same process. Using authorization tools like AWS Cedar or Permit.io allows developers to create better authorization systems that make good use of the “Shift-Left” trend, focusing on impacting development from day one. </p><p>Want to learn more about Authorization and access control? Join our <a title="https://io.permit.io/permitslack" href="https://io.permit.io/permitslack"><u>Slack Community</u></a>, where world-class authorization specialists and hundreds of devs are discussing, building, and implementing authorization together.</p>]]></content>
        <author>
            <name>Daniel Bass</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[How to Implement Relationship-Based Access Control (ReBAC) Using Open Policy Agent (OPA)]]></title>
        <id>relationship-based-access-control-rebac-with-open-policy-agent-opa</id>
        <link href="https://www.permit.io/blog/relationship-based-access-control-rebac-with-open-policy-agent-opa"/>
        <updated>2023-09-06T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Learn how to implement Relationship-Based Access Control (ReBAC) with OPA - an open source policy engine for controlling access to systems and resources.]]></summary>
        <content type="html"><![CDATA[<p>Building authorization can be a complicated endeavor. There are different models for building authorization and different ways of implementing them. At the end of the day, only one thing matters - we want the<strong> right person</strong> to <strong>have the right access</strong> to the <strong>right thing</strong>. Authorization is not to be <a title="https://www.permit.io/blog/authn-vs-authz" href="https://www.permit.io/blog/authn-vs-authz"><u>confused with Authentication</u></a>, which is about verifying a user&#39;s identity. </p><p>ReBAC is an alternative model to other common ones - such as <a title="https://www.permit.io/blog/rbac-with-permit" href="https://www.permit.io/blog/rbac-with-permit"><u>Role Based Access Control (RBAC)</u></a> and <a title="https://www.permit.io/blog/what-is-abac" href="https://www.permit.io/blog/what-is-abac"><u>Attribute Based Access Control (ABAC)</u></a>. Note that these models are more thinking tools than concrete guidelines, and most applications end up mixing between them (especially as time passes and the applications evolve). It’s up to developers to pick the most suitable authorization model for their application at each moment in time. </p><p>In this blog, we will learn how to implement ReBAC with <a title="https://www.permit.io/blog/introduction-to-opa" href="https://www.permit.io/blog/introduction-to-opa"><u>Open Policy Agent</u></a> - an open-source policy engine for controlling access to systems and resources. OPA allows separating policy logic from application code, enabling easy policy management and updates without requiring code changes or deployments.</p><h2>What is ReBAC? </h2><p>ReBAC is a policy model focused exclusively on the relationships, or how resources and identities (aka users) are connected to each other and between themselves. The consideration of these relationships allows us to create authorization policies for <strong>hierarchical structures</strong>.</p><p>ReBAC allows us to <strong>derive </strong>authorization policies <strong>based on existing application-level relationships.</strong> Creating policies based on relationships, rather than roles or attributes, saves us from having to create authorization policies on a per-instance basis. </p><p>To better understand how ReBAC works, let’s look at two of the most common relationship types ReBAC allows us to handle: </p><ul><li><div><p><strong>Parent-child hierarchies</strong> are relationships where resources are <strong>nested </strong>under other resources. This allows us to create a policy such as:<br><em><br>A </em><em><strong>user </strong></em><em>who is</em><em><strong> </strong></em><em>assigned the role of an </em><em><strong>Owner </strong></em><em>on a </em><em><strong>folder </strong></em><em>will also get the </em><em><strong>Owner </strong></em><em>role on every </em><em><strong>file </strong></em><em>within that </em><em><strong>folder</strong></em><em>. </em><br><br>We can see that the user&#39;s access to the files is derived from the combination of two elements: The <strong>nesting </strong>of the files within the folder and their <strong>role </strong>on the folder. </p></div></li></ul><ul><li><div><p><strong>Organizations</strong> are relationships based on <strong>grouping </strong>together <strong>users</strong>. This allows us to create a policy like:<em><br><br>A </em><em><strong>user </strong></em><em>who is</em><em><strong> </strong></em><em>assigned the role of </em><em><strong>Member </strong></em><em>on</em><em><strong> RnD Team </strong></em><em>will also be assigned the role of </em><em><strong>Editor </strong></em><em>on </em><em><strong>RnD File</strong></em><em> when the </em><em><strong>RnD Team</strong></em><em> is the </em><em><strong>Parent </strong></em><em>of </em><em><strong>RnD File</strong></em><em>.</em><br><br>Putting several users in one group allows us to derive policies based on their group membership, instead of per individual user.</p></div></li></ul><p>A more in-depth review of ReBAC, including examples and implementation instructions, is available <a title="http://permit.io/blog/rebac" href="http://permit.io/blog/rebac"><u>here</u></a>.</p><h2>Why use Open Policy Agent (OPA) for ReBAC policies?</h2><p>The initial setup of policies for each individual service requires manual configuration within the service itself. As your policies, users, and services expand, managing updates across all relevant services becomes tedious and time-consuming.</p><p>Mixing the authorization layer&#39;s code with that of the application itself also creates difficulties when upgrading, adding capabilities, and monitoring the code as it is replicated across various microservices.</p><p>OPA allows us to create a separate microservice solely dedicated to authorization, <strong>effectively decoupling policies from the core application code</strong>. Controlling access management centrally through a separate authorization service allows you to offer it as a service to every system that needs to check whether a user can or cannot access its resources.</p><ul><li><div><p>OPA unifies all policies across each individual service in one server.</p></div></li><li><div><p>It takes on the role of policy decision-making and enforcement from the service: <br>The service queries OPA, OPA makes a decision, sends an output to the service, ⁠and the service acts according to OPA’s reply. </p></div></li><li><div><p>It allows you to have a policy as code that can be easily reviewed, edited, and rolled back.</p></div></li></ul><h2>How to implement ReBAC in OPA?</h2><p>In order to implement a ReBAC model using OPA, we will need to follow several steps:</p><ul><li><div><p>First, we must map out the policies we want to enforce. This will help us better understand what we want our authorization layer to accomplish from a functional perspective. </p></div></li><li><div><p>Map out the specific building blocks of our implementation - Resources, Actions, and Resource Roles. </p></div></li><li><div><p>Map out our Relationships and Role Derivations. These will allow us to create ReBAC policies. </p></div></li><li><div><p>Create a data file that will contain all of the relevant policy information in Rego</p></div></li><li><div><p>Write Rego code that checks access based on our created policy via the  `graph.reachable()` function. </p></div></li></ul><h3><strong>How will our Rego code work: </strong></h3><p>Here&#39;s our ReBAC Rego code:</p><pre><code># return a full graph mapping of each subject to the object it has reference to
full_graph[subject] := ref_object {
	some subject, object_instance in object.union_n([files, teams,organizations])
	# get the parent_id the subject is referring
	ref_object := [object.get(object_instance, “parent_id”, null)]
}
# … see full Rego code at https://play.openpolicyagent.org/p/4qkNc0GtPP
# rule to return a list of allowed assignments
allowing_assignments[assignment] {
	# iterate the user assignments
	some assignment in input_user.assignments
	# check that the required action from the input is allowed by the current role
	input.action in data.roles[assignment.role].grants
	# check that the required resource from the input is reachable in the graph
	# by the current team
	assignment.resource in graph.reachable(full_graph, {input.resource})
}</code></pre><p>The full rego code is available in<a title="https://play.openpolicyagent.org/p/4qkNc0GtPP" href="https://play.openpolicyagent.org/p/4qkNc0GtPP"> the OPA Playground </a></p><ol><li><div><p>The code builds a full graph based on the teams, files, and teams.</p></div></li><li><div><p>Iterates over the roles and teams assigned to the user by which the access request was made. </p></div></li><li><div><p>Using the `graph.reachable()` function, it checks the graph to see if the user has the appropriate team and role assignment to access the requested resource.</p></div></li><li><div><p>If there is a correlation between the user team assignment, the file team assignment, and the role, the request is allowed (allow rule returns true). Otherwise, the request is denied by default.</p></div></li></ol><p>*reach / reachable - means that the file node in the graph is linked to the team node in the graph </p><p><em>It’s important to note that `graph.reachable()` is a built-in function available in OPA since version v0.20.0.</em><br></p><p>Let’s go over these steps with a concrete example -<br></p><h2><strong>⁠⁠ReBAC with OPA demo application:</strong></h2><p>Take an organization’s file system. The organization consists of two teams, with each team having a list of files associated with it. Apart from that, we have a file within one of the teams associated with a specific user. </p><p>Here is a visual representation of the relationship policy we wish to set up:</p><p></p><img src="https://media.graphassets.com/ComIWgb1QoOZ3lWfX7ZB" alt="pasted image 0.png" title="pasted image 0.png" width="955" height="806" /><p><br></p><p>To set up our ReBAC policy as Rego code, we will need to follow these steps: </p><h3>1. Map out the policies we want to enforce:</h3><ul><li><div>Every user<strong> part of the “Acme” organization</strong> should have “<strong>View</strong>” access to <strong>every instance within the file system</strong>. </div></li></ul><ul><li><div><p>A user assigned as the <strong>Admin of a team</strong> should have “<strong>Admin</strong>” access to <strong>every file associated with their team</strong>.</p></div></li><li><div><p><strong>Tim</strong>, the company’s designer, should have “<strong>Admin</strong>” access to “<strong>logo.psd</strong>”. </p></div></li></ul><h3>2. Mapping our Application Resources and Actions</h3><p>Let’s map out all of the resources we require in our application, as well as the actions that can be performed on each resource: </p><ul><li><div><p>Organization: View</p></div></li><li><div><p>Team: View, Edit. </p></div></li><li><div><p>Files: View, Edit. </p></div></li></ul><h3>3. Mapping our Resource Roles</h3><p>In ReBAC, roles are not system-wide entities assigned to users (Like in RBAC). ReBAC requires us to set up roles per resource. This means that every single one of the resources we previously defined is going to have roles associated with it. Here are the roles we will have to associate with the resources in our demo application:</p><ul><li><div><p>Organization: Member (View) </p></div></li><li><div><p>Team: Admin (View, Edit), Teammate (View) </p></div></li><li><div><p> Files: Admin (View, Edit), Teammate (View)</p></div></li></ul><h3>4. Mapping our Resource Relationships</h3><p>Now, it’s time to define the relationships between all of our resources. This will allow us to create authorization policies based on these relationships later on:</p><ul><li><div><p>Marketing Files are nested under the Marketing Team. </p></div></li><li><div><p>RND Files are nested under the RND Team. </p></div></li><li><div><p>Both teams are nested under the “Acme” organization. </p></div></li></ul><h3>5. Deciding on our Role Derivations</h3><ul><li><div><p>If a user is a Member of the organization, they should have the viewer role on every resource nested under the organization. </p></div></li><li><div><p>If a user is the Admin of a team, they should receive an admin role on every file instance in that team. </p></div></li></ul><h3>6. Let’s take a look at our users, Sally and Tim:</h3><p><strong>Sally</strong>: </p><ul><li><div><p>Is part of the <strong>Acme organization</strong></p></div></li><li><div><p>Has the <strong>organizational role</strong> of `<strong>viewer`</strong>. Based on our derivations, she should be assigned the role of a viewer to every file within the organization. </p></div></li><li><div><p>Is part of the <strong>RND </strong>team</p></div></li><li><div><p>Has the<strong> team role</strong> of `<strong>admin`</strong>- Based on our derivations, she should receive the admin role on any file associated with the <strong>RND </strong>team. </p></div></li></ul><p><strong>Tim</strong>: </p><ul><li><div><p>Is part of the <strong>Acme organization</strong></p></div></li><li><div><p>Has the <strong>organizational role</strong> of `<strong>viewer`</strong>. Based on our derivations, he should be assigned the role of a viewer to every file within the organization. </p></div></li><li><div><p>Is part of the <strong>Marketing </strong>team</p></div></li><li><div><p>Has the <strong>admin </strong>role over the file `<strong>logo.psd</strong>`, him them to perform Admin level actions on this specific file. </p></div></li></ul><h3>Policy Data: </h3><p>Let’s see how the data for this policy looks in Rego. The <strong>data </strong>for this policy will consist of five parts:</p><p><strong>The organization:</strong> In our case, Acme, is the parent organization under which we have several teams. In a more complex scenario, we can have several different organizations with a more detailed hierarchy. </p><pre><code>{
⁠
    &quot;organizations&quot;: [
        {
            &quot;id&quot;: &quot;acme&quot;
        }
⁠
}</code></pre><p><strong>Teams: </strong>a list of all available teams. Both files and users will be associated with their respective teams:</p><pre><code>{
    &quot;teams&quot;: [
        {
            &quot;id&quot;: &quot;rnd&quot;,
            &quot;parent_id&quot;: &quot;organization:acme&quot;
        },
        {
            &quot;id&quot;: &quot;marketing&quot;,
            &quot;parent_id&quot;: &quot;organization:acme&quot;
        }
}</code></pre><p><strong>Roles:</strong> a list of all possible user roles relevant to the policy, along with the scopes for each role: </p><pre><code>{
    &quot;roles&quot;: {
        &quot;admin&quot;: {
            &quot;grants&quot;: [
                &quot;view&quot;,
                &quot;edit&quot;
            ]
        },
        &quot;viewer&quot;: {
            &quot;grants&quot;: [
                &quot;view&quot;
            ]
        }
}</code></pre><p><strong>Users:</strong> a list of our users, and their ids (For the purposes of this example, the ids are a combination of a user&#39;s team association and allocated role. In an actual scenario, these ids can be a user&#39;s email, a unique GUID, or whatever you choose it to be) and their assigned roles and teams: </p><pre><code>{
    &quot;users&quot;: [
        {
            &quot;assignments&quot;: [
                {
                    &quot;resource&quot;: &quot;organization:acme&quot;,
                    &quot;role&quot;: &quot;viewer&quot;
                },
                {
                    &quot;resource&quot;: &quot;team:rnd&quot;,
                    &quot;role&quot;: &quot;admin&quot;
                }
            ],
            &quot;id&quot;: &quot;sally&quot;
        },
        {
            &quot;assignments&quot;: [
                {
                    &quot;resource&quot;: &quot;team:marketing&quot;,
                    &quot;role&quot;: &quot;viewer&quot;
                },
                {
                    &quot;resource&quot;: &quot;file:design.psd&quot;,
                    &quot;role&quot;: &quot;admin&quot;
                }
            ],
            &quot;id&quot;: &quot;tim&quot;
        }
    ]
}</code></pre><p><strong>Files:</strong> a list of all the files relevant to the policy, along with their “team_id”, which associates them to a specific team:</p><pre><code>{
    &quot;files&quot;: [
        {
            &quot;id&quot;: &quot;backend-readme.md&quot;,
            &quot;parent_id&quot;: &quot;team:rnd&quot;
        },
        {
            &quot;id&quot;: &quot;frontend-readme.md&quot;,
            &quot;parent_id&quot;: &quot;team:rnd&quot;
        },
        {
            &quot;id&quot;: &quot;gateway-config.yaml&quot;,
            &quot;parent_id&quot;: &quot;team:rnd&quot;
        },
        {
            &quot;id&quot;: &quot;website.js&quot;,
            &quot;parent_id&quot;: &quot;team:marketing&quot;
        },
        {
            &quot;id&quot;: &quot;blog-1.pdf&quot;,
            &quot;parent_id&quot;: &quot;team:marketing&quot;
        },
        {
            &quot;id&quot;: &quot;logo.psd&quot;,
            &quot;parent_id&quot;: &quot;team:marketing&quot;
        }
}</code></pre><p><br>Now that we have our data established, let’s decide on the access policy we want to check for. </p><p>In this example, let’s check if `<code>sally</code>` can `<code>edit</code>` `<code>gateway-config.yaml</code>`. </p><p>To perform this check, this will be our <strong>input</strong>:</p><pre><code>{
      &quot;user&quot;: &quot;sally&quot;,
      &quot;action&quot;:&quot;edit&quot;,
      &quot;resource&quot;:&quot;file:gateway-config.yaml&quot;
}</code></pre><p><br>This results in the response you’d expect: <code>True</code>.</p><p><strong>Congrats! You have successfully implemented ReBAC in OPA! <br></strong><br><strong>A full demo repository of this Rego example </strong><a title="https://github.com/permitio/rebac-rego-example" href="https://github.com/permitio/rebac-rego-example"><u><strong>is available here</strong></u></a><strong>.</strong><br><br></p><p>Let’s go over what each part of the code and what it means in more detail:</p><ol><li><div><p><strong>resource_instances and teams rules</strong>: These rules create sets of resources and teams by their ids, respectively. They iterate over the <code>data.resources</code> and <code>data.teams</code> sets and extract the id of each instance. The result is a set where each item is the id of a resource or team.</p></div></li><li><div><p><strong>full_graph rule</strong>: This rule constructs a graph where the nodes are subjects (either a resource or a team), and the edges are references to other objects in the graph. The graph is represented as a dictionary where the key is the subject id, and the value is the parent id of the object it’s referring to.</p></div></li><li><div><p><strong>users and input_user rules:</strong> The <code>users</code> rule creates a set of users by their ids. The <code>input_user</code> rule then uses the user id from the input to get the user’s details from this set.</p></div></li><li><div><p><strong>allowing_assignments rule:</strong> This rule filters the assignments of the <code>input_user</code> to find those that allow to perform the requested action on the specified resource.  It does so by checking two conditions:</p></div><div><ol><li><div><p>The requested action is in the list of actions granted by the role associated with the assignment (using the <code>data.roles[assignment.role].grants</code> expression).</p></div></li><li><div><p>The team associated with the assignment can reach the requested resource in the graph. This is done using the <code>graph.reachable(full_graph,{input.resource})</code> function, which presumably checks if there is a path from the assignment’s team to the resource in the <code>full_graph</code>.</p></div></li></ol></div></li><li><div><p><strong>default allow and allow rules:</strong> These are the main decision rules of the policy. The <code>allow</code> rule will be true if there is at least one assignment that allows the action on the resource (as determined by the <code>allowing_assignments</code> rule). If there are no such assignments, the <code>default allow</code> rule sets the decision to <code>false</code>.</p></div></li></ol><h2>Scalable Implementation</h2><p>As application requirements evolve, the need to shift from simple authorization models to ReBAC can arise rapidly. Implementing and managing such complex authorization systems can be challenging for developers and other stakeholders, potentially leading to bottlenecks and inflexibility.</p><p>Setting up a system as complex as ReBAC could take months of work, which doesn’t end at the point of implementation - as creating additional roles, attributes, and policies requires complex R&amp;D work and steep learning curves. </p><p>The solution is implementing and managing your RBAC, ABAC, or ReBAC policies using an authorization service that allows for flexible transition between authorization models and provides a simple no-code UI that makes permission management accessible to other stakeholders. </p><p>That’s where Permit comes in - <br></p><h2>Permit.io: <a title="www.permit.io/rebac" href="www.permit.io/rebac">ReBAC with a no-code UI</a></h2><p>Permit provides developers with a permission management solution that allows for both smooth transitioning between RBAC, ABAC, and ReBAC without any changes to your application code, and the ability to create and manage policies using an accessible no-code UI. </p><p>Permit’s UI generates Rego code for <a title="http://permit.io/rbac" href="http://permit.io/rbac"><u>RBAC</u></a>, <a title="http://permit.io/abac" href="http://permit.io/abac"><u>ABAC</u></a>, and <a title="http://permit.io/rebac" href="http://permit.io/rebac"><u>ReBAC</u></a>, wrapping it nicely into Git, and API / UI interfaces which you can edit, add to, and manage however you like.</p><p>This allows both developers and other stakeholders to set up ReBAC policies and add complex graph hierarchies - all without having to write a single line of code. </p><p>Permit ReBAC is easily approachable via the low-code policy editor. You can easily define the relations (graph edges) between the resources (graph nodes) with a few clicks, and there’s no need to learn a complex schema language to begin.<br><br>You can check out how ReBAC can be implemented by using Pemit’s no-code UI <a title="http://permit.io/blog/rebac" href="http://permit.io/blog/rebac"><u>here</u></a>.</p><p>Implementing authorization with Permit ensures that everyone is included in the permission management process, preventing developers from becoming bottlenecks while also allowing a smooth transition between RBAC, ABAC, and ReBAC.</p><p>Want to learn more about Authorization? Join our <a title="https://io.permit.io/permitslack" href="https://io.permit.io/permitslack"><u>Slack community</u></a>, where there are hundreds of devs building and implementing authorization.</p>]]></content>
        <author>
            <name>Daniel Bass</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[What is Relationship-Based Access Control (ReBAC)?]]></title>
        <id>what-is-rebac</id>
        <link href="https://www.permit.io/blog/what-is-rebac"/>
        <updated>2023-08-30T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[What is Relationship Based Access Control, when should it be used, how can you implement it in your application, and how can you provide a UI for managing it?]]></summary>
        <content type="html"><![CDATA[<h1>What is ReBAC?</h1><h2>Introduction </h2><p>ReBAC is a policy model focused exclusively on the relationships, or how resources and identities (aka users) are connected to each other and between themselves. These connections are used to implement Authorization- i.e. ensuring that <strong>the right people and services have the right access to the right resources </strong>(Not to be <a title="https://www.permit.io/blog/authn-vs-authz" href="https://www.permit.io/blog/authn-vs-authz"><u>confused with Authentication</u></a>). </p><p>ReBAC is an alternative model to other common ones - such as <a title="https://www.permit.io/blog/rbac-with-permit" href="https://www.permit.io/blog/rbac-with-permit"><u>Role Based Access Control (RBAC)</u></a> and <a title="https://www.permit.io/blog/what-is-abac" href="https://www.permit.io/blog/what-is-abac"><u>Attribute Based Access Control (ABAC)</u></a>. Note that these models are more thinking tools than concrete guidelines, and most applications end up mixing between them (especially as time passes and the applications evolve). It’s up to developers to pick the most suitable authorization model for their application at each moment in time. </p><p>In this blog, we will dive into what Relationship-Based Access Control (ReBAC) is, examine the pros and cons of this model to better understand the use cases that it’s suitable for, discuss the importance of scalable implementation, and see implementation options, including with Permit.io - a no-code UI solution for authoring and managing Policy as Code.</p><h2>Policy as a Graph</h2><p>Relationship-Based Access Control (ReBAC) extends RBAC by considering<strong> relationships between identities and resources</strong>. The consideration of these relationships allows us to create authorization policies for <strong>hierarchical structures</strong>.</p><p>It is easiest to visualize ReBAC <strong>as a graph</strong>, with each node on the graph representing a resource or identity, and each edge representing a relationship. </p><p>Graph-based authorization systems are perfect for mapping <strong>hierarchies and nested relationships.</strong> Given their ability to manage high volumes of data while maintaining consistency, these systems also prove effective in large-scale environments.</p><h2>So how does ReBAC help us exactly? </h2><p>The simplest example to portray the capabilities of ReBAC is by looking at an example of any file system (e.g. <a title="https://docs.permit.io/modeling/google-drive" href="https://docs.permit.io/modeling/google-drive"><u>Google Drive</u></a>): </p><img src="https://media.graphassets.com/rP7TGtwCSSej5IcIpBKD" alt="ReBAC 1.png" title="ReBAC 1.png" width="967" height="570" /><p>This graph displays a folder titled “Bob’s Files”. Within that folder, there are two additional folders - “Bob’s Docs” and “Bob’s Pics”. Inside each of these folders are several files. How would we go about managing Bob’s access to his files? </p><p>To understand how ReBAC helps us do this, we need to understand two basic terms:</p><p><strong>Role Derivation</strong> - <br><br>ReBAC allows us to <strong>derive </strong>authorization policies <strong>based on existing application-level relationships.</strong> Put in the simplest way, it allows us to create a policy like this:</p><p>A <strong>user </strong>who is<strong> </strong>assigned the role of an <strong>Owner </strong>on a <strong>folder </strong>will also get the <strong>Owner </strong>role on every <strong>file </strong>within that <strong>folder</strong>. </p><p>Creating policies based on relationships rather than roles or attributes saves us from having to create authorization policies on a per-instance basis. </p><p><br><strong>Resource Roles - </strong></p><p>To create ReBAC policies, we need to create roles specific to a given resource. This means that the role, and the permissions it carries, are only relevant in the context of that specific resource. A resource role is formatted as <strong>Resource#Role</strong>. <br><br>In the context of our previous example, “A <strong>user </strong>who is<strong> </strong>assigned the role of an <strong>Owner </strong>on a <strong>folder</strong>” will look like this: <strong>Folder#Owner</strong>.</p><p>The combination of Resource Roles and Role Derivations allows us to <strong>derive </strong>much more complex and granular roles <strong>that are perfectly tailored to handle hierarchies</strong>.</p><p></p><img src="https://media.graphassets.com/bQ4ZxwxYT0a4jaM3Obhp" alt="ReBAC 2.png" title="ReBAC 2.png" width="967" height="570" /><p><br>With role derivation, we can construct authorization policies that are <strong>far more efficient for hierarchies than RBAC </strong>and <strong>easier to manage than with ABAC</strong>. In <strong>RBAC</strong>, we would have to assign Bob a <strong>role </strong>that grants him direct access to each folder and file. In <strong>ABAC</strong>, we would add an “Owner” <strong>attribute </strong>to each of the files and folders and grant Bob a role that allows him to access all files and folders in which an “Owner” attribute references Bob’s ID.</p><p>Relationships are at the core of ReBAC, so let&#39;s take a closer look at what they can look like. Here are some of the most common relationship types and how they can be leveraged by ReBAC -</p><h2>Common Relationship Types</h2><h3>Parent-Child Hierarchies </h3><p>A parent-child hierarchy describes the <strong>nesting </strong>of resources under other resources. This scenario is similar to what we know from computer file systems - Files being categorized under folders. </p><p>In the context of ReBAC, such a relationship allows us to derive roles based on the relationship between two resources, like in the previous example: </p><img src="https://media.graphassets.com/uYiTRVJT7KH9rb15wbpi" alt="ReBAC 3.png" title="ReBAC 3.png" width="967" height="570" /><p>The ReBAC policy for this graph will look like this: </p><p>A <strong>user </strong>who is<strong> </strong>assigned the role <strong>Folder#Owner </strong>will also be assigned the <strong>File#Owner </strong>when the <strong>Folder </strong>instance is the <strong>Parent </strong>of a <strong>FIle </strong>instance.</p><p>In simpler words, if a file resides inside a folder (That’s the Parent-Child relationship), and a user is assigned the owner of that folder, they will also be the owner of the files. </p><h3>Organizations</h3><p>An organizational relationship allows us to create policies based on groups of users. Putting several users in one group allows us to derive policies based on their group membership, instead of per individual user. Take this example: </p><p></p><img src="https://media.graphassets.com/gTrUj0fZRV6RgqdKvXYv" alt="ReBAC 4.png" title="ReBAC 4.png" width="695" height="496" /><p><br>Bob, Sam, and Linda are all part of the HR team. We want to grant them editing access to all files the employee data files. Instead of assigning each of them direct editor access to each file, we group them all under the HR Team. This is done via a policy like - </p><p>A <strong>user </strong>who is<strong> </strong>assigned the role <strong>HR_Group#Member </strong>will also be assigned the <strong>Legal_Docs#Editor </strong>when the <strong>HR_Group</strong> is the <strong>Parent </strong>of <strong>Legal_Docs</strong>.</p><p>This allows us to give every user editing permissions for every file, without the need to set an explicit direct relationship between each user and each file. If we decide to add members or resources to the group, the policy&#39;s logic remains valid, and we wouldn’t have to update it for every change we make.</p><h2>How to implement ReBAC - Modeling your system:</h2><p>The next section reviews a demo application simulating a healthcare provider member app and shows how you can implement it using Permit.io. Permit allows developers to implement a ReBAC model into any application by using a simple SDK and a low-code UI.<br><br>You can see a working example of this healthcare demo application modeled using Permit <a title="https://github.com/permitio/Galactic-Health-Corporation" href="https://github.com/permitio/Galactic-Health-Corporation"><u>in this GitHub repo</u></a>.</p><p>The first step to understanding how ReBAC should be implemented into your application is to visually map out the resources you want to manage access to via relationships. This can be done by putting all of your resources (As nodes) and the relationships between them (As edges) on a graph. This should allow you to better visualize the policies you would need to create. </p><p>In this section, we will map out our demo application’s structure, and then display it on a graph. After that, we would be able to add actual users and instances into the mix. </p><h3>1. Map out our required policies</h3><p>Let&#39;s take a look at the policies we will want to enforce:</p><ul><li><div><p>Every <strong>app user</strong> should be able to view all of their <strong>own data</strong> (health plan, Medical records, and profile data).</p></div></li><li><div><p>App users should be able to see the <strong>profiles </strong>of<strong> other members</strong> in their <strong>patient groups</strong> (Family members, Caregivers, etc.).</p></div></li><li><div><p><strong>Admins </strong>should be able to <strong>assign users</strong> to <strong>patient groups</strong>.</p></div></li><li><div><p>App users should be able to assign a <strong>caregiver role</strong> to other members of their member group, allowing them to <strong>view their data </strong>(health plan and medical records).</p></div></li></ul><h3>2. Mapping our Application Resources and Actions</h3><p>Let’s map out all of the resources we require in our application, as well as the actions that can be performed on each resource: </p><ul><li><div><p>Member (Basically a user’s member profile): View, Edit</p></div></li><li><div><p>Health Plan: View</p></div></li><li><div><p>Medical Records: View</p></div></li><li><div><p>Patient Group: View, Assign, Unassign</p></div></li></ul><h3>3. Mapping our Resource Roles</h3><p>In ReBAC, roles are not system-wide entities assigned to users (Like in RBAC). <strong>ReBAC requires us to set up roles per resource</strong>. This means that every single one of the resources we previously defined is going to have roles associated with it. Here are the roles we will have to associate with the resources in our demo application:</p><ul><li><div><p>Member: Owner (Can view and edit), Group Member (Can view), Caregiver (Can view). </p></div></li><li><div><p>Health Plan: Owner (Can view and edit), Caregiver (Can view)</p></div></li><li><div><p>Medical Records: Owner (Can view and edit), Caregiver (Can view)</p></div></li><li><div><p>Patient Group: Admin (Can view, assign, unassign), Group Member (Can view)</p></div></li></ul><p>To set this up in Permit:</p><ul><li><div><p>Go to the ‘Policy Editor’ page, and click on the “Resources” tab</p></div></li><li><div><p>Add our four resources, actions, and, under “ReBAC Options” - resource roles.  <br><br></p><img src="https://media.graphassets.com/ClmExeLkRpW4niWwvolJ" alt="ReBAC 5.png" title="ReBAC 5.png" width="704" height="1114" /></div></li></ul><ul><li><div>Go to the ‘Policy Editor’ tab, and check the boxes to set up the relevant permissions for each resource role. <br></div><div><img src="https://media.graphassets.com/ZkBTIY5oTeOCfXa1j8TN" alt="ReBAC 6.png" title="ReBAC 6.png" width="1600" height="921" /></div><div></div></li></ul><h3>4. Mapping our Resource Relationships</h3><p>Now, it’s time to define the relationships between all of our resources. This will allow us to, later on, create authorization policies based on these relationships. </p><ul><li><div><p>A member can belong to a patient group</p></div></li><li><div><p>Each member has their own health plan and medical records<br><br>To set this up in Permit:</p></div></li><li><div><p>Open the ‘Resources’ tab, and edit the resource to which you want to add relationships.</p></div></li><li><div><p>Under “Relations”, set up the relevant relationships via the UI. </p><img src="https://media.graphassets.com/a6dF66NQiCySjGqZGrnX" alt="ReBAC 7.png" title="ReBAC 7.png" width="480" height="182" /><p></p></div></li></ul><h3>5. Deciding on our Role Derivations</h3><ul><li><div><p>If a <strong>user </strong>is the <strong>owner </strong>of a <strong>member </strong>(The member resource serving a member profile), they should have the <strong>owner role</strong> on their own <strong>medical records </strong>and <strong>health plan</strong> instances. </p></div></li><li><div><p>If a <strong>user </strong>is the <strong>caregiver </strong>of a <strong>member </strong>(Thus, they have a<strong> caregiver role</strong> on a member instance), they should receive a <strong>caregiver role</strong> on the <strong>medical records </strong>and <strong>health plan</strong> instances of the same member. </p></div></li><li><div><p>If a <strong>user </strong>is a <strong>member </strong>of a<strong> patient group</strong> (Thus, they have a <strong>Group Member</strong> role in a patient group instance), they should receive a <strong>Group Member</strong> role on other <strong>member </strong>instances belonging to the same <strong>patient group</strong>. <br><br>To set this up in Permit:</p></div></li><li><div><p>Open the ‘Roles’ tab, and open the role you want to add derivations to. </p></div></li><li><div><p>Under ‘ReBAC Options’,  set up the required derivation via the UI: </p><img src="https://media.graphassets.com/qMetQVkSTK6baZjJwb8x" alt="ReBAC 8.png" title="ReBAC 8.png" width="445" height="480" /><p></p></div></li></ul><p>Now let’s see how everything we set up would look on a graph: </p><p></p><img src="https://media.graphassets.com/XPu3LMZLSrWFgKMvG9u9" alt="ReBAC 9.png" title="ReBAC 9.png" width="756" height="468" /><p><br><br>Now that we have our system model set up, we can continue to discuss how this model can be implemented in a real application.</p><h2>How to implement ReBAC - Real-world example</h2><p>Let’s take everything we set up in the previous stage of modeling our system and apply it to a real-world scenario with two actual users - Sam and Bob.</p><p></p><img src="https://media.graphassets.com/FGUeloDNQg6Iu3WQ0MI9" alt="ReBAC 10.png" title="ReBAC 10.png" width="798" height="697" /><p><br>Let’s break this apart and see what’s going on here. <br><br>Let’s first look at the direct relationships (In black) and role assignments (In green): </p><ol><li><div><p>We have one <strong>Patient Group</strong> instance, with Bob as an <strong>Admin </strong>and Sam as a <strong>Group Member</strong>. </p></div></li><li><div><p>We have two <strong>Member Profile </strong>instances that belong to the same <strong>Patient Group</strong>. Bob and Sam each have an <strong>Owner </strong>role assignment to <strong>their own Member Profile</strong> instances. </p></div></li><li><div><p>Bob is assigned as a <strong>Caregiver </strong>to Sam’s <strong>Member Profile </strong>instance. </p></div></li><li><div><p>Each <strong>Member Profile </strong>instance is a parent of two resource instances: <strong>Medical Plan</strong> and <strong>Medical Record</strong>.</p></div></li></ol><p>Now, let’s look at our role derivations: </p><ol><li><div><p>Sam has a <strong>Group Member</strong> role on Bob’s <strong>Member Profile </strong>instance, derived from his <strong>Group Member</strong> role assignment on the Smith Family <strong>Patient Group</strong>. This allows Sam to view Bob’s Member details. </p></div></li><li><div><p>Both Sam and Bob have an <strong>Owner </strong>role on their <strong>Medical Plan</strong> and <strong>Medical Records</strong>. This is derived from their <strong>Owner </strong>role assignment of their <strong>Member Profile </strong>instances. </p></div></li><li><div><p>Bob has a <strong>Caregiver </strong>role on Sam’s <strong>Medical Plan</strong> and <strong>Medical Records</strong>. This is derived from his <strong>Caregiver </strong>role on Sam’s <strong>Member Profile </strong>instance. </p></div></li></ol><p>Using Permit’s APIs, with functions such as <a title="https://api.permit.io/v2/redoc#tag/Users/operation/update_user" href="https://api.permit.io/v2/redoc#tag/Users/operation/update_user"><u>sync_user</u></a>, , and <a title="https://api.permit.io/v2/redoc#tag/Role-Assignments/operation/assign_role" href="https://api.permit.io/v2/redoc#tag/Role-Assignments/operation/assign_role"><u>assign_role</u></a>, you can easily reproduce this policy structure in a real-life application without the hassle of modeling everything yourself from scratch. Using Permit’s <a title="https://docs.permit.io/category/sdk" href="https://docs.permit.io/category/sdk"><u>SDKs</u></a> also saves you the time of coding the API calls yourself.</p><pre><code>await permit.api.roleAssignments.assign({
      user: sam,
      role: &#39;group_member&#39;,
      resource_instance: `patient_group:bobs_group`,
      tenant: &#39;default&#39;,
  });</code></pre><pre><code>await permit.api.relationshipTuples.create({
      subject: `patient_group:bobs_group`,
      relation: &#39;belongs&#39;,
      object: `member:sam`,
      tenant: &#39;default&#39;,
  });</code></pre><p><em>An example of using Permit’s NodeJS SDK - Assigning Sam the role of “Group Member” in Bob’s patient group and creating a Relationship Tupple between Bob’s Group and Sam’s Member Profile. </em></p><h2>ReBAC Pros and Cons</h2><p>Now that we have discussed implementation, let’s do a quick review of the pros and cons of choosing ReBAC as your policy model:</p><h3>ReBAC Pros</h3><ul><li><div><p><strong>Handling Complex Hierarchies</strong>: ReBAC is designed to represent hierarchies and nested relationships, making it the most suitable choice for managing permissions for complex hierarchical relationships. </p></div></li><li><div><p><strong>Enables reverse indices</strong>: ReBAC’s graph structure allows for reverse queries (not only does x have access to y, but also who has access to y).</p></div></li><li><div><p>Using ReBAC allows us to <strong>define permissions en masse</strong> instead of doing it individually for every single resource by using teams and groups. </p></div></li><li><div><p><strong>RBAC alternative</strong>: The combined use of relationships together with roles is a good way to avoid RBAC role explosion (in which, for the sake of granularity, many roles are created, making it extremely hard to manage / audit)</p></div></li></ul><h3>ReBAC Cons</h3><ul><li><div><p><strong>Complexity:</strong> Implementing, managing, and maintaining ReBAC by yourself can be complex and time-consuming.</p></div></li><li><div><p><strong>Resource-intensive:</strong> ReBAC&#39;s consideration of numerous attributes can require significant processing power and time.</p></div></li><li><div><p><strong>Difficult to audit:</strong> The complexity and recursive nature of ReBAC policies can make auditing challenging.</p></div></li><li><div><p><strong>Not a replacement for ABAC:</strong> Though much more granular than RBAC, ReBAC still struggles with truly fine-grained, or dynamic permissions - such as rules dependent on attributes like time, location, quotas, etc.</p></div></li></ul><h2>Scalable Implementation</h2><p>As application requirements evolve, the need to shift from simple authorization models to RBAC, ABAC, or ReBAC can arise rapidly. Implementing and managing such complex authorization systems can be challenging for developers and other stakeholders, potentially leading to bottlenecks and inflexibility.</p><p>Setting up a system as complex as ReBAC could take months of work, which doesn’t end at the point of implementation - as creating additional roles, attributes, and policies requires complex R&amp;D work and steep learning curves.</p><p><a title="www.permit.io/rebac" href="www.permit.io/rebac"><strong>Permit’s UI</strong></a> allows us to define our required role derivation logic, generates code for us, and pushes any updates or changes to our application in real-time. Implementing authorization with Permit ensures that everyone is included in the permission management process, preventing developers from becoming bottlenecks. </p><p>Want to learn more about Authorization? Join our <a title="https://io.permit.io/permitslack" href="https://io.permit.io/permitslack"><u>Slack community</u></a>, where there are hundreds of devs building and implementing authorization.</p>]]></content>
        <author>
            <name>Daniel Bass</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Policy Engines: Open Policy Agent vs AWS Cedar vs Google Zanzibar]]></title>
        <id>policy-engines</id>
        <link href="https://www.permit.io/blog/policy-engines"/>
        <updated>2023-08-17T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Choosing the right policy agent to handle your authorization is not a simple task - each offers its benefits and has its drawbacks. How to choose? Read here. ]]></summary>
        <content type="html"><![CDATA[<p>Navigating the complex world of access control and authorization in modern software systems requires the right authorization solutions. In this article, we explore three powerful approaches: <a title="https://www.permit.io/blog/introduction-to-opa" href="https://www.permit.io/blog/introduction-to-opa"><u>Open Policy Agent (OPA)</u></a>, <a title="https://aws.amazon.com/about-aws/whats-new/2023/05/cedar-open-source-language-access-control/" href="https://aws.amazon.com/about-aws/whats-new/2023/05/cedar-open-source-language-access-control/"><u>AWS Cedar</u></a>, and <a title="https://www.permit.io/blog/zanzibar-vs-opa" href="https://www.permit.io/blog/zanzibar-vs-opa"><u>Google Zanzibar</u></a>. Each of these systems offers unique features and benefits, catering to different use cases and organizational needs. Let’s dive into the strengths and limitations of these policy-based authorization systems, so you can make an informed decision for your application&#39;s security and scalability.</p><h3>Open Policy Agent (OPA) Based</h3><p><a title="https://github.com/open-policy-agent/opa" href="https://github.com/open-policy-agent/opa"><u>OPA</u></a> is an open-source policy engine for controlling access to systems and resources. </p><p>It uses a high-level declarative language called Rego to define policies and evaluate complex authorization rules. With OPA, you can separate policy logic from your application code, enabling easy policy management and updates without requiring code changes or deployments. OPA has gained significant industry adoption and is backed by a thriving community, making it a reliable choice for building robust and fine-grained authorization services.</p><p><strong>Advantages of using OPA:</strong></p><ul><li><div><p>Policy-as-Code: OPA uses the Rego language to define policies, allowing policies to be treated as code with benefits such as versioning, auditing, and transparent review processes.</p></div></li><li><div><p>Performance: OPA stores policies and data in an in-memory cache, resulting in fast policy evaluations, even for complex rules.</p></div></li><li><div><p>Fine-Grained Permissions: OPA supports Role-Based Access Control (RBAC), Attribute-Based Access Control (ABAC), and Relationship-Based Access Control (ReBAC, With certain adjustments), enabling granular permissions management. Here are some useful examples: </p></div><div><ul><li><div><p><a title="https://www.permit.io/blog/implement-rbac-using-opa" href="https://www.permit.io/blog/implement-rbac-using-opa"><u>Role-Based Access Control (RBAC) with OPA</u></a></p></div></li><li><div><p><a title="https://www.permit.io/blog/implement-abac-using-opa" href="https://www.permit.io/blog/implement-abac-using-opa"><u>Attribute-Based Access Control (ABAC) with OPA</u></a></p></div></li></ul></div></li></ul><ul><li><div><p>Industry Adoption: OPA is widely used by <a title="https://www.permit.io/blog/netflix-authz" href="https://www.permit.io/blog/netflix-authz"><u>prominent industry players like Netflix</u></a>, Pinterest, and Goldman Sachs, indicating its credibility and reliability.</p></div></li></ul><p><strong>Disadvantages of using OPA:</strong></p><ul><li><div>Learning Curve: There is a significant learning curve associated with the Rego language used by OPA, which may require some initial investment in understanding its syntax and rules. As Rego is a logical programming language (like Datalog or Prolog) and less like common languages like Python or Go.</div></li></ul><p><strong>Some additional considerations: </strong></p><ul><li><div><p>Some rules rely on real-time user data (i.e., if the user is a subscriber or not). Real-time policy updates can be very complex to achieve with OPA.</p></div></li><li><div><p>Rules that rely on multiple data sources require bundling that is not straightforward.</p></div></li><li><div><p>It can be challenging to keep all OPAs in sync when running more than one OPA instance.</p></div></li></ul><p>While not supported by OPA by itself, these three issues can be resolved by using <a title="https://www.permit.io/blog/introduction-to-opal" href="https://www.permit.io/blog/introduction-to-opal"><u>OPAL</u></a> on top of OPA, which offers an admin layer on top of and serves real-time updates. </p><p>All in all, by leveraging OPA, you can benefit from a mature and widely adopted solution that provides flexibility, decoupling of code and policy, compatibility with various systems, and efficient policy evaluations.</p><p>A more detailed guide to OPA is available <a title="https://www.permit.io/blog/introduction-to-opa" href="https://www.permit.io/blog/introduction-to-opa"><u>here</u></a>. </p><p></p><h3>Cedar-Based</h3><p><a title="https://www.cedarpolicy.com/" href="https://www.cedarpolicy.com/"><u>AWS Cedar</u></a> is <a title="https://www.permit.io/blog/everything-you-need-to-know-about-aws-cedar-policy-language" href="https://www.permit.io/blog/everything-you-need-to-know-about-aws-cedar-policy-language"><u>a new open-source policy-as-code language</u></a> developed by AWS to streamline IAM management and access control. It introduces a structured and scalable approach to managing permissions, making it a game-changer for application-level permissions.</p><p><strong>Advantages of using Cedar:</strong></p><ul><li><div><p>Policy-as-Code: Same as OPA, Cedar uses a policy language to define policies, allowing policies to be treated as code with benefits such as versioning, auditing, and transparent review processes.</p></div></li><li><div><p>Readability: Cedar is designed to be highly readable, making it easier for both technical and non-technical team members to understand and work with the language. </p></div></li><li><div><p>Structured and Safety-Oriented: Cedar follows a structured approach, emphasizing safety by default. It prioritizes correctness and security, providing assurances through verification-guided development.</p></div></li><li><div><p>Application-Level Authorization: Cedar is specifically tailored for application-level authorization. It is well-suited for managing and enforcing permissions within applications, ensuring that access control requirements are effectively met at the application level.</p></div></li><li><div><p>Fine-Grained Permissions: Cedar supports Role-Based Access Control (RBAC), Attribute-Based Access Control (ABAC), and Relationship-Based Access Control (ReBAC) as well, enabling granular permissions management. Here are some useful examples:<br><br><a title="https://www.permit.io/blog/cedar-rbac" href="https://www.permit.io/blog/cedar-rbac"><u>Role-Based Access Control (RBAC) with Cedar</u></a></p></div></li></ul><p><strong>Disadvantages of using Cedar:</strong></p><ul><li><div><p>Limited Tooling and Ecosystem: Compared to other policy languages, Cedar currently has a smaller ecosystem of tools and modules available. It may have fewer built-in tools for specific tasks, which might require additional effort or custom implementations when working with certain functionalities.</p></div></li><li><div><p>Less Established Community: As a relatively new policy language, Cedar has<a title="http://cedar-policy.slack.com/" href="http://cedar-policy.slack.com/"><u> a small, (yet blooming!) community</u></a> compared to other more established alternatives. This could result in fewer available resources, documentation, and community-driven support when encountering challenges or seeking assistance with Cedar-related projects.</p></div></li></ul><p>An in-depth comparison between OPA and Cedar is available <a title="https://www.permit.io/blog/opa-vs-cedar" href="https://www.permit.io/blog/opa-vs-cedar"><u>here</u></a>. </p><p></p><h3>Zanzibar-based</h3><p>Unlike the previous two, Google Zanzibar is a graph-based authorization model. <a title="https://www.permit.io/blog/zanzibar-vs-opa#graph-based-authorization-systems" href="https://www.permit.io/blog/zanzibar-vs-opa#graph-based-authorization-systems"><u>Graph-based authorization systems</u></a> utilize a graph to represent relationships (such as ownership) between users and resources. </p><p><strong>Advantages of Google Zanzibar:</strong></p><p>Relationship-based Access Control (ReBAC) focused: Graph-based systems excel at managing hierarchies and nested relationships, making them a natural fit for scenarios requiring ReBAC. Google Zanzibar provides a robust foundation for modeling complex access control relationships effectively.</p><p>Data Consistency and Scale: Graph-based systems handle high volumes of data while maintaining consistency. This makes them well-suited for large-scale environments where data integrity and scalability are crucial.</p><p><strong>Disadvantages of Google Zanzibar:</strong></p><p>System Complexity and Dependencies: Implementing a Zanzibar-based graph introduces a complex system into the cloud environment. It often relies on hosted services, potentially leading to latency concerns and scalability challenges. Dependencies on external services can impact system performance and introduce additional points of failure.</p><p>Limited Applicability at the Edge: Graph-based systems like Zanzibar are typically challenging to deploy at the edge due to their size and non-local nature. This limitation may hinder their practicality in edge computing scenarios, where low latency and efficient access control are essential.<br><br>Further reading on <a title="https://www.permit.io/blog/zanzibar-vs-opa" href="https://www.permit.io/blog/zanzibar-vs-opa"><u>Zanzibar and comparing it to OPA is available here.</u></a></p><h2>Summary:</h2><p>We learned about three prominent policy-based authorization systems: Open Policy Agent (OPA), AWS Cedar, and Google Zanzibar. </p><p><strong>OPA </strong>stands out as an open-source policy engine, leveraging the Rego language for defining policies and granting fine-grained permissions. It offers Policy-as-Code, high performance, and industry adoption, but may require a significant learning curve.</p><p><strong>AWS Cedar</strong>, another policy-as-code language developed by AWS, emphasizes readability, structured design, and application-level authorization focus. While Cedar&#39;s safety-oriented approach and fine-grained permissions are commendable, it faces challenges related to its limited tooling and smaller community support.</p><p><strong>Google Zanzibar</strong>, on the other hand, offers a graph-based authorization model, excelling in managing access control via relationships. However, it introduces system complexity and dependencies, making it less suitable for edge or high performance computing scenarios.</p><p>With a comprehensive understanding of the strengths and weaknesses of these three systems, organizations can make informed decisions while building robust and efficient authorization services for their applications.</p><p>Want to learn more about authorization? Join our <a title="https://io.permit.io/permitslack" href="https://io.permit.io/permitslack"><u>Slack community</u></a>, where there are hundreds of devs building and discussing authorization models and implementations. </p>]]></content>
        <author>
            <name>Daniel Bass</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[What is Authorization as a Service]]></title>
        <id>authorization-as-a-service</id>
        <link href="https://www.permit.io/blog/authorization-as-a-service"/>
        <updated>2023-07-27T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[What is authorization as a service? Why would you need it? Can you build authorization yourself? What options are there? Learn more here. ]]></summary>
        <content type="html"><![CDATA[<h2>What is authorization? </h2><p>Authorization is the process of granting or denying access to specific resources based on a user&#39;s verified identity. (Not to be <a title="https://www.permit.io/blog/authn-vs-authz" href="https://www.permit.io/blog/authn-vs-authz"><u>confused with Authentication</u></a>, which is about verifying a user&#39;s identity). In simpler terms, it’s about <strong>who </strong>can do <strong>what </strong>in your application once they have logged in, and under what conditions. </p><p>Application-level Authorization can be managed through different <strong>authorization models</strong>. These authorization models determine the level of access or permissions granted to users based on factors such as user roles, attributes, contextual information, or a combination of these factors. </p><p>These decisions are made and enforced by rules, which are called <strong>policies</strong>. </p><p>There are several models in which these policies can be structured. The most common are <a title="https://www.permit.io/blog/rbac-with-permit" href="https://www.permit.io/blog/rbac-with-permit">Role-based access control (RBAC)</a>, <a title="https://www.permit.io/blog/what-is-abac" href="https://www.permit.io/blog/what-is-abac">Attribute-based access control (ABAC)</a>, and <a title="https://www.permit.io/blog/what-is-rebac" href="https://www.permit.io/blog/what-is-rebac">Relationship-based access control (ReBAC)</a>. </p><h2>What is authorization as a service? </h2><p>Authorization as a service means outsourcing the management of permissions and access control in your application to a third-party service. In the past few years, new authorization providers have emerged, providing a varying set of services and approaches to solving your authorization challenges. </p><p>In short, the main benefits of adopting an authorization service are both streamlining the development process and ensuring that your application is more resilient and easily deployable. By leveraging an authorization service, developers can concentrate on building the core features of their application, freeing up valuable time and resources that would otherwise be spent on creating and maintaining their own authorization and permission management systems. <br><br>Proper implementation of authorization systems (Or the lack of it) is considered by many the biggest concern in application security, with the latest OWASP &quot;Top 10 API Security Risks&quot; report <a title="https://www.permit.io/blog/owasp-2023" href="https://www.permit.io/blog/owasp-2023"><u>once again listing &quot;Broken Object Level Authorization&quot; as its top 1 vulnerability</u></a>. </p><p>That being said, let’s dive into each of these points and discuss it in more detail:</p><h2>Why Would You Need An Authorization Service?</h2><p>Building a secure application is a top priority for any developer, and managing permissions or authorization is a key component in achieving that. The question of how to manage the authorization layer in your application is relevant to almost any application out there with a varying degree of complexity. </p><p>A lot of ink has been spilled over the debate of build vs. buy when it comes to security features. In some areas, such as authentication, a solid consensus has been reached in the last few years that developers should not roll their own authentication. his type of shift isn’t limited to the security space - building your own payment infrastructure instead of using solutions like Stripe has been <a title="https://stackoverflow.com/questions/26944229/is-it-possible-to-develop-a-payment-gateway" href="https://stackoverflow.com/questions/26944229/is-it-possible-to-develop-a-payment-gateway"><u>considered absurd</u></a> for a while now. </p><p>With Authorization, the question of build vs. buy has not been debated as much, as full-stack Authz solutions are only now beginning to emerge. You can read a more detailed discussion of this subject <a title="https://www.permit.io/blog/roll-your-own-rbac" href="https://www.permit.io/blog/roll-your-own-rbac"><u>in this blog</u></a>. </p><p>That being said, let’s go over the main benefits of adopting an existing authorization solution: </p><ul><li><div><p><strong>Enhanced Security Expertise:</strong> Authorization is a complex problem that requires in-depth knowledge to solve properly. Third-party authorization services are developed and maintained by security experts, solely focused on making sure the solution they provide is up to the latest industry standards. This reduces the risk of security vulnerabilities and data breaches.</p></div></li></ul><ul><li><div><p><strong>Saves You From Reinventing the Wheel</strong>: While a complex problem, authorization is a common problem constantly encountered by dozens of developers. Utilizing a ready-made service instead of building one from scratch saves development time, allowing developers to focus on core functionalities and improving time-to-market. Authorization is more than just the enforcement infrastructure - It is also a long set of interfaces (both UI and API) that most applications end up needing sooner or later.</p></div></li></ul><ul><li><div><p><strong>Compliance and Regulations:</strong> Established authorization services come with <a title="https://www.permit.io/blog/building-app-authorization-the-5-keys-for-scalability-and-compliance" href="https://www.permit.io/blog/building-app-authorization-the-5-keys-for-scalability-and-compliance"><u>built-in compliance features</u></a> which allow you to implement the security and granularity levels required to adhere to industry-specific regulations and standards such as HIPPA, SOC2, and ISO 27001. </p></div></li></ul><ul><li><div><p><strong>User Experience:</strong> Some authorization as a service solutions provide easily manageable user interfaces to manage your authorization layer, or even generate policy as code. This prevents a situation where developers become bottlenecks in creating and managing policies - including all stakeholders in the conversation. </p></div></li></ul><h2>Can You Build an Authorization Service Yourself?</h2><p>While it is possible to build an authorization service yourself, it comes with significant challenges. A homebrew solution would have to meet at least these basic requirements: </p><ul><li><div><p>The service must match the availability of your existing stack, ensuring it can handle the constant requests from other services. </p></div></li><li><div><p>It must process requests with low latency, typically aiming for query response times below 50ms. If each takes more than 50-100ms, the performance of your application is basically ruined before it even starts to handle its own core logic.</p></div></li><li><div><p>You&#39;ll need to create a storage system for your authorization data model, including roles, relationships, and policies, with the ability for administrators to modify them. </p></div></li><li><div><p>Not all authorization-related data is available or relevant for every authorization check request. Some data, such as user attributes, object metadata, and entitlements, may need to be fetched from external sources such as IAM providers, application databases, external services, etc. This data needs to be propagated into the authorization layer when required and managed in a real-time fashion. </p></div></li><li><div><p>Supporting various authorization models (Such as RBAC, ABAC, ReBAC, or any model relevant to your application) while maintaining fast and reliable query responses is essential.</p></div></li><li><div><p>Authorization systems require ongoing critical maintenance and development as new requirements continue to funnel in from customers, security &amp; compliance, and the expansion of the application itself.</p></div></li></ul><p>If you prefer to avoid the engineering effort, using an authorization service allows developers to focus on building their core application functionality rather than spending time and resources building and maintaining infrastructure, APIs, and human interfaces that aren’t unique to any application. </p><p>You can leverage existing open-source solutions or opt for a ready-made out-of-the-box solution. You can read a more detailed discussion on the decision of building vs buying when it comes to authorization <a title="https://www.permit.io/blog/roll-your-own-rbac" href="https://www.permit.io/blog/roll-your-own-rbac"><u>here</u></a>. </p><h2>What should an authorization as a service solution provide?</h2><p>If you decide to go with an authorization-as-a -service provider, here&#39;s a quick list of considerations you should take into account when deciding which solution to pick: </p><ul><li><div><p><strong>Compatibility:</strong> Ensure compatibility with existing systems and infrastructure (Like your cloud environment, programming language, data sources, etc.). Make sure that the transition to the new solution can be fast, yet gradual.</p></div></li><li><div><p><strong>Best Practices:</strong> Look for a solution that <a title="https://www.permit.io/blog/5-best-practices-for-building-cloud-native-permissions" href="https://www.permit.io/blog/5-best-practices-for-building-cloud-native-permissions"><u>utilizes authorization best practices</u></a>: <a title="https://www.permit.io/blog/what-is-policy-as-code" href="https://www.permit.io/blog/what-is-policy-as-code"><u>policy-as-code</u></a>, <a title="https://www.permit.io/blog/introduction-to-opal" href="https://www.permit.io/blog/introduction-to-opal"><u>event-driven updates</u></a>, <a title="https://www.permit.io/blog/gitops-today-why-and-how" href="https://www.permit.io/blog/gitops-today-why-and-how"><u>GitOps</u></a>, back-office control, and customer-facing experiences.</p></div></li><li><div><p><strong>Latency and Locality:</strong> Choose a solution considering response times and avoid relying solely on remote querying.</p></div></li></ul><ul><li><div><p><strong>Policy Model Support:</strong> Choose a solution that supports the policy model relevant to you -  <a title="https://www.permit.io/blog/rbac-with-permit" href="https://www.permit.io/blog/rbac-with-permit">RBAC</a>, <a title="https://www.permit.io/blog/what-is-abac" href="https://www.permit.io/blog/what-is-abac">ABAC</a>, or <a title="https://www.permit.io/blog/what-is-rebac" href="https://www.permit.io/blog/what-is-rebac">ReBAC</a>, and allows you to flexibility transition between them. Remember that application requirements tend to change, necessitating the transition to a different policy model. </p></div></li></ul><ul><li><div><p><strong>Scalability:</strong> Evaluate a solution&#39;s ability to handle growth and complex policies or structures.</p></div></li><li><div><p><strong>Security and Compliance:</strong> Prioritize cybersecurity, data protection, and avoiding increased attack surface. Ask your provider how they intend to work with your sensitive data for authorization.</p></div></li><li><div><p><strong>Ease of Use:</strong> Choose a user-friendly solution that provides interfaces for creating and managing authorization policies.</p></div></li></ul><ul><li><div><p><strong>Support:</strong> Ensure reliable customer support and quick response times to address any questions or issues.</p></div></li></ul><p>A more detailed explanation of all the factors to consider when choosing an authorization service can be found <a title="https://www.permit.io/blog/choose-an-authz-service" href="https://www.permit.io/blog/choose-an-authz-service"><u>here</u></a>. </p><h2>What authorization-as-a-service options are out there?</h2><p>There is no one-size-fits-all approach to authorization. Each application has its unique requirements, and it’s important to get accustomed to the different solution approaches out there before making a decision. In general, authorization services can be divided into two main categories: Policy As Code solutions, and graph-based solutions.</p><h3>Graph vs. Code-Based Authorization in a Nutshell: </h3><p><a title="https://www.permit.io/blog/what-is-policy-as-code" href="https://www.permit.io/blog/what-is-policy-as-code"><u>Policy-as-code</u></a> authorization utilizes code to define authorization policies, facilitating their modification and offering a higher degree of flexibility, effectively handling complex rules and relationships. Graph-based authorization systems employ a graphical representation to illustrate relationships between users and resources and excel at mapping hierarchies and nested relationships. To learn more about the choice between Graph-Based Authorization and Code Based Authorization <a title="https://www.permit.io/blog/zanzibar-vs-opa" href="https://www.permit.io/blog/zanzibar-vs-opa"><u>check out this article</u></a>. </p><p>Here is a quick list of authorization-as-a-service options: </p><h2>Policy-as-code solutions: </h2><h3>Open Policy Agent (OPA)</h3><p><a title="https://github.com/open-policy-agent/opa" href="https://github.com/open-policy-agent/opa"><u>OPA</u></a> is an open-source policy engine for controlling access to systems and resources. </p><p>It uses a high-level declarative language called <strong>Rego </strong>to define policies and evaluate complex authorization rules. You can read a <a title="https://www.permit.io/blog/introduction-to-opa" href="https://www.permit.io/blog/introduction-to-opa"><u>detailed introduction to OPA here</u></a>. </p><p>OPA has gained significant industry adoption and is backed by a thriving community, making it a reliable choice for building robust and fine-grained authorization services.</p><h3>AWS’ Cedar</h3><p><a title="https://aws.amazon.com/about-aws/whats-new/2023/05/cedar-open-source-language-access-control/" href="https://aws.amazon.com/about-aws/whats-new/2023/05/cedar-open-source-language-access-control/"><u>AWS Cedar</u></a> is a new open-source policy-as-code language developed by AWS to streamline IAM management and access control. It introduces a structured and scalable approach to managing permissions, making it a game-changer for application-level permissions. A detailed guide to building RBAC with Cedar is available <a title="https://www.permit.io/blog/cedar-rbac" href="https://www.permit.io/blog/cedar-rbac"><u>here</u></a>. <br><br>Permit.io provides <a title="https://www.permit.io/blog/cedar-qna" href="https://www.permit.io/blog/cedar-qna"><u>an integration with the Cedar</u></a> policy language, allowing users to generate Cedar code through their UI. </p><p>You can read an in-depth comparison between OPA and Cedar <a title="https://www.permit.io/blog/opa-vs-cedar" href="https://www.permit.io/blog/opa-vs-cedar"><u>here</u></a>. </p><h2>Graph-Based Solutions: </h2><h3>Google Zanzibar</h3><p>Zanzibar serves as Google&#39;s gatekeeper for access control and is renowned for its distributed, scalable, and consistent architecture. Underpinning Zanzibar is a graph data model and a distributed consensus algorithm ensuring consistent authorization decisions across the board.</p><h3>SpiceDB</h3><p>AuthZ’s <a title="https://github.com/authzed/spicedb" href="https://github.com/authzed/spicedb"><u>SpiceDB</u></a> is a mature open-source graph-based authorization system. Extending beyond the original specifications of Zanzibar, SpiceDB introduces features such as Caveats and adopts the role of a permissions database, emphasizing its centrality in the authorization domain.</p><h2>Scalable Implementation</h2><p>Scaling the deployment of your policy engine of choice for policy evaluation in production can be challenging. </p><p>While policy engines provide the necessary building blocks for defining policies and evaluating decisions, deploying them with your application at scale requires a solution. This is where <a title="https://github.com/permitio/opal" href="https://github.com/permitio/opal"><u>OPAL </u></a>comes in. Supporting both <a title="https://www.permit.io/blog/scaling-authorization-with-cedar-and-opal" href="https://www.permit.io/blog/scaling-authorization-with-cedar-and-opal"><u>Cedar</u></a> and <a title="https://www.permit.io/blog/introduction-to-opal" href="https://www.permit.io/blog/introduction-to-opal"><u>OPA</u></a>, OPAL serves as an administration layer that simplifies the deployment of your policy engine of choice and ensures seamless scalability. </p><p>With OPAL, you can effortlessly keep your policy configuration up to date across all deployed policy engines, ensuring consistency and accuracy. It also guarantees that the data used for evaluation remains current, facilitating precise policy enforcement. OPAL&#39;s configuration-as-code approach simplifies the deployment process by providing a centralized and easily manageable configuration. </p><h2>Policy Authoring</h2><p>While OPA, Cedar, and Google Zanzibar provide us with the ability to unify all policies in a single service, take on the role of policy decision-making and enforcement from the app’s services, and manage policy as code/graph, they lack one key functionality:</p><p><strong>The ability to create, manage and enforce policies in a way anyone in your organization can use.</strong></p><p>Normally, creating and managing your application’s authorization policies could only be done through complex R&amp;D work and steep learning curves (e.g. writing Rego or Cedar code). This creates a situation where developers become bottlenecks in your app’s permission management, other stakeholders are locked out of the conversation, and your customers are left without the flexibility they require. All of these manifest as an unending stream of feature requests.</p><p>The solution is implementing and managing your policies with a simple no-code UI which makes permission management accessible to other stakeholders. This can be achieved by using <a title="https://www.permit.io/" href="https://www.permit.io/"><u>Permit</u></a>, as it allows you to manage policy-as-code with a no-code UI or API, supporting both OPA and Cedar. Permit generates code for RBAC, ABAC, and ReBAC, which you can edit, add to, and manage via GitOps.</p><p>Want to learn more about Authorization? Join our Slack community, where there are hundreds of devs building and implementing authorization.</p>]]></content>
        <author>
            <name>Daniel Bass</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Should You Roll Your Own RBAC Authorization?]]></title>
        <id>roll-your-own-rbac</id>
        <link href="https://www.permit.io/blog/roll-your-own-rbac"/>
        <updated>2023-07-24T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Having an authorization layer is a must. But should you build one yourself?]]></summary>
        <content type="html"><![CDATA[<p>Building a secure application is a top priority for any developer, and managing permissions or authorization is a key component in achieving that. One of the most critical decisions that developers face when building an application is whether to build their own security features or buy them from a third-party provider - a question that commonly sparks some <a title="https://www.reddit.com/r/webdev/comments/vmoccf/do_you_prefer_to_build_your_own_auth_or_use_some/" href="https://www.reddit.com/r/webdev/comments/vmoccf/do_you_prefer_to_build_your_own_auth_or_use_some/"><u>lively debates</u></a>.</p><p>In the past few years, a solid consensus has been established that developers should not roll their own authentication, and numerous content pieces [<a title="https://withblue.ink/2020/04/08/stop-writing-your-own-user-authentication-code.html" href="https://withblue.ink/2020/04/08/stop-writing-your-own-user-authentication-code.html"><u>1</u></a>] [<a title="https://simplelogin.io/blog/do-not-create-own-auth-system/" href="https://simplelogin.io/blog/do-not-create-own-auth-system/"><u>2</u></a>] [<a title="https://dev.to/jordanfinners/make-one-resolution-this-year-never-write-your-own-authentication-3nc1" href="https://dev.to/jordanfinners/make-one-resolution-this-year-never-write-your-own-authentication-3nc1"><u>3</u></a>] have been created on the subject. This type of shift isn’t limited to the security space - building your own payment infrastructure instead of using solutions like Stripe has been <a title="https://stackoverflow.com/questions/26944229/is-it-possible-to-develop-a-payment-gateway" href="https://stackoverflow.com/questions/26944229/is-it-possible-to-develop-a-payment-gateway"><u>considered absurd</u></a> for a while now.</p><p>With Authorization, the question of build vs. buy has not been debated as much, as full-stack Authz solutions are only now beginning to emerge. This blog aims to point out the main challenges you will face in building your own authorization layer, to help you consider this decision.</p><h2>Build Vs. Buy in a nutshell</h2><p>The decision between building or buying a security component can be a difficult one. Building your own authorization system gives you complete control over the code, and you can customize it to meet the specific needs of your application. However, building an authorization system from scratch can be a time-consuming and resource-intensive process. <br><br>Here are some questions you should consider before deciding to roll your own authorization layer:</p><h2>Will your solution keep your data protected?</h2><p>THE number one question you should ask yourself when deciding whether to build your own authorization is: <strong>“Can I build a solution that is robust enough to keep my data secure”</strong>. While you may think that building your own authorization system gives you complete control over security, making a mistake can pose enormous potential security risks - putting your application, if not your whole organization, at risk. Building a secure authorization system requires expertise in <a title="https://www.permit.io/blog/5-best-practices-for-building-cloud-native-permissions" href="https://www.permit.io/blog/5-best-practices-for-building-cloud-native-permissions"><u>best practices</u></a>, as well as in-depth knowledge of the authorization field - which may not be readily available in-house.</p><h2>Who creates, implements, and maintains your authorization?</h2><p>Another key challenge of building your own security features is ensuring that the knowledge of how the component works<strong> is not solely dependent on one person</strong>. If only one person knows how the system works, it can become a bottleneck for the entire development team, as well as your end users. This is especially true when that person leaves the company, goes on vacation, or simply becomes unavailable for an extended period of time. </p><p>It’s also important to note that authorization doesn’t end at the point of implementation - </p><p>Depending on the expertise of a single developer (Or even a designated team of developers, if your organization has the workforce to spare) to create, implement, and maintain the authorization layer can easily result in an unending stream of feature requests you might not be able to handle.<br><br>A quick review of large-scale companies that persisted in building authorization on their own shows dedicated AuthZ dev teams growing to an average of 6 engineers (an average cost of $900,000 per year).</p><h2>Who interacts with your authorization? Who writes the code? </h2><p>One important best practice to consider when adopting an authorization solution is to manage the authorization <a title="https://www.permit.io/blog/what-is-policy-as-code" href="https://www.permit.io/blog/what-is-policy-as-code"><u>policy as code</u></a>. In short, when managed as code, policies can be managed using the same tools and processes used to manage and deploy software. This makes it easier to track changes to policies over time, roll back changes if necessary, and in general, enjoy the well-thought-through best practices of the code world (e.g., <a title="https://www.permit.io/blog/gitops-today-why-and-how" href="https://www.permit.io/blog/gitops-today-why-and-how">GitOps</a>).</p><p>The thing is, even if we have our policies managed as code, this does not give us the ability to create, manage and enforce them in a way that anyone in your organization can use. If only your developers know how to operate this system (i.e. generate new policies, or modify existing ones by writing policy code), they become bottlenecks in your app’s permission management, leaving other stakeholders locked out of the conversation. Every time a non-technical user, be it from your own organization or your end user, will need to make changes to the policy, they will be fully dependent on your developer team to do so. </p><p>The solution is creating or adopting a solution that provides no-code interfaces which allows creating policy as code. This UI will need to be accessible to every relevant stakeholder, allowing them to take part in the permission management process. </p><h2>Is your authorization built to scale and evolve?</h2><p>Your application and organization are (Hopefully) going to grow. This will require the application to support more users, requests, and data (Not to mention features - more on that in a sec). When building authorization, it is crucial that you plan ahead and <a title="https://www.permit.io/blog/planning-app-rbac" href="https://www.permit.io/blog/planning-app-rbac"><u><strong>structure it in a way that allows for easy modification and expansion</strong></u></a>. Note that building an authorization system that can handle scalability requires significant expertise and resources. <br><br>As your business requirements change, your security system needs to evolve with them. Building your own authorization system requires constant maintenance and updates to keep up with changing business requirements. This can be a drain on development resources and may result in delays in delivering new features or fixing bugs.</p><p>Netflix is a good example of this, and there’s a lot to learn from <a title="https://www.permit.io/blog/netflix-authz" href="https://www.permit.io/blog/netflix-authz"><u>how they approached building their authorization layer</u></a>, and <a title="https://www.infoq.com/presentations/netflix-architecture-new-experiences/" href="https://www.infoq.com/presentations/netflix-architecture-new-experiences/"><u>the challenges they faced</u></a> when moving from RBAC to ABAC. <br><br>If you don’t plan for it accordingly, something as simple as adding attributes to an existing RBAC layer (If, say, you now need to monitor access to certain resources based on Time, Geo-Location, or any other type of ABAC rule) could mean completely refactoring your entire authorization system.  </p><h2>Pros of Building Your Own Security Components</h2><p>Building your own authorization system gives you complete control over the code and allows you to tailor it perfectly to meet your application’s needs. This can be especially important if your application has unique business requirements or need to integrate with legacy systems that may not be supported by third-party solutions. Additionally, building your own authorization system can be a valuable learning experience, giving you a deeper understanding of security principles and best practices. That being said - it&#39;s all a question of what your organization can actually afford in terms of time and workforce allocation.</p><h2>Conclusion</h2><p>Building your own security features, specifically authorization, can be a challenging and time-consuming process that most organizations, especially small ones, cannot afford. While there are some benefits to building your own solution, including customization and learning opportunities, the risks and challenges outweigh the benefits for most organizations. Good third-party authorization services can offer a secure solution that can scale, evolve, and, most importantly, save you the time and effort of building, implementing, and maintaining your own authorization layer. Ultimately, the decision between build-or-buy depends on your specific needs and resources, but it&#39;s important to carefully consider the trade.</p><p>Want to learn more about implementing Authorization? Join our <a title="https://io.permit.io/permitslack" href="https://io.permit.io/permitslack"><u>Slack community</u></a>, where hundreds of devs, including top authorization professionals, are building and implementing authorization.</p>]]></content>
        <author>
            <name>Daniel Bass</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Best Practices for Authorization Audit Logs]]></title>
        <id>audit-logs</id>
        <link href="https://www.permit.io/blog/audit-logs"/>
        <updated>2023-07-20T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Why and how you should enhance your application's security and compliance with authorization audit logs. ]]></summary>
        <content type="html"><![CDATA[<p>In the ever-evolving landscape of application security, the ability to track <strong>who did what within your application</strong> and <strong>why they were allowed</strong> (Or forbidden) to do so is essential. This goal can be achieved by the use of audit logs. These records play a vital role in capturing and documenting a system&#39;s activities over time - which is especially crucial when dealing with application-level authorization.</p><p>This article will discuss the importance of audit logs, specifically their role in tracking authorization-related events, the value of having “Meta” audit logs for authorization, implementation methods, audit log generation best practices, and the importance of having comprehensible audit logs to adhere to compliance standards. </p><h2>What Are Audit Logs? </h2><p>An audit log is a central record of events impacting a system&#39;s state or behavior. Each log entry acts as a footprint, detailing a specific change in the system. It is usually accompanied by contextual information about its initiation and, where applicable, the reasons behind it.</p><p>In the context of application-level authorization, an audit log will usually include information such as:</p><ul><li><div><p>A <strong>timestamp</strong> of the attempted action</p></div></li><li><div><p>The <strong>user/machine</strong> who attempted the action</p></div></li><li><div><p>A <strong>description</strong> of the attempted action</p></div></li><li><div><p>The <strong>resource</strong> which was the target of the attempted action</p></div></li><li><div><p>The <strong>authorization decision</strong> - Permitted or Denied, <br>or the <strong>status of the operation</strong> - Success or Failure. </p></div></li><li><div><p>And, in some cases - <br>The <strong>reasoning</strong> behind the authorization decision</p></div></li></ul><img src="https://media.graphassets.com/cne9O3RGSiq4uB7j9ZtQ" alt="Group 67738.png" title="Group 67738.png" width="846" height="589" /><p><em>Authorization Audit-Logs in the Permit.io dashboard</em></p><p></p><pre><code>{
      &quot;Allow&quot;: true,
      &quot;debug&quot;: {
         &quot;rbac&quot;: {
           &quot;code&quot;:
           &quot;allow&quot;: true,
           
      &quot;reason&quot;:&quot;user &#39;user_1&#39; has the role &#39;admin&#39; in tenant,
               &#39;sample_tenant&#39;, role &#39;admin&#39; has the &#39;create&#39; permission 
               on resources of type &#39;document&#39;&quot;
           
           &quot;allowing_roles&quot;: [
             &quot;admin&quot;
           ]
      }, 
      &quot;request&quot;: {
         &quot;user&quot;: {
             &quot;key&quot;: &quot;user_1&quot;,
             &quot;email&quot;: null,
             &quot;synced&quot;: true,
             &quot;last_name&quot;: null,
             &quot;attributes&quot;: {
               &quot;age&quot;: 50,
               &quot;key&quot;: &quot;user_1&quot;,
               &quot;email&quot;: &quot;sampleemail@org.com&quot;,
               &quot;roles&quot;: [ 
                 &quot;admin&quot;
               ],             
               &quot;tenants&quot;: [
                 &quot;sample_tenant&quot;
               ],             
               &quot;fav_color&quot;: &quot;red&quot;
             },
             &quot;first_name&quot;: null
           },
           &quot;action&quot;: &quot;create&quot;,
           &quot;tenant&quot;: &quot;sample_tenant&quot;,
           &quot;resource&quot;: {
             &quot;type&quot;: &quot;document&quot;,           
             &quot;attributes&quot;: {
               &quot;type&quot;: &quot;document&quot;
             }
           }
         }
       },
       
      &quot;allowing_sources&quot;: [
         &quot;rbac&quot;
      ],
      &quot;debugger_activated&quot;: true,
      &quot;__data_use_debugger&quot;: true,
      &quot;__input_use_debugger&quot;: null   
   }</code></pre><p><em>An example of a Permit.io-generated authorization audit log for an RBAC policy</em></p><p>This information will allow an administrator to easily<strong> understand and investigate</strong> the reasoning behind authorization decisions made within their system. Having detailed audit logs is a crucial function, especially when investigating unauthorized access. Without them, there would be no way to trace the origin and reasoning behind problematic actions that occurred in our application. </p><p>Audit logs are our best way of debugging the authorization system itself, debugging behaviors in the access-controlled application, understanding the cascading results of authentication mechanisms, and, of course, investigating security/compliance incidents. <br><br>Taking it one step further - it is extremely important to have access not only to audit logs of actions made in the application itself, but also to changes made within the application’s access control layer. Let’s dive a little deeper into that. </p><h2>Why Do You Need “Meta” Audit Logs?</h2><p>While having a detailed log of all the authorization events happening in your application is crucial, it’s not enough. Understanding the changes made to your application’s authorization layer is another important step toward a fully transparent view of your application’s access control. </p><p>This extra level of auditing (Which we refer to here as “Meta” audit logs) tackles one of the most complex issues in the world of access control - <strong>Authorization-for-Authorization</strong>. It provides insights into the granting, changing, and revoking of permissions within the application&#39;s authorization system. By capturing these events, organizations gain visibility into the evolution of permission assignments, ensuring transparency and accountability. “Meta” audit logs enable administrators to monitor and review changes to permissions, identify potential misconfigurations or unauthorized access, and strengthen their overall security posture.</p><p></p><img src="https://media.graphassets.com/3cBTQwmOSj2rxbuW2BJJ" alt="unnamed.png" title="unnamed.png" width="816" height="114" /><p><em>An example of “Meta” Audit Logs generated via the Permit.io UI</em></p><h2>How to Properly Implement Audit Logs for Authorization?</h2><p>To effectively implement audit logs in your application, it is crucial to record each significant event that occurs. At its core, an audit log is a repository, either a file, database table, or persistent storage, where a new record is added for every event. When generating an audit event, capture relevant system information and label it with the corresponding event type.</p><p>Setting up a dedicated log viewer offers convenient access to your records. There are several options available for indexing and consuming audit events - as you probably won’t want to do it manually: </p><ul><li><div><p>Streaming audit logs to stdout: Log aggregation tools, such as <a title="https://www.elastic.co/" href="https://www.elastic.co/"><u>Elastic</u></a>, can collect logs directly from your application&#39;s standard output stream, particularly when you use formats like JSON with a consistent structure.</p></div></li><li><div><p>Viewing logs: Tools like Datadog provide comprehensive features for aggregating, browsing, and searching log data. Once you have ingested the audit logs from your system, these applications allow you to query events based on properties such as type and timespan.</p></div></li><li><div><p>Collecting logs with Logstash: As part of the Elastic suite, <a title="https://www.elastic.co/logstash" href="https://www.elastic.co/logstash"><u>Logstash</u></a> serves as a versatile data collector capable of reading logs from various sources. It can retrieve logs from local files, events in a database, and requests sent to an HTTP webhook or websocket. Once the data is ingested, it is forwarded to your preferred log aggregator.</p></div></li><li><div><p>Using an authorization solution that provides built-in audit log aggregation (such as Permit.io) in addition to log streaming.</p></div></li><li><div><p>No matter which implementation method you choose, <strong>make sure it is reliable:</strong></p></div></li></ul><p>Your chosen processing pipeline must be capable of handling audit logs reliably. Although occasional drops in error logs might be acceptable, a failed audit log write could have serious consequences for future compliance investigations. </p><h2>Generating Audit Logs: Best Practices</h2><p>Having understood the different approaches to implementing an audit solution, let’s zoom in on the generation of the audit logs themselves. The best practices for how audit logs should be generated can be as important as their implementation, if not more so. <br><br>As we generate audit logs for multiple users, tenants, and applications, we have compiled a list of best practices for making your logs more helpful and coherent:</p><ul><li><div><p><strong>Automatic Generation:</strong><br>Generate audit logs from access checks automatically, and avoid having to report each audit log individually. This will grant your audit logs full coverage, preventing any potential gaps. If discovered post-incident, these gaps might be too late to fill. </p></div></li><li><div><p><strong>Asynchronous Audit Logging:<br></strong>Audit but logs can be very noisy and uneasy to investigate. It is recommended to use dedicated functions that record each action asynchronously, without adding latency to each route. This approach helps ensure a smooth and efficient investigation process.</p></div></li><li><div><p><strong>Generate Audit Logs Implicitly:</strong><br>It is recommended to Prefer solutions that generate audit logs implicitly, without the need for explicit logging code in your application. This allows for better consistency, more comprehensive coverage, reduced code complexity, and better log standardization. </p></div></li></ul><ul><li><div><strong>Include decision logs:</strong><br>Prefer audit logs that include decisions logs (Logs that refer to the state of the decision engine and the specific logic that led to an authorization decision). This will allow you to better replicate the flow that created the audit log when investigating or debugging.<br></div></li><li><div><strong>Prefer annotated audit logs</strong>:<br>Including annotations in audit logs provides valuable information and insights into the context of the system, the reasoning behind events, and why decisions were approved or denied. </div></li></ul><p>Abiding by these practices can help enable efficient investigation and debugging processes, provide valuable insights into the context and reasoning behind authorization events, and facilitate adherence to compliance standards. <br><br>Let’s dig a little deeper into the compliance aspect - </p><h2>How to Use Audit Logs to Adhere to Compliance Standards?</h2><p>Having accessible audit logs for your application’s authorization layer is a must for maintaining compliance standards within an organization. </p><p>Compliance standards, such as HIPPA, SOC2, and ISO 27001 require organizations to implement robust access controls and auditing mechanisms. Authorization layer audit logs are instrumental in ensuring that only authorized personnel access customer data by providing visibility into user access activities and detecting any deviations from the defined access controls. By maintaining comprehensive audit logs, organizations can demonstrate their adherence to HIPPA, SOC2, and ISO 27001, enhance data protection measures, and instill confidence in their clients and stakeholders regarding the security and privacy of sensitive information.</p><h2>Audit Logs for Different Policy Models, Engines, and Languages</h2><p>Authorization is never as simple as “One solution fits all” - it&#39;s essential to explore audit logs in the context of different policy engines and access control models.</p><p><strong>Audit Logs for RBAC (Role-Based Access Control):</strong></p><p><strong></strong><a title="https://www.permit.io/blog/rbac-with-permit" href="https://www.permit.io/blog/rbac-with-permit"><u>⁠Role-Based Access Control (RBAC)</u></a> is a widely adopted model that assigns permissions based on predefined roles. Having audit logs specifically tailored for RBAC enables organizations to effectively monitor and trace access control decisions. These logs capture information about user activity based on their assigned roles and provide insight into who accessed what and when.</p><p><strong>Audit Logs for ABAC (Attribute-Based Access Control):</strong></p><p><strong></strong><a title="https://www.permit.io/blog/what-is-abac" href="https://www.permit.io/blog/what-is-abac"><u>Attribute-Based Access Control (ABAC)</u></a> is a flexible access control model that grants permissions based on attributes associated with users, resources, and environmental conditions. In an ABAC environment, audit logs provide granular details about attribute evaluations, policy decisions, and access requests. By capturing the attributes considered during authorization decisions, ABAC audit logs facilitate comprehensive auditing and analysis. </p><p><strong>Audit Logs for ReBAC (Relationship-Based Access Control):</strong></p><p><a title="https://www.permit.io/blog/what-is-rebac" href="https://www.permit.io/blog/what-is-rebac">⁠Relationship-Based Access Control (ReBAC)</a> extends the traditional RBAC model by considering relationships between users, resources, and contexts when making access control decisions. Audit logs tailored for ReBAC capture crucial information about these relationships, allowing developers to understand the complex relationships influencing authorization outcomes.</p><p>Audit logs play an increasingly important role in different policy engines and languages:</p><p><strong>Audit Logs for Open Policy Agent (OPA):</strong></p><p><a title="https://www.permit.io/blog/introduction-to-opa" href="https://www.permit.io/blog/introduction-to-opa"><u>Open Policy Agent (OPA)</u></a> is a popular policy engine used for fine-grained authorization. OPA provides a flexible and extensible framework for expressing and enforcing access control policies in the Rego policy language. Audit logs specific to OPA capture decision evaluations, policy matches, and enforcement actions. These logs enable developers to monitor and review policy decisions made by OPA, helping to ensure compliance and identify policy gaps or misconfigurations.</p><p><strong>Audit Logs for AWS Cedar:</strong></p><p><a title="https://www.permit.io/blog/cedar-rbac" href="https://www.permit.io/blog/cedar-rbac"><u>AWS’ Cedar</u></a> is a new policy engine and language that enables developers to define and enforce complex authorization policies. Cedar-specific audit logs track policy evaluations allowing developers to gain insights into the enforcement of intricate authorization policies, detect anomalies, and verify compliance with desired access control outcomes.</p><p></p><h2>Ready-to-Use Audit Logs:</h2><p>To effectively leverage audit logs for application-level authorization, Permit.io offers automatically generated audit logs out of the box for both your authorization layer (Supporting RBAC, ABAC, and ReBAC policy models, and both the OPA and Cedar engines), as well as your authorization layer management. While Permit’s UI provides a dedicated page for viewing your audit logs, you can also find them directly in your deployed PDP microservice. As they are written to its stdout/stderr, you can stream them directly into your logging platform.</p><p>Permit’s audit log interface also allows you to filter them based on various aspects, such as users, dates, decisions, and more.</p><img src="https://media.graphassets.com/t6eIoj33SJSLxoTLkU0U" alt="pasted image 0.png" title="pasted image 0.png" width="906" height="1026" /><p><br><em>An example of Permit’s Audit log UI filtering mechanism </em></p><h2>Conclusion:</h2><p>In the realm of application security, audit logs play an integral role in application-level authorization. Capturing a comprehensive set of audit logs, including meta-audit logs that encompass permission management activities, is essential to maintaining a secure and compliant environment. With Permit.io&#39;s integrated authorization solution and its ready-to-use audit logs, you can easily streamline your security operations, improve compliance, and fortify your defenses against unauthorized access.</p><p>Want to learn more about Authorization? Join our <a title="https://io.permit.io/permitslack" href="https://io.permit.io/permitslack"><u>Slack community</u></a>, where there are hundreds of devs building and implementing authorization.</p>]]></content>
        <author>
            <name>Daniel Bass</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[6 Low-Code Tools That Will Make You a Better Frontend Developer]]></title>
        <id>frontend-low-code-tools</id>
        <link href="https://www.permit.io/blog/frontend-low-code-tools"/>
        <updated>2023-07-19T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Discover this low-code tools to enhance your frontend development skills and deliver higher-quality products and features faster.]]></summary>
        <content type="html"><![CDATA[<h2>Introduction</h2><p>How does one become a better developer? </p><p>You can say a developer is measured by their ability to deliver product features in less time while maintaining high code quality.  Striking this balance has become more achievable today, thanks to advancements in languages, platforms, CI/CD automation tools, and testing methodologies. However, integrating all these aspects can be challenging for developers and teams.</p><p>One effective way to achieve this balance is by utilizing low-code tools. These tools allow developers to quickly add functionality to applications and maintaining code quality while ensuring separation of concerns. In this article, we&#39;ll explore six low-code tools that can help you become a better frontend developer, enabling you to deliver higher-quality business value (aka product features) faster.</p><img src="https://media.graphassets.com/lTwAZF4RiuFCmq5Zwo0I" alt="Venn (1).jpg" title="Venn (1).jpg" width="834" height="893" /><h2>1. <a target='_blank' title="https://clerk.dev/" href="https://clerk.dev/"><u>Clerk.dev</u></a></h2><p>Authentication is a crucial feature for any application, verifying a user&#39;s identity to ensure they are who they claim to be. Developing authentication from scratch can be a time-consuming and complex task, involving session management, identity providers, passwords or other authentication methods, and more.</p><p>Clerk.dev is a cloud product that provides all the necessary functionality for authentication using multiple identity providers and secure methods, all in just a few lines of code. Unlike other authentication products, Clerk.dev puts the frontend developer at the center and provides an SDK and UI components that can be used with any frontend framework. By using Clerk.dev, you can quickly add advanced authentication functionality to your app and focus on creating practical value for your users.</p><img src="https://media.graphassets.com/XSI2g6ZcRU2DplnNrLw5" alt="2c9fa07f8f2c4f1fa5ba6fb5196ba45b31a694e1-2400x1260.png" title="2c9fa07f8f2c4f1fa5ba6fb5196ba45b31a694e1-2400x1260.png" width="1200" height="630" /><h2>2. <a target='_blank' title="https://supabase.com/" href="https://supabase.com/">Supabase</a> and <a target='_blank' title="https://vercel.com/resources/the-frontend-cloud-advantage" href="https://vercel.com/resources/the-frontend-cloud-advantage">Vercel</a></h2><p>While frontend development and browsers have become more powerful, certain capabilities still require backend development, causing bottlenecks for many teams. Supabase is a backend-as-a-service infrastructure that enables backend functionality without writing backend code. Vercel is a cloud platform that provides the Frontend Cloud, offering modern cloud infrastructures for frontend teams. By combining Supabase and Vercel, you can create full-stack applications without the need for backend code, allowing you to concentrate on user-oriented features. This saves valuable time for tasks like data persistence and backend functionality.</p><img src="https://media.graphassets.com/4gcsT6HjT42cmVZH1os3" alt="vercel_supabase.png" title="vercel_supabase.png" width="695" height="478" /><h2>3. <a target='_blank' title="https://cloudinary.com/documentation/frontend_sdks" href="https://cloudinary.com/documentation/frontend_sdks">Cloudinary</a></h2><p>Frontend applications heavily rely on media items such as images, videos, and gifs,  but handling them efficiently can be challenging. While displaying media items is built into every browser, implementing features like storing, serving, and managing them can be time-consuming and challenging.</p><p>Cloudinary is a cloud product that simplifies media management with just a single line of code. It offers storage, serving, and manipulation of various media items through APIs, along with UI components for frontend-based management without backend code. With Cloudinary, you can save significant time and effort on media-related features, enabling you to focus on providing practical value to users.</p><h2>4. <a target='_blank' title="https://stripe.com/payments/elements" href="https://stripe.com/payments/elements">Stripe</a></h2><p>Monetizing applications is crucial for businesses, but implementing payment systems can be complex, and implementing a payment system, managing transactions, usage, and quotes often requires dedicated teams.</p><p>Among various payment systems, Stripe is an ideal choice for frontend applications, offering easy-to-use APIs and UI components for creating a full payment system without backend code. By integrating Stripe, you can achieve monetization in your application in a fraction of the time it would take to build from scratch.</p><img src="https://media.graphassets.com/PiT8JFNTpKt0NQ17YJLu" alt="elements-social.jpg" title="elements-social.jpg" width="2048" height="1024" /><h2>5. <a target='_blank' title="https://www.algolia.com/developers/search-ui/" href="https://www.algolia.com/developers/search-ui/">Algolia</a></h2><p>Data drives our applications, regardless of the domain. Whether it&#39;s e-commerce, cybersecurity, enterprise software, or any other field, your app is filled with data, and users need an effective way to search and navigate it. However, implementing a search engine can be a daunting task for frontend teams.</p><p>This is where Algolia comes in. Algolia provides a low-code infrastructure that allows you to implement user-friendly search with ease. By plugging data from your app and configuring Algolia, you can integrate a search engine into your application&#39;s core features quickly, streamlining user interactions and saving time on complex search implementations.</p><h2>6. <a target='_blank' title="https://permit.io/foaz" href="https://permit.io/foaz">Permit.io</a></h2><p>Authorization is a critical aspect of every modern application. After users log in, it&#39;s essential to decide what they can do within the application in a secure and granular manner.</p><p>In frontend development, there are two aspects to authorization: feature flagging, which allows for features to be enabled or disabled for specific users or groups, and access control, which determines if and when a user is allowed to perform an action.</p><p>Traditionally, only feature flagging has been part of frontend work, but with the growing functionality of frontend applications, fine-grained access control has become essential. </p><p>Permit.io is a cloud product that offers a wide range of access control and authorization functionalities designed with front-end developers in mind. By using Permit.io, you can utilize <a title="https://www.permit.io/foaz" href="https://www.permit.io/foaz">Frontend Only Authorization (FoAz)</a> to access backend APIs directly with frontend credentials, all without writing backend code. This allows you to grant your users access to third-party services, your own backend APIs, or any other resource with a fine-grained permissions model using only frontend code (It also has quite a generous free tier!)</p><img src="https://media.graphassets.com/FD0YDynTSSgaGwIwydNe" alt="FoAz Proxy.png" title="FoAz Proxy.png" width="3341" height="2561" /><p>Additionally, by encouraging your backend teams to implement authorization infrastructure, you can support advanced feature flagging and access control functionalities in your frontend application. Using Permit.io will allow you to elevate your frontend application&#39;s security, ensuring users can access only the resources they are allowed to.</p><h2>Empower Your Team Today</h2><p>As frontend developers gain more power and responsibility, low-code tools become indispensable for creating better applications faster without compromising quality. Whether you&#39;re a junior or senior developer, architect, or team leader, leveraging low-code tools can enhance your team&#39;s productivity and deliver better results with less effort. Take the opportunity to empower your team with low-code tools that will make you a better frontend developer.</p><p>If you have any thoughts or comments on the article or simply want to chat with low-code makers, we invite you to <a target='_blank' title="https://io.permit.io/permitslack" href="https://io.permit.io/permitslack">join our Slack community</a>. There, you can meet other developers and makers who use low-code tools to create better applications faster.</p>]]></content>
        <author>
            <name>Gabriel L. Manor</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Best Practices for Authorization in Python]]></title>
        <id>best-practices-for-authorization-in-python</id>
        <link href="https://www.permit.io/blog/best-practices-for-authorization-in-python"/>
        <updated>2023-07-18T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Discover best practices for authorization in Python applications. Avoid anti-patterns and create better access control with RBAC and ABAC implementations.]]></summary>
        <content type="html"><![CDATA[<h2>Introduction</h2><p>Authorization plays a vital role in building secure and robust applications, ensuring that users possess the necessary permissions to access resources or perform particular actions. <br>In Python, developers often follow authorization anti-patterns that can potentially lead to security vulnerabilities, needless code complexity, and significant maintenance difficulties. This article examines various best practices to avoid these anti-patterns and provides strategies to implement more effective authorization in your Python applications.</p><h2>Understanding Authentication and Authorization</h2><p>Before we delve into the anti-patterns, it&#39;s crucial to <a title="https://www.permit.io/blog/authn-vs-authz" href="https://www.permit.io/blog/authn-vs-authz"><u>differentiate between authentication and authorization</u></a>. Authentication is the process of <strong>verifying a user&#39;s identity</strong>, while authorization <strong>assigns permissions and access rights to an authenticated user</strong>.</p><p>While authentication paves the way for authorization, they are separate processes. <strong>Authorization decisions should be independent of authentication</strong>, ensuring that access is granted or denied based on a user&#39;s permissions, after their authentication status is verified.</p><p>After understanding this crucial difference, we can now dive into the authorization anti-patterns.</p><h2>Common Authorization Anti-Patterns</h2><h3>Mixing Authorization Code with Application Logic</h3><p>One common way to code authorization in Python is to integrate statements such as <code>if is_admin:</code> into the code logic. Fortunately, this pattern isn&#39;t widespread thanks to a variety of frameworks available.</p><p>One of the main problems with this method is the difficulty it creates in understanding, debugging, and maintaining your code. It also violates the principles of single responsibility and separation of concerns.</p><h3>Embedding Roles in Application Code</h3><p>Another common method of handling authorization in Python involves using decorators that specify the roles with access to a function. This is a widespread pattern in many HTTP frameworks:</p><pre><code># Middleware
def roles_required():
    ...
            if user.role == &#39;admin&#39;:
                return func(*args, **kwargs)
            else:
                raise Exception(&#39;User is not admin&#39;)
    ...
@roles_required(&#39;admin&#39;)
def delete_user(user_id):
    user = User.get(user_id)
    user.delete()</code></pre><p>Despite being a more favorable approach than the previous one, it has its own drawbacks. For instance, every role modification necessitates code changes. As every developer knows, changing code means more bugs, a slower product lifecycle, and other issues that could break the application delivery metrics.</p><h3>Writing Multiple Authorization Functions</h3><p>Using decorator frameworks and declaring roles in the app’s code often doesn&#39;t provide the needed granularity on the resource level. This will likely result in us having to script the decision logic in another middleware:</p><pre><code># Middleware
def roles_required():
    ...
            if user.role == &#39;admin&#39;:
                return func(*args, **kwargs)
            else:
                raise Exception(&#39;User is not admin&#39;)
    ...
def permissions_required():
    ...
            if permissions == &#39;delete_user&#39;:
                return func(*args, **kwargs)
            else:
                raise Exception(&#39;User is not admin&#39;)
    ...
# Business logic
@roles_required(&#39;admin&#39;)
@permissions_required(&#39;delete_user&#39;)
def delete_user(user_id):
    ...</code></pre><p>As we can see here, the resulting code becomes increasingly complex and difficult to maintain. Whenever we need to add more logic, we&#39;ll be forced to create more middleware (or augment the existing ones), which is highly inefficient.</p><h3>Limited Function Scope</h3><p>When using middleware frameworks, we may find the function scope lacking sufficient information to make a decision. For example, our billing system may need to check if a user is a paying customer, but the function scope lacks the user&#39;s billing status:</p><pre><code>@roles_required(&#39;admin&#39;)
def enable_workflow(user_id):
    user = User.get(user_id)
    paid_tier = billing_service.get_user_tier(user_id) == &#39;paid&#39;
    if not paid_tier:
        raise Exception(&#39;User is not on the paid tier&#39;)</code></pre><p>As depicted above, we must integrate more logic into the function itself, thereby reverting to the issue of mixing code with app logic. The problem becomes even worse when we need to make a decision mid-function.</p><h3>Lack of Centralized Authorization</h3><p>Using middleware frameworks often results in authorization functions being scattered across the codebase, making the authorization logic hard to maintain and update. A critical aspect of authorization is having a centralized location where all the authorization logic is defined - ensuring easy updates and consistency across the application.</p><h3>Performance Issues</h3><p>Unlike authentication, authorization decisions occur frequently within the application. Using policy decisions embedded in the application code can lead to performance issues. Not only does this code impact performance, but it also becomes difficult to debug when numerous authorization functions are distributed throughout the code.</p><p>So how can we avoid all of these anti-patterns? Here are a few best practices we think could be useful - </p><h2>Python Authorization Best Practices</h2><h3>Use Declarative Policies Instead of Imperative Statements</h3><p>Adopt policy-as-code approaches, such as the <a title="https://www.permit.io/blog/oss-aws-cedar-is-a-gamechanger-for-iam" href="https://www.permit.io/blog/oss-aws-cedar-is-a-gamechanger-for-iam"><u>Cedar language</u></a>, to define authorization policies. A declarative approach allows you to articulate your desired permissions without muddling your code with intricate authorization logic.</p><p>The following code is an example of declaring a simple <a title="https://www.permit.io/blog/cedar-rbac" href="https://www.permit.io/blog/cedar-rbac"><u>RBAC policy in Cedar</u></a>:</p><pre><code>permit(
    principal in Role::&quot;admin&quot;,
    action in [
        Action::&quot;task:update&quot;,
        Action::&quot;task:retrieve&quot;,
        Action::&quot;task:list&quot;
    ],
    resource in ResourceType::&quot;task&quot;
);</code></pre><p>As you can easily read here, the policy permits users in the admin role to perform update, retrieve, and list actions on the task resource.</p><p>Using a declarative approach allows you to define your authorization policies in a single location, making them easier to manage and maintain.</p><h3>Keep Your Enforcement Layer Model-Agnostic</h3><p>Your enforcement layer (where you enforce policy decisions in the application) and authorization model should remain separate. The enforcement layers should be capable of handling different models, such as Role-Based Access Control (RBAC) or Attribute-Based Access Control (ABAC), without any changes to the enforcement logic.</p><p>Here&#39;s an example of how we take the same method of creating policies and create an ABAC policy in Cedar:</p><pre><code>permit (
    principal,
    action in
        [Action::&quot;UpdateList&quot;,
         Action::&quot;CreateTask&quot;,
         Action::&quot;UpdateTask&quot;,
         Action::&quot;DeleteTask&quot;],
    resource
)
when { principal in resource.editors };</code></pre><p>As you can see, the policy is very similar to the RBAC one, but it uses a different attribute to make the decision. This is the power of using declarative policy language - you can easily change the policy without changing the enforcement logic.</p><h3>Choose a Framework/Language Generic Service</h3><p>Your authorization service should be generic, and capable of adapting to various frameworks or applications. The easiest way to achieve this is by offering a read-only RPC (such as an HTTP API endpoint) endpoint in the decision point. This way, every application that wants to enforce authorization has to send the same structure of decision request to it.</p><p>With the examples we have seen above, we can see that the enforcement logic is the same for both RBAC and ABAC policies. The only difference is the policy itself. This is the power of having a generic authorization service - it can be used with any policy model.</p><p>Here&#39;s an example of enforcing the policy in Python:</p><pre><code>is_authorize(user, action, resource)</code></pre><p>This <code>is_authorize</code> function is calling the <a title="https://github.com/permitio/cedar-agent" href="https://github.com/permitio/cedar-agent"><u>Cedar-agent</u></a>, an engine that can evaluate the policy and return the decision. The function is generic and can be used with any policy model.</p><h3>Always Decouple Policy from Code</h3><p>Avoid making policy decisions directly within the application code. Instead, encapsulate the authorization logic within a separate layer or module. This will ensure that policy decisions remain independent from application logic and are easily modifiable as needed.</p><p>Using Policy as Code makes it easy to decouple authorization logic from application code. The policy is defined in a separate environment and repository, and the enforcement logic is generic and can be used with any policy model.</p><h3>Create a Unified Platform for Authorization</h3><p>Consolidate all your authorization policies into a single source of truth platform. This practice simplifies the management and maintenance of permissions and ensures consistency across your application. Even if you have multiple apps, you can deploy them with multiple decision points, but the policy is still defined in a single location.</p><h3>Make Sure Decisions Are Easy to Audit</h3><p>Maintain a <a title="https://www.permit.io/blog/audit-logs" href="https://www.permit.io/blog/audit-logs"><u>centralized audit log for all authorization decisions</u></a> within your application. A clear record of who accessed what and when assists with security analysis, compliance requirements, and detection of potential unauthorized access.</p><p>Using Policy as Code makes it easy to audit the policy as it all uses the same policy engines to evaluate the authorization decision. By modeling your decision architecture with the above practices, you can easily use any logging system to centralize all your decision logs in one place.</p><h2>Choosing an Authorization Service</h2><p>To align with these best practices, the optimal approach involves using an authorization service that centralizes configuration and deploys decentralized policy decision points to enforce the authorization logic in your applications. There are two options for setting up an authorization service:</p><h3>Using Open-Source</h3><p><a title="https://github.com/permitio/opal" href="https://github.com/permitio/opal"><u>OPAL</u></a>, an open-source tool, helps you set up a comprehensive authorization system based on the Cedar language, <a title="https://www.permit.io/blog/introduction-to-opa" href="https://www.permit.io/blog/introduction-to-opa">Open Policy Agent (OPA)</a>, and other policy engines. With OPAL, you can promptly establish an authorization service using a provided Docker file. In this article, you can find very detailed instructions for <a title="https://www.permit.io/blog/scaling-authorization-with-cedar-and-opal" href="https://www.permit.io/blog/scaling-authorization-with-cedar-and-opal"><u>creating such an open-source, fully functional system</u></a> using one Dockerfile/helm chart.</p><h3>Using a Cloud Service</h3><p>Permit.io is a cloud service offering a user-friendly policy editor and efficient permission management. It supports various permission models, including RBAC, ABAC, and ReBAC, and also provides synchronization capabilities to keep the data for policy decisions up-to-date in real time.</p><p>For Python applications, Permit.io offers a <a title="https://docs.permit.io/sdk/python/quickstart-python" href="https://docs.permit.io/sdk/python/quickstart-python">Python SDK</a> to integrate the service with your application and enforce the authorization logic. The Permit SDK simplifies your policy decisions to a single function call, like so:</p><pre><code>permit.check(&#39;user&#39;, &#39;read&#39;, &#39;resource&#39;)</code></pre><h2>Conclusion</h2><p>Building permissions and authorization can be a complex endeavor, but adhering to the best practices outlined in this article can lead to more robust and maintainable applications. It&#39;s vital to avoid the mentioned anti-patterns, adopt a declarative approach, and ensure that your authorization system is agnostic, generic, decoupled, unified, and easily auditable. By centralizing your authorization policies and leveraging open-source tools or cloud services like <a title="https://github.com/permitio/opal" href="https://github.com/permitio/opal">OPAL</a> and <a title="https://docs.permit.io" href="https://docs.permit.io">Permit.io</a>, you can streamline the implementation and management of your authorization system.</p><p>Looking for help in implementing better authorization? Have a question or comment on the article? We invite you to join our <a rel="noopener noreferrer" class="c-link c-link--focus-visible" target='_blank' title="https://io.permit.io/permitslack" href="https://io.permit.io/permitslack">authorization community in Slack</a> and create better application-level authorization together.</p>]]></content>
        <author>
            <name>Gabriel L. Manor</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[How to Add RBAC into a FastAPI Application]]></title>
        <id>implement-authorization-in-fastapi</id>
        <link href="https://www.permit.io/blog/implement-authorization-in-fastapi"/>
        <updated>2023-07-13T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Learn how to implement Authorization in FastAPI applications with Permit.io, a permission management system. Follow a step-by-step guide using RBAC and ABAC.]]></summary>
        <content type="html"><![CDATA[<h2>Introduction</h2><p>FastAPI experienced exponential growth lately among Python application developers. It is not only the fastest web framework out there, but also the clean design that allows developers to extend functionality for needs such as authentication and authorization. While authentication (verifying who the users are) is usually a simple task that can be solved with existing plugins, authorization (checking what users can do and see after login) is still a grey area for many developers.</p><p>In this article, we will go step by step in building an authorization layer into a FastAPI application. We will start with the basic principles of building it in FastAPI and continue with fully functional scalable authorization implementation. By the end of the article, you&#39;ll have the whole knowledge you need to implement authorization in your FastAPI application. Let&#39;s dive in!</p><h2>The Demo Application</h2><p>One simple way to demonstrate the various levels of authorization granularity is a simple to-do application. Let&#39;s take a look at the following code that declares a simple todo application with FastAPI.</p><pre><code>@app.get(&quot;/tasks&quot;)
async def get_tasks():
    return tasks

@app.post(&quot;/tasks&quot;, dependencies=[Depends(authenticate)])
async def create_task(task: Task):
    tasks.append(task)
    return task

@app.put(&quot;/tasks/{task_id}&quot;, dependencies=[Depends(authenticate)])
async def update_task(task_id: int, task: Task):
    tasks[task_id - 1] = task
    return task

@app.delete(&quot;/tasks/{task_id}&quot;, dependencies=[Depends(authenticate)])
async def delete_task(task_id: int):
    task = tasks[task_id - 1]
    tasks.remove(task)
    return task</code></pre><p>We also created a mock authentication function so we can make sure all the relevant endpoints are protected and only users with verified identities can access them.</p><pre><code>def authenticate(request: Request, token: str = Depends(token_auth_scheme)):
    return verifyToken(token)</code></pre><p>With this code in mind, let&#39;s continue to design the permission model in our application.</p><h2>Designing the Authorization Model(s)</h2><p>Looking at our logic, we can see that there are four endpoints that expose the following operations:</p><ul><li><div><p>Get all tasks</p></div></li><li><div><p>Create a new task</p></div></li><li><div><p>Update an existing task</p></div></li><li><div><p>Delete an existing task</p></div></li></ul><p>Thinking of the permissions required for each operation, we can produce the following table:</p><table><tbody><tr><td><p>Operation</p></td><td><p>Permission</p></td></tr><tr><td><p>Get all tasks</p></td><td><p>Allowed by everyone</p></td></tr><tr><td><p>Create a new task</p></td><td><p>Allowed only by admin</p></td></tr><tr><td><p>Update an existing task</p></td><td><p>Allowed by all authenticated users</p></td></tr><tr><td><p>Delete an existing task</p></td><td><p>Allowed only by admin if the task is marked as done</p></td></tr></tbody></table><p>If you are familiar with permission models, you can see that we need to support two types of permission models:</p><ul><li><div><p><a title="https://www.permit.io/blog/rbac-with-permit" href="https://www.permit.io/blog/rbac-with-permit"><u>RBAC - Role-Based Access Control</u></a>: To differentiate between admin and regular users.</p></div></li><li><div><p><a title="https://www.permit.io/blog/what-is-abac" href="https://www.permit.io/blog/what-is-abac"><u>ABAC - Attribute-Based Access Control</u></a>: To differentiate between done and not done tasks.</p></div></li></ul><p>As we have all the code needed to run the logic and authenticate users, let&#39;s continue with the idea of implementing those two permission models into our FastAPI application.</p><h2>The Authorization Anti-Pattern</h2><p>One approach for implementing authorization in FastAPI is mixing the policies and permissions with the application logic. For example, we can see developers that create middleware for the endpoint that checks for the relevant permissions in imperative code statements. Here&#39;s an example of such permissions check for the delete endpoint in our demo application:</p><pre><code>def allowed_to_delete_task(task_id: int, user: User):
    task = tasks[task_id - 1]
    return task.done or user.is_admin</code></pre><p>As you can see, this code is fairly simple, and successfully implements the permissions defined in the previous section. Although this code is simple, and this overall approach is common and easy to implement, it has some major drawbacks:</p><ul><li><div><p>When we need to perform changes in the model, for example, to allow users to perform operations on their own tasks, we need to change the code in the application logic.</p></div></li><li><div><p>As we create a logic that is specific to the endpoint, we need to dirt our code with multiple authorization functions.</p></div></li><li><div><p>If something is changed in the application itself, for example, the task object, we need to rethink the code and change it accordingly.</p></div></li></ul><p>Let’s examine a better way to implement authorization in FastAPI.</p><h2>The Authorization Service</h2><p>The main idea of an authorization service is to decouple the policy and permissions from the application logic. If you think of the previous anti-pattern, we can see that the code we wrote explicitly declares the policy we have for the particular operation. In the authorization service approach, we want to create a generic enforcement point in the application that outsources the policy declaration to an external service.</p><p>By using such an authorization service, we can simplify the implementation of our API authorization endpoint to the following code:</p><pre><code>def authorize(request: Request, token: str = Depends(token_auth_scheme)):
    action = request.method.lower()
    resource = request.path_params if action == &quot;get&quot; else await request.json()

    return authorize_request(token, action, resource)</code></pre><p>As you can see, the code is very generic and can be used by any application for any endpoint. Not only that, assuming that we have a clean implementation of the authorize_request function, we can seamlessly use it even inside an endpoint function. If, for example, the endpoint scope has not had enough information to authorize the request, we can call the authorize_request function everywhere else and get the authorization result. Let&#39;s continue by thinking of the right way to implement the authorize_request function.</p><h2>Configure our Permissions in Permit.io</h2><p>As you might think of building this authorization service by yourself, there is a simpler way to do it - Using an authorization-as-a-service provider, Permit.io. In the following steps, we will configure all the required permissions for our demo application in a few easy steps.</p><ol><li><div><p>Create a new (and free!) account in <a title="https://app.permit.io/" href="https://app.permit.io/">Permit.io</a>.</p></div></li><li><div><p>Configure our application roles:</p></div><div><ul><li><div><p>Go to the <code>Policy</code> page and then go to the <code>Roles</code> tab and create two roles: <code>admin</code> and <code>user</code>. </p><img src="https://media.graphassets.com/A1zXaFPESWueCXVFqb9T" alt="Add roles.png" title="Add roles.png" width="3361" height="2966" /></div></li><li><div><p>Go to the <code>Users</code> tab and create two new users with the admin and user roles (in the real world, we will sync our users from our authentication provider).</p><img src="https://media.graphassets.com/JP17QeDdThaTh2r7zeU4" alt="Add Users.png" title="Add Users.png" width="1200" height="846" /></div></li></ul></div></li><li><div><p>Configure our application permissions:</p></div><div><ul><li><div><p>Go to <code>Policy</code> screen and then to the <code>Resources</code> tab, click <code>Add Resource</code> button.</p></div></li><li><div><p>In the resource dialog, create a new resource with the following details:</p><img src="https://media.graphassets.com/Brft1CgKTIqqNrqECUCr" alt="Create Resource.png" title="Create Resource.png" width="1201" height="846" /></div></li><li><div><p>In the <code>Policy</code> table, configure the following permissions: </p><img src="https://media.graphassets.com/QFkGFgJyTyGoOv7UOP7f" alt="Policy Config - RBAC.png" title="Policy Config - RBAC.png" width="1200" height="846" /></div></li></ul></div></li></ol><p>As you might notice, at this step, we configured only the RBAC permissions of our application, and every admin user can delete any task. Later in this article, we will demonstrate how to scale the permission model of this app with our requirements without changing any application code. Let&#39;s continue with adding the authorize_request abstract function in the form of permit.check in our FastAPI application.</p><h2>Implementing Permit.io in FastAPI</h2><p>To make everything simpler, we already created a FastAPI application that is ready to use. Let&#39;s continue by doing it interactively in your local Python environment.</p><p>First, let&#39;s clone the application to your local environment:</p><pre><code>git clone git@github.com:permitio/permit-fastapi-example.git</code></pre><p>In the cloned repositories, you&#39;ll notice the following files:</p><ul><li><div><p><a target='_blank' title="https://github.com/permitio/permit-fastapi-example/blob/main/main.py" href="https://github.com/permitio/permit-fastapi-example/blob/main/main.py">main.py</a>: The FastAPI application - includes the endpoints and the auth functions.</p></div></li><li><div><p><a target='_blank' title="https://github.com/permitio/permit-fastapi-example/blob/main/requirements.txt" href="https://github.com/permitio/permit-fastapi-example/blob/main/requirements.txt">requirements.txt</a>: The required Python packages.</p></div></li><li><div><p><a title="https://github.com/permitio/permit-fastapi-example/blob/main/.env" href="https://github.com/permitio/permit-fastapi-example/blob/main/.env">.env</a>: where we will store our Permit.io API secret.</p></div></li></ul><p>Looking at the top of the app.py file, you&#39;ll notice the following code:</p><pre><code>permit = Permit(
    pdp= os.getenv(&quot;permit_pdp_url&quot;),
    token= os.getenv(&quot;permit_sdk_key&quot;)
)

async def authorize(request: Request, token: str = Depends(token_auth_scheme), body={}):
    resource_name = request.url.path.strip(&#39;/&#39;).split(&#39;/&#39;)[0]
    method = request.method.lower()
    resource = await request.json() if method in [&quot;post&quot;, &quot;put&quot;] else body
    user = token.credentials

    allowed = await permit.check(user, method, {
        &quot;type&quot;: resource_name,
        &quot;attributes&quot;: resource
    })

    if not allowed:
        raise HTTPException(status_code=403, detail=&quot;Not authorized&quot;)</code></pre><p>As we described before, this is the code that is responsible for the authorization, and it only enforces the decision of the authorization service.</p><p>To communicate with Permit.io’s decision API, we will have to configure the API key in our application. In Permit.io admin app, go to Settings and copy the API Key of your environment to the .env file as the <code>permit_sdk_key</code> variable.</p><img src="https://media.graphassets.com/xvMemulmQValwaIfXGzV" alt="SDK Key Config.png" title="SDK Key Config.png" width="1196" height="846" /><p>Let&#39;s run the application and see how it works:</p><pre><code>uvicorn main:app --reload</code></pre><p>At this point, you can start test our authorization, do it by run the following commands in a different terminal:</p><pre><code>curl -X GET http://localhost:8000/tasks</code></pre><p>As you can see in the terminal output, here are all the mocked tasks that we created on the application startup.</p><p>If we try now to create a new task, we&#39;ll get an error:</p><pre><code>curl -X POST http://localhost:8000/tasks \
    -d &#39;{&quot;title&quot;: &quot;New Task&quot;, &quot;checked&quot;: &quot;true&quot;}&#39; \
    -H &#39;accept: application/json&#39; \
    -H &#39;Content-Type: application/json&#39;</code></pre><p>This error, is because the authentication phase, as we didn&#39;t provide any token. In our application, we mock the token as the email of the user, let&#39;s try to create a new task with the admin user:</p><pre><code>curl -X POST http://localhost:8000/tasks \
    -d &#39;{&quot;title&quot;: &quot;New Task&quot;, &quot;checked&quot;: &quot;true&quot;}&#39; \
    -H &quot;Authorization: Bearer admin@permit-todo.app&quot; \
    -H &#39;accept: application/json&#39; \
    -H &#39;Content-Type: application/json&#39;</code></pre><p>As you can see, we got a new task created.</p><p>What if we will try to run the same request but with a regular user?</p><pre><code>curl -X POST http://localhost:8000/tasks \
    -d &#39;{&quot;title&quot;: &quot;New Task&quot;, &quot;checked&quot;: &quot;false&quot;}&#39; \
    -H &quot;Authorization: Bearer user@permit-todo.app&quot; \
    -H &#39;accept: application/json&#39; \
    -H &#39;Content-Type: application/json&#39;</code></pre><p>We will get an unauthorize response</p><pre><code>{
  &quot;detail&quot;: &quot;Not authorized&quot;
}</code></pre><p>Let&#39;s try now to call the update endpoint, but now with the regular user:</p><pre><code>curl -X PUT http://localhost:8000/tasks/4 \
    -d &#39;{&quot;title&quot;: &quot;New Task&quot;, &quot;checked&quot;: &quot;false&quot;}&#39; \
    -H &quot;Authorization: Bearer user@permit-todo.app&quot; \
    -H &#39;accept: application/json&#39; \
    -H &#39;Content-Type: application/json&#39;</code></pre><p>All our permissions work as expected; regular users are allowed to update tasks.</p><h2>Change Permissions with No Code Changes</h2><p>The biggest benefit of implementing authorization using this method is the ability to change the policy without changing the application code. We are not only able to change the roles or redefine them, but we could also add support to new permission models. For example, as we described before, our delete endpoint authorization has some more requirements than a simple RBAC check. We want to verify users can delete only their own tasks after they marked them as done.</p><p>Let&#39;s add this configuration in the Permit app:</p><ol><li><div><p>On the <code>Policy</code> page, go to the <code>ABAC Rules</code> tab, enable the <code>ABAC Options</code> switch, and click <code>Create New</code> in the <code>ABAC Resource Sets</code> section</p></div></li><li><div><p>In the Resource Set dialog, fill the following details:</p><img src="https://media.graphassets.com/D53HfPoMQAKGfY5lSDmr" alt="Resource Set Config.png" title="Resource Set Config.png" width="1200" height="846" /></div></li></ol><p>In this simple configuration, we added a new set of tasks that are owned by the user and marked as done. Let&#39;s continue by allowing our users to delete only this resource set by checking the relevant checkboxes on the <code>Policy</code> page.</p><img src="https://media.graphassets.com/1oZEvPbYSzmX16rnnxTB" alt="Policy Config - ABAC.png" title="Policy Config - ABAC.png" width="1200" height="846" /><p><em>Note: To evaluate the ABAC policy in Permit.io, you should run the </em><a target='_blank' title="https://docs.permit.io/tutorials/onboarding/deploying-to-production" href="https://docs.permit.io/tutorials/onboarding/deploying-to-production"><em>PDP service locally</em></a><em>. Running the decision engine locally will also help you to make decisions in better performance.</em></p><p>Let&#39;s try now to delete a non-checked task:</p><pre><code>curl -X DELETE http://localhost:8000/tasks/4 \
    -H &quot;Authorization: Bearer admin@permit-todo.app&quot;</code></pre><p>As you can see, we got an error, as we just configured users are not allowed to delete tasks that are not makred as done.</p><p>Trying to delete a task that is owned by the user and marked as done, succeed!</p><pre><code>curl -X DELETE http://localhost:8000/tasks/4 \
    -H &quot;Authorization: Bearer admin@permit-todo.app&quot;</code></pre><p>Now, think of the time and effort you&#39;ll need to implement this change in your application with the traditional approach. Cool, right?</p><h2>Conclusion</h2><p>In this tutorial, we learned how to implement authorization in the FastAPI application using Permit.io. We learned how to implement the authorization service and how to configure it to support our application permissions. We also learned how to use the authorization service in our application and how to change the permissions without changing the code.</p><p>A topic we haven&#39;t covered much in this article, is the synchronization of your data and authentication provider to Permit.io. To enrich your knowledge of these topics, we invite you to visit Permit.io’s docs to learn more about it.</p><p>We also invite you to join our authorization Slack community to discuss ideas and get advice for the right model for your application.</p>]]></content>
        <author>
            <name>Gabriel L. Manor</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Send Frontend App Events Directly to Slack]]></title>
        <id>send-frontend-app-events-directly-to-slack</id>
        <link href="https://www.permit.io/blog/send-frontend-app-events-directly-to-slack"/>
        <updated>2023-07-07T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Learn how to send Slack messages from a frontend app using FoAz. Configure permissions, proxy calls, and secure tokens. Monitor app events effortlessly!]]></summary>
        <content type="html"><![CDATA[<h2>Introduction</h2><p>In our dynamic startup environment, we are continually seeking ways to monitor users&#39; engagement with our application. We want to get notify for various user actions, such as new sign-ups, achievement of key milestones, configuration of new resources, or subscribing to premium features. To make these moments more memorable, we have found an effective strategy: <strong>directly transmitting these frontend app events to a designated Slack channel</strong>, as they happen.</p><p>One way of doing so is by using dashboarding and monitoring tools to set alerts on specific events. Our application is heavily invested in the UI experience, and we want to measure these milestones based on user actions in the UI. We already use <a title="https://logrocket.com/" href="https://logrocket.com/"><u>LogRocket</u></a> and other observability tools, but haven&#39;t found an efficient way to convert events logged there into Slack messages.</p><p>This article, will show how we <strong>used Slack APIs from our frontend app to send messages to a Slack channel</strong>. We will cover the APIs we used, and how we solved the challenge of calling backend APIs from a frontend app. With this article, you&#39;ll learn how to call backend-oriented APIs directly from the frontend app using a new open-standard protocol called <a title="https://www.foaz.io/" href="https://www.foaz.io/"><u>FoAz</u></a>.</p><h2>Slack APIs</h2><p>Slack is an API-first product with a very rich set of APIs. This means everything that can be done through the UI, can be done using APIs as well. Slack also allows us to build an automated workflow that drives all its cool applications. </p><p>We will use the <a title="https://api.slack.com/methods/chat.postMessage" href="https://api.slack.com/methods/chat.postMessage">chat.postMessage</a> API, which allows us to post messages to a channel. </p><p>Looking at the documentation of the chat.postMessage endpoint, we can see that it requires a token to be sent as part of the request. This token will belong to a special bot we will use to send our event messages. <br><br>Our first challenge is that this token cannot be exposed in the frontend app. <br>The token shouldn&#39;t be available for everyone who accesses our browser app, as we don’t want anyone to just grab it and spam our Slack channel.</p><p>The second challenge, even if we solve the token store problem, is the token&#39;s granularity. <br>The default option would be to set up a token that allows all users to send messages to the channel. That&#39;s not good enough, as we want to<strong> restrict access to only the user who triggered the event</strong>. For example, if we want to send only admin user events, we don&#39;t want regular users to be able to send events.</p><p>To solve these challenges, we will use FoAz, a feature in Permit.io that allows us to call backend APIs from the frontend app and define better permissions for &quot;root&quot; level tokens and secrets.</p><h2>FoAz</h2><p>Frontend Only Authorization (FoAz) is a standard that combines three components:</p><ul><li><div><p>A secret vault that keeps our tokens and secrets secure.</p></div></li><li><div><p>A reverse proxy that verifies our application users&#39; identity (authentication) before the backend API calls are triggered.</p></div></li><li><div><p>A policy engine that checks our users have the right permissions to call the backend API.</p><img src="https://media.graphassets.com/FD0YDynTSSgaGwIwydNe" alt="FoAz Proxy.png" title="FoAz Proxy.png" width="3341" height="2561" /></div></li></ul><p>Using FoAz, we can create Slack API calls directly from the browser. <br>Let&#39;s start to configure our FoAz implementation by opening a free Permit.io account at <a title="https://app.permit.io/" href="https://app.permit.io/">app.permit.io</a></p><h3>Configure Users and Roles</h3><p>The first step in our FoAz configuration is configuring our application’s users and roles.</p><ol><li><div><p>Create the following roles in Permit.io dashboard:</p></div><div><ul><li><div><p>admin - This role will allow users to send messages to the Slack channel.</p></div></li><li><div><p>user - This role will allow users to read messages from the Slack channel.<br></p><img src="https://media.graphassets.com/A1zXaFPESWueCXVFqb9T" alt="Add roles.png" title="Add roles.png" width="3361" height="2966" /></div></li></ul></div></li><li><div><p>Create the following users in Permit.io:</p></div><div><ul><li><div><p><code>thor@foaz-events.app</code> - This user will be assigned to the admin role.</p></div></li><li><div><p><code>someone@foaz-events.app</code> - This user will be assigned to the user role.<br></p><img src="https://media.graphassets.com/GprSwoK0QNufOkFYN1kG" alt="Add users.png" title="Add users.png" width="3361" height="2966" /></div></li></ul></div></li></ol><h3>Get the Slack Token</h3><p>The first step to configure our call is getting the secrets from Slack and storing them in our secret vault. To do that, you&#39;ll have to create a Slack app and get the secrets from there. You can find instructions on how to get the secrets from Slack <a title="https://api.slack.com/authentication/basics" href="https://api.slack.com/authentication/basics"><u>here</u></a>. Mind that you&#39;ll need an app with the <code>chat:write</code> permission and a bot user to send messages to a channel.</p><p>This is an example of our app manifest, so you can paste it on Slack to get a pre-configured app.</p><pre><code>{
    &quot;display_information&quot;: {
        &quot;name&quot;: &quot;Permit.io (bot)&quot;,
        &quot;description&quot;: &quot;Permit.io Announcement Bot&quot;,
        &quot;background_color&quot;: &quot;#3a2f26&quot;
    },
    &quot;features&quot;: {
        &quot;bot_user&quot;: {
            &quot;display_name&quot;: &quot;GreetBot&quot;,
            &quot;always_online&quot;: false
        }
    },
    &quot;oauth_config&quot;: {
        &quot;scopes&quot;: {
            &quot;bot&quot;: [&quot;chat:write&quot;
            ]
        }
    },
    &quot;settings&quot;: {
        &quot;org_deploy_enabled&quot;: false,
        &quot;socket_mode_enabled&quot;: false,
        &quot;token_rotation_enabled&quot;: false
    }
}</code></pre><h3>Configure the API Call Proxy</h3><p>Now that we have the secret to call Slack’s APIs, we can configure the API call proxy. <br>This configuration will add a layer of security between our frontend app and the Slack API, making sure our users are authenticated and authorized to call it.</p><ol><li><div><p>In the FoAz Proxy page in Permit.io, click Add New Configuration</p></div></li><li><div><p>In the URL field, insert slack.com/api/chat.postMessage</p></div></li><li><div><p>In the method field, choose the <code>POST</code> method</p></div></li><li><div><p>To send the message, map this call to a new resource called Chat (you can do it in the dropdown opened when you click on Resource)</p></div></li><li><div><p>Add an action - let’s call it send.</p></div></li><li><div><p>In the secret field, we should paste the Slack bot secret.</p></div></li></ol><p>This is how the configuration should look like:</p><img src="https://media.graphassets.com/ALlqyCkjQsqtvHmhWTc0" alt="FoAz Proxy-1.png" title="FoAz Proxy-1.png" width="3369" height="2085" /><h3>Configure Permissions</h3><p>With our application roles, actions, and resources configured, we can now configure the permissions for our users. In the Policy Editor screen, let&#39;s check only the Admin users to be able to call the Slack API.</p><img src="https://media.graphassets.com/FQRdJeRmQLKNv7IbYO6x" alt="Policy config.png" title="Policy config.png" width="3374" height="2433" /><p>Now that we have our FoAz configured, we can start implementing the frontend app that will call the Slack API.</p><h2>Our Sample Application</h2><p>To run our code, we created a sample application where we will demonstrate how to call the Slack API from the frontend app. We invite you to do this tutorial interactively while your run the code on your local machine.</p><p><strong>Note: To run the application, you&#39;ll need a </strong><a title="https://nodejs.org/en/download" href="https://nodejs.org/en/download"><strong>Node.js</strong></a><strong> environment and a </strong><a title="https://api.slack.com/apps?new_granular_bot_app=1" href="https://api.slack.com/apps?new_granular_bot_app=1"><strong>Slack app/account</strong></a><strong>.</strong></p><h3>Run the Application</h3><ol><li><div><p>Clone the <a title="https://github.com/permitio/foaz-slack-example" href="https://github.com/permitio/foaz-slack-example">sample application</a></p><pre><code>git clone git@github.com:permitio/foaz-slack-example.git</code></pre></div></li><li><div><p>Install the dependencies</p><pre><code>⁠npm install</code></pre></div></li><li><div><p>Run the application</p><pre><code>npm run dev</code></pre></div></li></ol><h3>Configure Slack Channel ID</h3><p>To send messages to a specific channel, we need to configure the channel ID in our application.</p><p>To grab that ID, right-click on the channel name and select Copy Link from the menu. </p><p></p><img src="https://media.graphassets.com/vZNsM5rTyCklJPjPjam6" alt="Slack copy.png" title="Slack copy.png" width="3119" height="2433" /><p>The link will look like this: <code>https://permit-io.Slack.com/archives/</code><code><strong>C02TVG7RY1X</strong></code></p><p>Copy the link&#39;s last part, and paste it to the <code>VITE_SLACK_CHANNEL_ID</code> constant in the .env file.</p><p>To complete the configuration, we also should paste the proxy ID from the FoAz configuration to the file as the <code>VITE_PERMIT_PROXY_ID</code> variable</p><p></p><img src="https://media.graphassets.com/YZKf28fTZKe4nOMEfLCJ" alt="FoAz ID.png" title="FoAz ID.png" width="3374" height="2433" /><p>The code in the .env file should look like this:</p><pre><code>VITE_SLACK_CHANNEL_ID=C05EDEC1F7C
VITE_PERMIT_PROXY_ID=b8d1fd0681b745e2accaa1cdf24c52e1</code></pre><h3>Test the Application</h3><p>As you can see in the opened browser window, we need to log in to our application. Our goal is to get Slack messages sent to the events channel when our admin logs in but not when a regular user logs in. Let&#39;s try to login with the admin user we created in Permit.io - <code>thor@foaz-events.app</code> (at this point, we just mock local auth, no password needed). Now when you log in, you suppose to see immediately that we fail to send the event message and we can see an error message 🫤.</p><h3>Configure JWKs</h3><p>The reason for the error is that our token cannot be verified by the proxy. To make our token to be verifiable by the proxy, we need to configure the proxy with the JWKs we used to sign the token.</p><ol><li><div><p>Go to the terminal when you used to run npm run dev, and search for the following log message.</p><pre><code>--- Public JWKS --- 
{&quot;keys&quot;:[{&quot;kty&quot;:&quot;RSA&quot;,&quot;kid&quot;:&quot;5vXye0jM2MxctISKoq64V2Pb05mXQJQS6QpuhcfLps4&quot;,&quot;use&quot;:&quot;sig&quot;,&quot;alg&quot;:&quot;RS256&quot;,&quot;e&quot;:&quot;AQAB&quot;,&quot;n&quot;:&quot;kmTcV248-bCY7pwwLztRK8sSXXd5PYIq62PIQdLZcVg-ns0F_TfOydKqmZPrDTD_CH0DcKauB3naq79iTGKgj_ded0q5dAKWfRc-2X_sGYYY4Er6esOp4nTx1gPy6WfdZKBdett4YP9cA43sHR96VMOEpQv0cEo9XklmDdcBmcPeCf1Xp2Io_kS8wZMD-uE7ZwwX5Y4skvO3LiXqKUk-OJf0H0GR35D_YrCYYM_5jbUkgXnfM2RStKlVEzBNNUM85PCOyqhH2rb3EA3TvsCdhTyz6sLgPnQ6EN_tRG8CesuvOr3fqxqRBWfiEkwNJ1DwMuw3j2iAaUGLcw69WMdnAw&quot;}]}</code></pre></div></li><li><div><p>In Permit.io UI, go to Settings -&gt; JWKs and add the JWKs from the logs in your relevant environment.<br></p><img src="https://media.graphassets.com/UoNEb1pSwQlSzV9iZ1FA" alt="Config JWKs.png" title="Config JWKs.png" width="3211" height="2501" /></div></li></ol><p>Now, let&#39;s try to login again with the admin user. As you can see, we got a success message that we are logged in, and we got a message in our Slack channel.</p><h2>Test Permissions</h2><p>As you remember, the other challenge we had was to limit the access to the Slack API to only the admin users. Let&#39;s try now to logout and login with the regular user we created in Permit.io - <code>someone@foaz-events.app</code> - as you can see now, and we got an error message that we are not authorized to call the Slack API.</p><p>To see the real magic of FoAz in action, let&#39;s go back to the policy editor screen in Permit.io and change the policy to allow the regular user to call the Slack API.</p><img src="https://media.graphassets.com/oZOeGfV4TBi6bl1gPztu" alt="Policy config 2.png" title="Policy config 2.png" width="3374" height="2433" /><p>Now, let&#39;s try to login again with the regular user. As you can see, we got a success message that we are logged in, and we got a message in our Slack channel.</p><h2>Summary</h2><p>In this article, we&#39;ve learned how easily you can create a simple sending of app events in your application. As a next step, you can wrap the example code with a nice app events framework in your application and do it in a more elegant way.</p><p>Want to learn more about permissions and frontend access control? <br>Read about FoAz in <a title="https://permit.io/" href="https://permit.io/">Permit.io</a> and <a title="https://foaz.io/" href="https://foaz.io/">FoAz</a>. If you have any more questions regarding this article or FoAz, you are welcome to <a title="https://io.permit.io/permitslack" href="https://io.permit.io/permitslack">join our Slack community</a>.</p>]]></content>
        <author>
            <name>Gabriel L. Manor</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Add a Slack Chatbox Directly into Your React App]]></title>
        <id>add-a-slack-chatbox-directly-into-your-react-app</id>
        <link href="https://www.permit.io/blog/add-a-slack-chatbox-directly-into-your-react-app"/>
        <updated>2023-07-05T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Learn how to build a Slack-based chat box in your frontend app using React authorization and the Slack API. Secure access with FoAz. Try the working example.]]></summary>
        <content type="html"><![CDATA[<h2>Introduction</h2><p>Like every company, we always try to be there for our users, answer questions, get feedback, and help them get the most out of our product. One of the ways we do that is by using <strong>Slack</strong>. For every Pro/Enterprise account in our app, we create a dedicated Slack channel and invite the account users to that channel.</p><p>Of course, users can just use their Slack app to communicate with us, but we wanted to make it easier for them. For this reason, we created an embedded chat box directly in our app, through which they can communicate with their dedicated Slack channel, ask questions, get support, and give us feedback. Additionally, it allows all the users from one organization to see the messages sent to the channel and the answers you provide. This way, they can get immediate support for questions they may have during their usage of our app.</p><p>In this article, we will share a basic example of building a Slack-based chat box in your frontend app. We will show an innovative way to interact with Slack APIs from the frontend app, and how to use FoAz to secure access to the Slack APIs. At the end of the reading, you&#39;ll also have a working example of a Slack-based chat box that you can use in your app.</p><video controls width="undefined" height="undefined">
          <source src="https://media.graphassets.com/x97qqexzTNebkjHoihDn" type="video/mp4" title="foaz_slack.mp4" />
          Sorry, your browser doesn't support embedded videos.
        </video><h2>Slack APIs</h2><p>Slack is an API-first product, with a very rich set of APIs. This means everything that can be done through the UI, can be done using APIs as well. They also allow us to build an automated workflow that drives all the cool applications you see in Slack. </p><p>We will use two APIs for our chat box: One is the <a title="https://api.slack.com/methods/conversations.history" href="https://api.slack.com/methods/conversations.history">conversations.history</a> API, which allows us to read the messages from the channel, and the second is the <a title="https://api.slack.com/methods/chat.postMessage" href="https://api.slack.com/methods/chat.postMessage">chat.postMessage</a> API, which allows us to  send messages. Both of these APIs are HTTP-based endpoints that allow us to create a chat box in our frontend app.</p><p>Looking at the documentation of the chat.postMessage endpoints, we can see that it requires a token to be sent as part of the request. We don&#39;t want to use the user&#39;s token, as not all of the app users will have access to the channel or Slack account, so we want to use a bot token. This token will belong to a bot that will send and retrieve messages from the channel.</p><p>Using such a token has two challenges we need to deal with:</p><ol><li><div><p>We cannot expose the token in the frontend app, as it will allow anyone to find it and send messages to the channel.</p></div></li><li><div><p>We want only admin users of our app will be able to send messages to the channel. Regular users have no SLA to send support messages to the channel.</p></div></li></ol><p>To deal with those challenges, we will use <a title="https://www.permit.io/foaz" href="https://www.permit.io/foaz"><u>FoAz</u></a>, a feature in Permit.io that allows us to call backend APIs from the frontend app and define better permissions for &quot;root&quot; level tokens and secrets.</p><h2>FoAz</h2><p><strong>F</strong>rontend <strong>O</strong>nly <strong>A</strong>uthori<strong>z</strong>ation (Or, FoAz) solves two major problems for us:</p><ol><li><div><p>It allows frontend apps to call backend APIs without exposing the backend API keys in the frontend app by using the user&#39;s frontend (temporary) JWT.</p></div></li><li><div><p>It allows us to define better permissions for &quot;root&quot; level tokens and secrets.</p></div></li></ol><p>While you can implement FoAz yourself by following the open standard at <a title="https://foaz.io/" href="https://foaz.io/">foaz.io</a>, we will use Permit.io to implement FoAz in our app. For the purpose of this demo, let&#39;s start by configuring our FoAz to secure the calls to the Slack APIs in Permit.io. If you haven&#39;t signup to Permit.io yet, you can do it <a title="https://app.permit.io/" href="https://app.permit.io/">here</a>.</p><p><strong>Note: In order to follow the technical demo in this article, you must have installed Node.js/npm on your computer.</strong></p><h2>Create Slack App</h2><p>To call Slack APIs, we need to create a Slack app that will allow you to call their APIs and use a bot to send messages.</p><p>To create Slack app, you can follow these steps:</p><ol><li><div><p>In <a title="https://api.slack.com" href="https://api.slack.com"><u>https://api.slack.com</u></a> - login with your Slack credentials and click Your Apps in the top right corner</p></div></li><li><div><p>Click on Create New App in the top right corner of your applications list</p></div></li><li><div><p>Your app should have the following permissions and a bot, you can configure it manually or just paste the following app manifest (change it per your needs)</p><pre><code>{
    &quot;display_information&quot;: {
        &quot;name&quot;: &quot;Permit.io (bot)&quot;,
        &quot;description&quot;: &quot;Permit.io Announcement Bot&quot;,
        &quot;background_color&quot;: &quot;#3a2f26&quot;
    },
    &quot;features&quot;: {
        &quot;bot_user&quot;: {
            &quot;display_name&quot;: &quot;GreetBot&quot;,
            &quot;always_online&quot;: false
        }
    },
    &quot;oauth_config&quot;: {
        &quot;scopes&quot;: {
            &quot;bot&quot;: [
                &quot;channels:history&quot;,
                &quot;channels:read&quot;,
                &quot;chat:write&quot;,
                &quot;users:read&quot;
            ]
        }
    },
    &quot;settings&quot;: {
        &quot;org_deploy_enabled&quot;: false,
        &quot;socket_mode_enabled&quot;: false,
        &quot;token_rotation_enabled&quot;: false
    }
}</code></pre></div></li></ol><h2>Configure Chat Permissions</h2><p>Let&#39;s start our tutorial by setting up the necessary configuration required to create the chat box.</p><h3>Users and Roles</h3><p>To create secure access, we will first need to define users and roles. In your app, you&#39;ll probably already have a way to authenticate your users, but to save time in this example, we will use Permit.io to create mock users and roles. For a full guide on setting up roles and permissions in Permit.io, <a title="https://www.permit.io/blog/rbac-with-permit" href="https://www.permit.io/blog/rbac-with-permit"><u>check out this tutorial</u></a>. </p><ol><li><div><p>Create the following roles in Permit.io:</p></div><div><ul><li><div><p>admin - This role will be used to allow users to send messages to the Slack channel.</p></div></li><li><div><p>user - This role will be used to allow users to read messages from the Slack channel.<br></p><p></p></div></li></ul></div></li><li><div><p>Create the following users in Permit.io:</p></div><div><ul><li><div><p>thor@foaz-chatbox.app - This user will be assigned to the admin role.</p></div></li><li><div><p>someone@foaz-chatbox.app - This user will be assigned to the user role.</p><img src="https://media.graphassets.com/GprSwoK0QNufOkFYN1kG" alt="Add users.png" title="Add users.png" width="3361" height="2966" /></div></li></ul></div></li></ol><h3>Slack API Access</h3><p>Now that we have the users and roles, we can configure access to the Slack APIs. In the Permit.io app sidebar menu, you&#39;ll find a page called FoAz Proxy. This page allows you to configure the access to the Slack APIs, and to define the permissions for the users and roles we created in the previous step.</p><ol><li><div><p>Create a new FoAz Proxy by clicking the Add Configuration button.</p></div></li><li><div><p>Assign it a name, for example, Slack Chat</p></div></li><li><div><p>In the URL field, assign the following URL to read Slack messages <code>slack.com/api/conversations.history</code></p></div></li><li><div><p>In the method, choose the <code>POST</code> method</p></div></li><li><div><p>In the <code>Resource</code> dropdown, choose to Create New and create a new resource named <code>Chat</code> with the actions of <code>read</code> and <code>send</code></p><img src="https://media.graphassets.com/lbNunpD2S2mXiMyhI69a" alt="Add Resource.png" title="Add Resource.png" width="674" height="650" /></div></li><li><div><p>Choose the action <code>Read</code> for the mapping rule we just created</p></div></li><li><div><p>Click on + Mapping Rule and paste the following URL <code>slack.com/api/chat.postMessage</code> in it, choose the method post, and assign <code>Chat</code> and <code>send</code> as action and resource</p></div></li><li><div><p>Repeat the previous step and paste the following URL <code>slack.com/api/users.list</code> in it, choose the method <code>GET</code>, and assign <code>Chat</code> and <code>read</code> as action and resource<br></p><img src="https://media.graphassets.com/QuIpBw4SF6w8BS9VF0Wk" alt="FoAz Config.png" title="FoAz Config.png" width="1199" height="831" /></div></li></ol><h3>Chat Permissions</h3><p>Now that we have configured the building blocks of our permission model (Roles, Actions [HTTP Methods], and Resources [URLs]), we can now create the permissions for the users and roles we created in the previous step. In the Policy Editor tab, let&#39;s mark the following permissions for our two roles:</p><img src="https://media.graphassets.com/bbIHptbQmyo9lPDFqmwZ" alt="Proxy Config.png" title="Proxy Config.png" width="1195" height="863" /><p>At this point, we have all our permissions configured, and we can start using the FoAz proxy to call the Slack APIs from our frontend app. Let&#39;s clone a sample widget and try to use our new chat box.</p><h2>Clone the Sample Widget</h2><p>To save time, we created a sample widget that you can use to build your own Slack-based chat box. Although this widget is written in React, you can use the same approach in any frontend framework you use.</p><ol><li><div><p>Clone the <a title="https://github.com/permitio/foaz-slack-example" href="https://github.com/permitio/foaz-slack-example"><u>following repository</u></a></p><pre><code>git clone git@github.com:permitio/foaz-slack-example.git</code></pre></div></li><li><div><p>In the terminal, from the same directory you just cloned the project, Install the dependencies for our demo</p><pre><code>npm install</code></pre></div></li><li><div><p>Configure the right Slack channel where you want to send the messages in the .env file (to get the channel ID, right-click on the channel name, choose Copy Link, and grab the ID from the link you copied)</p><pre><code>VITE_REACT_APP_Slack_CHANNEL_ID=&lt;YOUR_Slack_CHANNEL_ID&gt;</code></pre></div></li><li><div><p>Configure the Proxy ID by copying the configuration ID from Permit’s app to the relevant environment variable in the .env file.</p><img src="https://media.graphassets.com/YZKf28fTZKe4nOMEfLCJ" alt="FoAz ID.png" title="FoAz ID.png" width="3374" height="2433" /></div></li><li><div><p>Start the development server</p><pre><code>npm run dev</code></pre></div></li><li><div><p>Open the browser at <a title="http://localhost:3000/" href="http://localhost:3000/">http://localhost:</a>5173, and login with the thor@foaz-chatbox.app user we created in the previous step.</p></div></li></ol><p>At this point, you should see a chat box in the bottom right corner of the screen. If you try to send a message, you&#39;ll see that FoAz cannot authorize you to send the message, as we didn&#39;t connect our login method to the FoAz proxy yet.</p><h2>Configure the Proper JWKs</h2><p>FoAz uses the user&#39;s JWT token to call the backend APIs. The way that FoAz verifies the user&#39;s identity is by validating the <a title="https://docs.permit.io/foaz/fetching-jwks/?_gl=1*101hr7q*_ga*MTY3MDU2NTUyNy4xNjc4ODY2NzEw*_ga_SPFKH5NXDE*MTY4Nzg2MTQ3MC4xMTAuMC4xNjg3ODYxNDcwLjAuMC4w#what-are-jwks" href="https://docs.permit.io/foaz/fetching-jwks/?_gl=1*101hr7q*_ga*MTY3MDU2NTUyNy4xNjc4ODY2NzEw*_ga_SPFKH5NXDE*MTY4Nzg2MTQ3MC4xMTAuMC4xNjg3ODYxNDcwLjAuMC4w#what-are-jwks"><u>JWT token against the public JWKs supplied by the authentication authority</u></a>. This method is supported by all the major authentication providers, and you can find the JWKs URL in the authentication provider&#39;s documentation.</p><p>In our case, tho, to avoid the mess of configuring the authentication provider, we will use mock JWKs that we will configure in Permit.io. To find your JWKs configuration, in the terminal window where you started the sample widget, you should see the following message:</p><pre><code> --- Public JWKS --- 
{&quot;keys&quot;:[{&quot;kty&quot;:&quot;RSA&quot;,&quot;kid&quot;:&quot;tvPApr70xhk-RJrKgXuTeIz9KyNjrf_6NABfvh61rCA&quot;,&quot;use&quot;:&quot;sig&quot;,&quot;alg&quot;:&quot;RS256&quot;,&quot;e&quot;:&quot;AQAB&quot;,&quot;n&quot;:&quot;qgSzmsz-Astj1FjJdqqnkaW-696aQTxrjPB7U-_uk0pto4cbTrnWihNBs791Itr0MX0XX_7BO3z-SILEcyP75vDapcn0vleJ_t-Kd1uQPiNKaUClqFqN8QmoyIE7CBCp196QfgAVVBTMgGsKXwNpGFKQg35QmKhbKlA92Ahj14S3C7B0L7OhrEUk3T9tM4QIhgbnyG_xUXT7StNE3lw-3SwS1qIU1-pQXE7OPWkcv5GEnlIxXaoxqhQZrQE77YIxgrRVrA6fbQdTLhNELO_1ZWOyFIkcRr9AJX1-Ar-92n5StHIZfIwl5-sKC931k1JgkCfuxklrbrbcgmwKR_3BlQ&quot;}]}</code></pre><p>As this is the public key Permit.io will use to validate the JWT token, we need to configure it in Permit.io.</p><p>In Permit.io UI, go to Settings -&gt; JWKs and add the JWKs from the logs in your relevant environment.</p><img src="https://media.graphassets.com/UoNEb1pSwQlSzV9iZ1FA" alt="Config JWKs.png" title="Config JWKs.png" width="3211" height="2501" /><p>Let&#39;s now go back again to the sample widget, and try to send a message again. This time, you should see that the message was sent successfully.</p><h2>Verify the Proper Permissions</h2><p>As we mentioned before, we want to allow only admin users to send messages to the Slack channel. To verify that, let&#39;s try to login with the someone@foaz-chatbox.app user we created in the previous step, and try to send a message.</p><img src="https://media.graphassets.com/gpyWzgyvRm60qo7smJMM" alt="Chat Example.png" title="Chat Example.png" width="1199" height="1058" /><p>As you can see, this time the message was not sent, as the user doesn&#39;t have the proper permissions to send messages to the Slack channel. Yet, we still can read the messages from the channel, as we configured the proper permissions for the user role.</p><p>One of the coolest things you can achieve by using FoAz is permissions that do not depend on the code of your application. In this example, we can now change the checkbox in the Policy Editor tab, and allow the user role to send messages to the Slack channel. If you try to send a message again, you&#39;ll see that this time the message was sent successfully.</p><h2>Use the Chat Box in Your App</h2><p>Although the code we used to demonstrate the chat box is not production ready (as it lacks error handling, edge cases, etc.) you can get a good idea of how to create one yourself in your app.</p><p>In the app.tsx file, you’ll find the required elements for the interactive chat box. We base our app on material-UI which means you can customize it according to your specific UI needs. In the same file, you’ll also find the way we utilize a useSlack hook that helps us with all the data we need to get and send to the Slack APIs. Use it as-is or create your needed hook yourself.</p><p>const { slackUser, setSlackUser, messages, send, loading, sending } = useSlack();</p><p>In the useSlack file, you’ll find first the functions we used to generate mocks of the JWT and a wrapper to the fetch function that call the Slack APIs via FoAz proxy. You’ll also find the hook itself that contains the relevant function to manage all the chat flow we manage with Slack.</p><pre><code>const proxyFetch = async (url: string, user: string, method: string, body: any) =&gt; {
    const token = await generateJWT(user);
    const res = await fetch(`https://proxy.api.permit.io/proxy/${PROXY_ID}?url=${url}`, {
        method,
        body: body ? JSON.stringify(body) : undefined,
        headers: {
            &#39;Authorization&#39;: `Bearer ${token}`,
            &#39;Content-Type&#39;: &#39;application/json&#39;
        }
    });
    const json = await res.json();
    const status = res.status;
    return { status, json };
}</code></pre><h2>Conclusion</h2><p>At this point, you should have enough knowledge to create your own chat box and use FoAz to secure access to the Slack APIs. As the next step, we invite you to think of more creative FoAz ways to create cool new worlds in your frontend apps.</p><p>You can read more on FoAz as a standard in <a title="https://foaz.io/" href="https://foaz.io/">foaz.io</a>, and join our community <a title="https://io.permit.io/permitslack" href="https://io.permit.io/permitslack"><u>working group in Slack</u></a> to contribute to the standard and the open-source project.</p><p>Happy FoAzing!</p>]]></content>
        <author>
            <name>Gabriel L. Manor</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Implementing Authorization in 4 Node.js Frameworks]]></title>
        <id>implementing-authorization-in-4-nodejs-frameworks</id>
        <link href="https://www.permit.io/blog/implementing-authorization-in-4-nodejs-frameworks"/>
        <updated>2023-07-02T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Explore top resources for implementing RBAC authorization in Node.js frameworks - Express, Next.js, Fastify, and NestJS.]]></summary>
        <content type="html"><![CDATA[<p>As web developers, ensuring the security of our applications is one of our top priorities. One of the main pillars of security is implementing a robust authorization mechanism that efficiently manages user permissions. In this blog post, we will summarize and provide links to some of the best resources to guide you in adding authorization to various Node.js/ frameworks.</p><p>Let&#39;s delve into each article:</p><h2>1. <a title="https://www.permit.io/blog/implement-rbac-authorization-in-express" href="https://www.permit.io/blog/implement-rbac-authorization-in-express">Implement RBAC Authorization in Express</a></h2><p>Express.js is a popular minimalist web application framework for Node.js. This guide explores the process of integrating RBAC (Role-Based Access Control) into an Express application. RBAC is a popular authorization scheme where permissions are associated with roles, and users are assigned roles to gain certain permissions. This structure helps manage complex systems with multiple users and roles, providing a high level of granularity for permission control.</p><p>The article guides you through creating a basic Express.js app, setting up user models with roles, defining role permissions, and creating middlewares to check user permissions before accessing certain routes. By following this guide, you can successfully integrate RBAC into your Express.js app, making your application secure and manageable.</p><h2>2. <a title="https://www.permit.io/blog/how-to-add-rbac-in-nextjs" href="https://www.permit.io/blog/how-to-add-rbac-in-nextjs">How to Add RBAC in Next.js</a></h2><p>Next.js, a React framework, is gaining significant popularity due to its simplicity and performance features. As with Express.js, integrating RBAC into a Next.js application significantly enhances its security. This guide provides detailed instructions on setting up RBAC for Next.js.</p><p>The article follows a similar flow as the Express.js guide but with some variations due to the differences between the two frameworks. It includes guidance on creating a Next.js app, setting up user models, defining roles and permissions, and creating an authorization middleware. Follow this guide to fortify your Next.js application with a robust authorization mechanism.</p><h2>3. <a title="https://www.permit.io/blog/how-to-create-an-authorization-middleware-for-fastify" href="https://www.permit.io/blog/how-to-create-an-authorization-middleware-for-fastify">How to Create an Authorization Middleware for Fastify</a></h2><p>Fastify, a high-performance web framework for Node.js, prides itself on its speed and low overhead. To complement this efficiency, an effective authorization mechanism is crucial. This article explores how to create an authorization middleware for Fastify.</p><p>The article provides insights into Fastify&#39;s unique approach to middleware and how it can be harnessed to build robust authorization for your application. It explains how to define user roles and permissions, how to create authorization middleware using Fastify&#39;s hooks, and how to apply this middleware to secure your application&#39;s routes. Dive into this guide to add efficient authorization to your Fastify application.</p><h2>4. <a title="https://www.permit.io/blog/how-to-protect-a-url-inside-a-nestjs-app-using-rbac-authorization" href="https://www.permit.io/blog/how-to-protect-a-url-inside-a-nestjs-app-using-rbac-authorization">How to Protect a URL Inside a NestJS App Using RBAC Authorization</a></h2><p>NestJS, a progressive Node.js framework for building efficient and scalable server-side applications, is highly extensible and supports modularization, making it suitable for complex applications. This guide demonstrates how to protect a URL inside a NestJS application using RBAC.</p><p>The article goes over how to set up your NestJS application, define roles and permissions, and create guards for route protection. The guard acts as an authorization middleware, validating if a user can access certain URLs based on their role and permissions. Check out this guide to enhance your NestJS application&#39;s security.</p><p>In conclusion, implementing a robust authorization mechanism is an essential security measure for any application. Depending on your choice of Node.js/JS framework, these resources provide step-by-step instructions on how to integrate RBAC for secure and efficient management of user permissions. Happy coding!</p>]]></content>
        <author>
            <name>Gabriel L. Manor</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[OPA for App-Level Authorization, from RBAC to ABAC in Scale]]></title>
        <id>opa-for-app-level-authorization-from-rbac-to-abac-in-scale</id>
        <link href="https://www.permit.io/blog/opa-for-app-level-authorization-from-rbac-to-abac-in-scale"/>
        <updated>2023-07-02T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Explore key guides on implementing Open Policy Agent (OPA) for scalable application-level authorization, from RBAC to ABAC.]]></summary>
        <content type="html"><![CDATA[<p>Authorization is a fundamental concern in building secure, robust cloud applications. In the past, developers typically implemented authorization directly into their applications, leading to tightly coupled, complex systems. Fortunately, <a title="https://www.permit.io/blog/introduction-to-opa" href="https://www.permit.io/blog/introduction-to-opa">Open Policy Agent (OPA)</a>, a general-purpose policy engine, has emerged as a flexible and powerful tool for managing authorization at scale, from <a title="https://www.permit.io/blog/implement-rbac-using-opa" href="https://www.permit.io/blog/implement-rbac-using-opa">Role-Based Access Control (RBAC)</a> to <a title="https://www.permit.io/blog/implement-abac-using-opa" href="https://www.permit.io/blog/implement-abac-using-opa">Attribute-Based Access Control (ABAC)</a>. In this blog post, we compile a series of key articles that guide you through implementing OPA as your authorization engine.</p><h2>Introduction to OPA</h2><p>In the <a title="https://www.permit.io/blog/introduction-to-opa" href="https://www.permit.io/blog/introduction-to-opa">Introduction to OPA</a>, you&#39;ll learn about the basics of Open Policy Agent. OPA is an open-source, general-purpose policy engine that enables unified, context-aware policy enforcement across your entire stack. This article gives a thorough breakdown of how OPA works, its use cases, and the benefits it brings to cloud-native applications.</p><h2>Netflix AuthZ</h2><p>The article on <a title="https://www.permit.io/blog/netflix-authz" href="https://www.permit.io/blog/netflix-authz">Netflix AuthZ</a> provides real-world evidence of OPA&#39;s power and flexibility. Netflix, a global leader in the entertainment industry, leverages OPA for fine-grained, context-aware authorization, and this piece details how they use OPA for authorization in their microservices architecture.</p><h2>Implementing RBAC using OPA</h2><p><a title="https://www.permit.io/blog/implement-rbac-using-opa" href="https://www.permit.io/blog/implement-rbac-using-opa">Implementing RBAC using OPA</a> is a hands-on guide to setting up Role-Based Access Control using OPA. RBAC, a system where permissions are associated with roles and users are assigned to these roles, is a common pattern for managing authorization. This article walks you through setting up an RBAC system using OPA, with code snippets and explanations along the way.</p><h2>Implementing ABAC using OPA</h2><p>Next, we have <a title="https://www.permit.io/blog/implement-abac-using-opa" href="https://www.permit.io/blog/implement-abac-using-opa">Implementing ABAC using OPA</a>, an article that introduces you to Attribute-Based Access Control. ABAC is a flexible, granular authorization model that uses attributes (characteristics, properties, etc.) associated with users, the environment, or the resource itself to decide permissions. The piece outlines how to set up an ABAC system using OPA, providing code samples and detailed explanations.</p><h2>Introduction to OPAL</h2><p>Moving beyond the basics, the <a title="https://www.permit.io/blog/introduction-to-opal" href="https://www.permit.io/blog/introduction-to-opal">Introduction to OPAL</a> post presents an advanced tool for working with OPA: OPAL (OPA as a Library). OPAL provides an interface to use OPA as a Go library, which can be used to make your applications policy-aware without making them policy-dependent.</p><h2>Load External Data into OPA</h2><p><a title="https://www.permit.io/blog/load-external-data-into-opa" href="https://www.permit.io/blog/load-external-data-into-opa">Load External Data into OPA</a> dives into one of the most powerful aspects of OPA: its ability to use external data for policy decisions. This article provides step-by-step instructions on how to load data into OPA from an external source, enhancing the flexibility and context-awareness of your authorization.</p><h2>Access Control: Scary to Simple</h2><p>Finally, <a title="https://www.permit.io/blog/access-control-scary-to-simple" href="https://www.permit.io/blog/access-control-scary-to-simple">Access Control: Scary to Simple</a> wraps up with a deep dive into simplifying access control with OPA. The piece discusses common pitfalls in managing access control and how adopting OPA can help you avoid these issues, keeping your authorization policies simple, efficient, and effective.</p><p>In conclusion, using OPA for application-level authorization brings significant benefits to your application security. The scalability and flexibility of OPA, from RBAC to ABAC, are testament to its power, and the articles above provide all the guidance you need to start implementing OPA in your cloud applications.</p>]]></content>
        <author>
            <name>Gabriel L. Manor</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Everything You Need to Know about AWS’ Cedar Policy Language]]></title>
        <id>everything-you-need-to-know-about-aws-cedar-policy-language</id>
        <link href="https://www.permit.io/blog/everything-you-need-to-know-about-aws-cedar-policy-language"/>
        <updated>2023-07-02T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[A compilation of key articles that delve into Cedar's capabilities and potential]]></summary>
        <content type="html"><![CDATA[<p>If you&#39;re working with AWS, or in general with application level permissions, you&#39;ll want to get familiar with Cedar, a new policy-as-code language developed by AWS. It&#39;s a game-changer for policy management and access control, introducing a structured and scalable way to manage permissions. Here&#39;s a compilation of key articles that delve into Cedar&#39;s capabilities and potential:</p><ol><li><div><p><a title="https://www.permit.io/blog/oss-aws-cedar-is-a-gamechanger-for-iam" href="https://www.permit.io/blog/oss-aws-cedar-is-a-gamechanger-for-iam">AWS Cedar: A Game Changer for IAM</a></p><p>This article provides a comprehensive overview of Cedar and why it&#39;s a significant advancement for IAM management. It discusses how Cedar simplifies policy creation, enhances scalability, and improves security, all while remaining open-source and easy to adopt. This is a must-read for anyone wanting to grasp the basics of Cedar.</p></div></li><li><div><p><a title="https://www.permit.io/blog/cedar-rbac" href="https://www.permit.io/blog/cedar-rbac">Cedar and Role-Based Access Control (RBAC)</a></p><p>Learn about the intersection of Cedar and RBAC in this article. It covers how Cedar takes RBAC a step further, allowing for fine-grained, context-aware permission control. The piece also explores Cedar&#39;s role in a range of situations, from simple access control to complex use cases.</p></div></li><li><div><p><a title="https://dev.to/aws-builders/authorization-and-cedar-a-new-way-to-manage-permissions-part-i-1nid" href="https://dev.to/aws-builders/authorization-and-cedar-a-new-way-to-manage-permissions-part-i-1nid">Authorization and Cedar: A New Way to Manage Permissions Part I</a></p><p>This deep dive into Cedar&#39;s role in managing permissions is the first of a two-part series. It discusses how Cedar offers a more efficient and secure way to manage permissions, with a focus on the basics of writing Cedar policies and using Cedar to enhance authorization.</p></div></li><li><div><p><a title="https://www.permit.io/blog/scaling-authorization-with-cedar-and-opal" href="https://www.permit.io/blog/scaling-authorization-with-cedar-and-opal">Scaling Authorization with Cedar and Opal</a></p><p>This post details how Cedar and Opal can work together to create scalable, robust authorization systems. It covers the benefits of using these tools together, including the increased flexibility, improved security, and better scalability that result from their synergy.</p></div></li><li><div><p><a title="https://www.permit.io/blog/cedar-qna" href="https://www.permit.io/blog/cedar-qna">Cedar: Questions and Answers</a></p><p>If you have questions about Cedar, this article has answers. From the basics of what Cedar is and how it works, to more complex inquiries about specific use cases and compatibility, this comprehensive Q&amp;A is a helpful resource for understanding Cedar.</p></div></li><li><div><p><a title="https://www.permit.io/blog/opa-vs-cedar" href="https://www.permit.io/blog/opa-vs-cedar">OPA vs Cedar: A Comparative Analysis</a></p><p>This article provides a comparative analysis between Cedar and Open Policy Agent (OPA), another popular open-source policy-as-code framework. It outlines their respective strengths and weaknesses, and offers insights into why you might choose one over the other.</p></div></li><li><div><p><a title="https://github.com/cedar-policy/cedar-awesome" href="https://github.com/cedar-policy/cedar-awesome">Cedar Awesome: A Community Project</a></p><p>This GitHub repository is a curated list of resources, articles, tools, and other materials related to Cedar. It&#39;s a community project designed to promote the understanding and usage of Cedar. Whether you&#39;re a beginner or an advanced user, you&#39;ll find something helpful here.</p></div></li></ol><p>Cedar is an innovative tool that significantly simplifies and enhances IAM management on AWS. Its policy-as-code language provides unprecedented control, flexibility, and scalability. Take the time to explore these resources and understand how you can leverage Cedar&#39;s capabilities in your AWS environment.</p>]]></content>
        <author>
            <name>Or Weis</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[How to Implement RBAC Authorization in a NestJS Application]]></title>
        <id>how-to-protect-a-url-inside-a-nestjs-app-using-rbac-authorization</id>
        <link href="https://www.permit.io/blog/how-to-protect-a-url-inside-a-nestjs-app-using-rbac-authorization"/>
        <updated>2023-06-30T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Master Nestjs app authorization with ease. Implement RBAC using Permit.io, then effortlessly scale to ABAC. Enhance security with this comprehensive guide.]]></summary>
        <content type="html"><![CDATA[<p>TL;DR: Enhance the security of your Nest.js API endpoints with Permit.io — a powerful tool for implementing authorization and access control. Ensure only authorized users have access to sensitive data.</p><p>Building secure and reliable API endpoints is crucial when developing applications with Nest.js. In this blog post, we will explore how you can enhance the security of your Nest.js APIs using Permit.io — a tool specifically designed for access control. By integrating Permit.io into your Nest.js project, you can ensure that only authorized users can access your API endpoints, protecting sensitive data and preventing unauthorized actions. </p><h2>What we will cover:</h2><ol><li><div>Setting up a Nest.js Project</div></li><li><div>Working with Nest.js Passport library</div></li><li><div>Writing a decorator guard</div></li><li><div>Setting up our first policy with Permit</div></li><li><div>Installing and Initializing Permit</div></li><li><div>Writing the enforcement code</div></li></ol><p>You’ll need: The latest Node.js version installed, a simple understanding of Express, and familiarity with Typescript.</p><h2>Setting up a Nest.js Project</h2><p>To start, we need to install the Nest.js CLI globally. Open your terminal or command prompt and run the following command:</p><pre><code>npm install -g @nestjs/cli</code></pre><p>This will install the Nest.js CLI, which provides useful commands for generating modules, controllers, and more. Now, let’s create a new Nest.js project for our <code>nestjs-authz-guard</code>. Navigate to the directory where you want to create your project and run the following command:</p><pre><code>nest new nestjs-authz-guard</code></pre><p>This command will create a new Nest.js project structure with all the necessary files and folders. Let’s enter this project by running:</p><pre><code>cd nestjs-authz-guard</code></pre><p>Next, we’ll start the development server and see our blog application in action. Run the following command:</p><pre><code>npm run start:dev</code></pre><p>Navigate to <a class="markup--anchor markup--p-anchor" target='_blank' title="http://localhost:3000" href="http://localhost:3000"><code>http://localhost:3000</code></a> and you should see the below screen. Congratulations, you have set up a Nest.js project!</p><img src="https://media.graphassets.com/HUwQ3ZZmS5mPzMc3dSjT" alt="nest-1.png" title="nest-1.png" width="1600" height="891" /><h2>Working with Next.js Passport library</h2><p><a rel="nofollow noopener" class="markup--anchor markup--p-anchor" target='_blank' title="https://github.com/jaredhanson/passport" href="https://github.com/jaredhanson/passport">Passport</a> is the most popular node.js authentication library, well-known by the community, and successfully used in many production applications. Integrating this library with a Nest application using the <code>@nestjs/passport</code> module is a rather straightforward process. At a high level, Passport executes a series of steps to:</p><ul><li><div>Authenticate a user by verifying their credentials (such as username/password, JSON Web Token [<a rel="nofollow noopener" class="markup--anchor markup--li-anchor" target='_blank' title="https://jwt.io/" href="https://jwt.io/">JWT</a>], or identity token from an Identity Provider)</div></li><li><div>Manage the authenticated state (by issuing a portable token, such as a JWT, or creating an <a rel="nofollow noopener" class="markup--anchor markup--li-anchor" target='_blank' title="https://github.com/expressjs/session" href="https://github.com/expressjs/session">Express session</a>)</div></li><li><div>Attach information about the authenticated user to the <code>Request</code> object for further use in route handlers</div></li></ul><p>We will install the passport to create a Decorator Guard for our Authorization logic.</p><pre><code>npm install @nestjs/passport</code></pre><h2>Writing our Nest.js Decorator Guard</h2><p>To start, let’s create another folder in our <code>/src</code> folder inside the project. We can name this folder <code>auth</code>. Next, inside, let’s create a file called <code>permissions.guard.ts</code>.</p><img src="https://media.graphassets.com/qziiuKWfSeAzBBywKGJs" alt="nest-2.png" title="nest-2.png" width="562" height="314" /><p>In the guard, we’ll house the logic to determine whether a specific user is granted permission to perform certain actions. In this tutorial, we assume the authentication aspect is already implemented, implying that user identity has been verified and a JWT (JSON Web Token) containing a unique user ID is available.</p><p>You can find a guide for implementing secure authentication with Nest.js <a rel="noopener" class="markup--anchor markup--p-anchor" target='_blank' title="https://docs.nestjs.com/security/authentication" href="https://docs.nestjs.com/security/authentication">here</a>.</p><p>Next, inside our <code>permissions.guard.ts</code> file, let’s add some logic.</p><pre><code>// auth/permissions.guard.ts

import { Injectable, CanActivate, ExecutionContext, UnauthorizedException } from &#39;@nestjs/common&#39;;
import { Observable } from &#39;rxjs&#39;;

@Injectable()
export class PermissionsGuard implements CanActivate {
  canActivate(
    context: ExecutionContext,
  ): boolean | Promise&lt;boolean&gt; | Observable&lt;boolean&gt; {
    const request = context.switchToHttp().getRequest();

    // Add the authorization logic here with Permit.io.
    // If the user has the necessary permissions, it will return true.
    // If the user does not have the necessary permissions, 
    // throw an UnauthorizedException.

    const userHasPermission = false; // &lt;- replace this line with your Permit.io logic

    if (!userHasPermission) {
      throw new UnauthorizedException(&#39;You do not have the necessary permissions.&#39;);
    }
    return true;
  }
}</code></pre><p>Currently, we are hard coding the state of the permission. We are always setting it to <code>false</code>. Let’s navigate to our <code>app.controller.ts</code> file and add another API endpoint path which we will try to protect.</p><pre><code>import { Controller, Get, UseGuards } from &#39;@nestjs/common&#39;;
import { AppService } from &#39;./app.service&#39;;
import { PermissionsGuard } from &#39;./auth/permissions.guard&#39;;


@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }

  @UseGuards(PermissionsGuard)
  @Get(&#39;protected&#39;)
  getProtectedEndpoint(): string {
    return &#39;This is a protected route, but you have access.&#39;;
  }
}</code></pre><p>Here we imported our <code>PermissionsGuard</code> and added a <code>useGuard</code> decorator. </p><p>Then we created another <code>@Get</code> request, where we passed in our endpoint name (<code>protected</code>). We wrapped it with a <code>useGuard()</code> decorator, which means that if we navigate to <a class="markup--anchor markup--p-anchor" target='_blank' title="http://localhost:3000/protected" href="http://localhost:3000/protected"><code>http://localhost:3000/protected</code></a> we should see this:</p><img src="https://media.graphassets.com/toU81WHLSKWLwARGzuaH" alt="nest-3.png" title="nest-3.png" width="1600" height="803" /><p>Now, let’s change the outcome of the Guard logic to return <code>true</code>.</p><pre><code>const userHasPermission = true;</code></pre><p>Now we should have access to the <code>protected</code> route.</p><img src="https://media.graphassets.com/UN6QbKs0QW2w2oFPz2oc" alt="nest-4.png" title="nest-4.png" width="1242" height="710" /><p>Hurray! We did it. Now it’s time to add Permit’s authorization logic.</p><h2>Setting up our first policy with Permit </h2><p>First, go ahead and create an account at <a rel="noopener" class="markup--anchor markup--p-anchor" target='_blank' title="https://app.permit.io/" href="https://app.permit.io/">https://app.permit.io</a>. You will be presented with an onboarding, but once you enter your organization name, you can just <strong>skip</strong> the setup (As we will be going through the same steps here, with a more detailed explanation). </p><p>Once in the dashboard, navigate to the policy screen to the role manager. You will be prompted yo manage your first new role:</p><img src="https://media.graphassets.com/4qwrdNgTRhyk1TB2iI2Q" alt="nest-5.png" title="nest-5.png" width="1600" height="855" /><p>Let’s create our first role. Each role will have specific rules associated with it, of what a user can and cannot do. The role we will create is an <code>Admin</code> role. The <code>/protected</code> page will only be accessible to users with the <code>Admin</code> role. </p><p>To learn more about building RBAC (Role-based Access Control) policies — check out our guide <a rel="noopener" class="markup--anchor markup--p-anchor" target='_blank' title="https://docs.permit.io/features/policy-editor/rbac/overview" href="https://docs.permit.io/features/policy-editor/rbac/overview">here</a>.</p><img src="https://media.graphassets.com/X7fUunETwiOAp8dn7MDl" alt="nest-6.png" title="nest-6.png" width="1232" height="954" /><img src="https://media.graphassets.com/vhuMKp2kQlSFSWXv3Do0" alt="nest-7.png" title="nest-7.png" width="1600" height="324" /><p>Success!</p><p>Now let’s navigate to the Users panel — we’ll add a sample user and assign them with the <code>Admin</code> role. </p><p>In general, this would be the user and their unique ID that you would get from the JWT (JSON Web Token) upon successful authentication, but for this demo, we will just fake that process and pretend it has already happened.</p><p>If you need suggestions on the best Authentication Providers to work with, <a rel="noopener" class="markup--anchor markup--p-anchor" target='_blank' title="https://io.permit.io/permitslack" href="https://io.permit.io/permitslack"><strong>message us on</strong> <strong>Slack</strong></a>, and we will be more than happy to suggest some.</p><p>You can also check out a guide on adding a user to Permit after successful authentication with <a rel="noopener" class="markup--anchor markup--p-anchor" target='_blank' title="https://auth0.com/" href="https://auth0.com/">Auth0</a> <a rel="noopener" class="markup--anchor markup--p-anchor" target='_blank' title="https://www.permit.io/blog/add-rbac-authorization-to-auth0" href="https://www.permit.io/blog/add-rbac-authorization-to-auth0">here</a>.</p><img src="https://media.graphassets.com/3T9h0DfFSQWLRQNIjzXO" alt="nest-8.png" title="nest-8.png" width="1600" height="1186" /><p>You can name the user however you’d like.</p><p>Next, we’ll navigate to the Policy panel and create our first policy. First, we need to manage and create our first <code>resource</code>. You will be prompted to do so on the screen. </p><p>Let’s call our resource <code>protected-page</code> (because that’s what the user will be trying to gain access to). As for the actions that a user will be able to perform on this resource, we only specified <code>view</code>. If you have more actions a user could perform, you can add them as needed. </p><img src="https://media.graphassets.com/w2ApUBETtSk56prQJ85M" alt="nest-9.png" title="nest-9.png" width="1600" height="1070" /><img src="https://media.graphassets.com/PyeEu937RBqPepkD0aN5" alt="nest-10.png" title="nest-10.png" width="1600" height="360" /><p>If we now look at the policy editor, we will see a grid-like view where the <code>Admin</code> role contains a <code>protected-page</code> resource, which contains the <code>view</code> action that we can check for. </p><img src="https://media.graphassets.com/qNudyFIMRMy9cgWSJKPt" alt="nest-11.png" title="nest-11.png" width="1008" height="564" /><p>Let’s quickly add another role — we’ll all it <code>Manager</code>.</p><img src="https://media.graphassets.com/CxmPFluXQz0ztQlaiGDg" alt="nest-12.png" title="nest-12.png" width="750" height="654" /><p></p><img src="https://media.graphassets.com/d0mlfxR7TlmyVphgpYfl" alt="nest-13.png" title="nest-13.png" width="1600" height="1132" /><p>As we create another role, it automatically contains the previously defined resources and actions. As you can see, managing permissions and adding on top of them is extremely simple and fast. </p><img src="https://media.graphassets.com/Cgmp0BKRNK5Oa0eu9N0X" alt="nest-14.png" title="nest-14.png" width="1542" height="928" /><p>Finally, and most importantly, let’s check the permission to view the page for the Admin role. </p><img src="https://media.graphassets.com/1O0KUEtRtmzWzhGTo4Sg" alt="nest-15.png" title="nest-15.png" width="582" height="366" /><p>Our RBAC policy is now configured. Time to write some simple code to get this to work!</p><h2>Installing and Initializing Permit</h2><p>First, let’s install the npm package.</p><pre><code>npm install permitio</code></pre><p>Now, let’s import the package and add the Permit instance inside our Guard. </p><pre><code>// auth/permissions.guard.ts

import { Injectable, CanActivate, ExecutionContext, UnauthorizedException } from &#39;@nestjs/common&#39;;
import { Observable } from &#39;rxjs&#39;;
// Permit package import
import { Permit } from &#39;permitio&#39;;

// This line initializes the SDK and connects your app
//to the Permit.io Cloud PDP.
const permit = new Permit({
    pdp: &quot;https://cloudpdp.api.permit.io&quot;,
    // your API Key
    token: &quot;[YOUR_API_KEY]&quot;,
});</code></pre><p>Make sure to replace the API key with your unique API Key obtained from the Permit dashboard. To do so, click on your name in the dashboard and directly copy the API key from there.</p><img src="https://media.graphassets.com/BOZKxNbARUKYrNsRenmF" alt="nest-16.png" title="nest-16.png" width="1352" height="806" /><h2>Writing the enforcement code</h2><p>It’s now time to add the <code>permit.check()</code> function to our guard! Here is what the code will look like:</p><pre><code>// auth/permissions.guard.ts

import { Injectable, CanActivate, ExecutionContext, UnauthorizedException } from &#39;@nestjs/common&#39;;
import { Observable } from &#39;rxjs&#39;;
import { Permit } from &#39;permitio&#39;;

// This line initializes the SDK and connects your app
// to the Permit.io Cloud PDP.

const permit = new Permit({
    pdp: &quot;https://cloudpdp.api.permit.io&quot;,
    // your API Key
    token: &quot;[YOUR_API_KEY]&quot;,
});

@Injectable()
export class PermissionsGuard implements CanActivate {
  async canActivate(
    context: ExecutionContext,
  ): Promise&lt;boolean&gt; {
    const request = context.switchToHttp().getRequest();

    // Add the authorization logic here with Permit.io.
    // If the user has the necessary permissions, return true.
    // If the user does not have the necessary permissions, throw an UnauthorizedException.

    const userHasPermission = await permit.check(&quot;demo_user@gmail.com&quot;, &quot;view&quot;, &quot;protected-page&quot;);

    console.log(userHasPermission);

    if (!userHasPermission) {
      throw new UnauthorizedException(&#39;You do not have the necessary permissions.&#39;);
    }
    return true;
  }
}</code></pre><p>Notice that we changed the <code>canActivate</code> function to be <code>async</code>, so that we can <code>await</code> for the <code>permit.check()</code> to return the <code>Promise</code>.</p><p>Inside the <code>permit.check()</code> function, we pass three parameters. The unique <code>key/id</code> of the user, which in this case is the email, the <code>action</code> we are performing, and the <code>resource</code> we are performing that action on. Permit will check this against the policy we have defined and return a <code>boolean</code> based on the outcome of the permission check.</p><p>Because we assigned the <code>Admin</code> role to our user, we should have the permissions to access the page — let’s call the <code>/protected</code> route and see.</p><img src="https://media.graphassets.com/Qo2SoGNQYSm57DxH6wiw" alt="nest-17.png" title="nest-17.png" width="1254" height="514" /><p>Indeed, we do have access. Let’s now change the role for our user to <code>Manager</code> and see if we suddenly lose access.</p><img src="https://media.graphassets.com/bQm0XhdTRdGwwiNSjhxL" alt="nest-18.png" title="nest-18.png" width="1600" height="434" /><p></p><img src="https://media.graphassets.com/L81cjHUSHG5b0QAyvd2D" alt="nest-19.png" title="nest-19.png" width="1136" height="998" /><p></p><img src="https://media.graphassets.com/NcRkHkk9TMigxg2N3ui1" alt="nest-20.png" title="nest-20.png" width="1600" height="158" /><p>Alright, our user is now a manager, so let’s navigate to the endpoint path and see.</p><img src="https://media.graphassets.com/EDoy6gXQeGY1ArnXxyxw" alt="nest-21.png" title="nest-21.png" width="1600" height="413" /><p>Woops! It looks like the access has been taken away from us. That’s it! It’s as simple as that :)</p><p>Next time you need to protect an API endpoint in Nest.js, it will be a breeze. Learn more about <a rel="noopener" class="markup--anchor markup--p-anchor" target='_blank' title="https://permit.io" href="https://permit.io">Permit</a> — or access the whole code repository for this project <a rel="noopener" class="markup--anchor markup--p-anchor" target='_blank' title="https://github.com/filipermit/demo-projects/tree/main/nestjs-api-endpoint-guard" href="https://github.com/filipermit/demo-projects/tree/main/nestjs-api-endpoint-guard">here</a>. </p>]]></content>
        <author>
            <name>Filip Grebowski</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Location-Based Access Control Made Easy with Next.js and IPinfo]]></title>
        <id>location-based-access-control-made-easy-with-nextjs-and-ipinfo</id>
        <link href="https://www.permit.io/blog/location-based-access-control-made-easy-with-nextjs-and-ipinfo"/>
        <updated>2023-06-28T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Easily add location-based access control to your application using IPinfo and Permit.io. Grant user access based on geolocation with this comprehensive guide.]]></summary>
        <content type="html"><![CDATA[<p>In web applications, controlling access based on various factors is often necessary. One common requirement is <strong>restricting access to certain content or features based on a user’s IP address</strong>. This can be achieved using <a rel="noopener" class="markup--anchor markup--p-anchor" target='_blank' title="http://permit.io" href="http://permit.io">Permit.io</a>’s low-code/no-code Authorization tool in conjunction with the <a rel="noopener" class="markup--anchor markup--p-anchor" target='_blank' title="https://ipinfo.io/" href="https://ipinfo.io/">IPinfo</a> service. This article will explore how to implement IP-based access control in a Next.js application.</p><p>The overarching concept behind this demo will be controlling access to a specific subdomain. Our primary objective is to <strong>restrict access to the subdomain solely to users within our designated location</strong>. Users outside a defined location will be <strong>automatically redirected to the main page</strong> if they attempt to access the subdomain.</p><h2>The tools we will be using</h2><p><a rel="noopener" class="markup--anchor markup--p-anchor" target='_blank' title="https://ipinfo.io/" href="https://ipinfo.io/">IPinfo</a> is a popular IP address data provider with over 10 contextualized datasets derived from IP addresses. It provides information such as the country, city, anonymous IPs, and the organization associated with an IP. IPinfo’s API can be accessed via various programming languages, including JavaScript, with their Node.js library.</p><p><a rel="noopener" class="markup--anchor markup--p-anchor" target='_blank' title="https://permit.io/" href="https://permit.io/">Permit.io</a> is a flexible access control developer tool designed to simplify implementing various access control mechanisms in web applications. It allows you to define access rules based on roles or permissions and provides a simple <code>permit.check()</code>function to enforce them. With Permit, you can easily integrate access control into your Next.js applications.</p><p>In the following sections, we will guide you through setting up a Next.js project and implementing IP-based access control using Permit and IPinfo.</p><p><strong>Prerequisites</strong>: This guide requires basic knowledge of Next.js and JavaScript.</p><p><strong>Important: </strong>This demo app will focus purely on the functionality and not the UI we will see.</p><h2>Let’s create a basic starter App in Next.js!</h2><p>As a Developer Advocate at <a rel="noopener" class="markup--anchor markup--p-anchor" target='_blank' title="https://io.permit.io/supertokens-passwordless-blog" href="https://io.permit.io/supertokens-passwordless-blog">Permit.io</a>, I have found that the most effective way to guide developers through the intricate realm of Authentication and Authorization is by demonstrating them through code and practical examples. Let’s dive into that.</p><p>To get started, you’ll need to have Node.js installed on your computer. <br>Then, follow these steps:</p><ol><li><div>Install the NextJS boilerplate, name your project, and select the setting that suits your development best. I always build my projects with the <code>/src</code> folder enabled and  <code>lintr</code> installed. </div></li></ol><pre><code>npx create-next-app@latest</code></pre><p>2. Navigate to the newly created directory.</p><pre><code>cd YOUR_PROJECT_NAME</code></pre><p>3. Run the development server.</p><pre><code>npm run dev</code></pre><p>Now you should see your Next.js application running on <code>http://localhost:3000</code>. Congratulations!</p><img src="https://media.graphassets.com/i3EVgiJYRzuiXMyQJAE4" alt="supertokens-1.png" title="supertokens-1.png" width="3248" height="2004" /><p></p><h2>Creating a new page in Next.js</h2><p>Once you have your repository open, we need to create a new folder under <code>/src</code> called <code>/pages</code>. Inside this folder, we can add paths on top of our URL that will display the relevant pages. Let’s create a file called <code>/only-uk</code>.</p><p>Inside the file, paste this simple code and see it in action.</p><pre><code>import React from &quot;react&quot;;

export default function UnitedKingdomOnly() {
 return (
  &lt;h1&gt;If you are currently in the UK you will be able to see this page.&lt;/h1&gt;
 );
}</code></pre><p>It works :)</p><img src="https://media.graphassets.com/OnGyGenSOuTGQRb5culb" alt="ip-info-1.png" title="ip-info-1.png" width="840" height="148" /><h2>Setting up Permit and our first policy</h2><p>We will need to create an ABAC policy within Permit. ABAC (<a rel="noopener" class="markup--anchor markup--p-anchor" target='_blank' title="https://www.permit.io/blog/what-is-abac" href="https://www.permit.io/blog/what-is-abac">Attribute-based access control</a>) is an authorization model that evaluates attributes (or characteristics), alongside roles, resources, and actions to determine access. The purpose of ABAC is to allow users to define more complex access-control rules to prevent other users from unauthorized actions — those that don’t have “approved” characteristics as defined by an organization’s security policies.</p><p>For this demo, we can create three roles, a simple <code>Admin</code> role, an <code>Admin from the UK</code> and an <code>Admin from Poland</code>. As you can see, the two latter roles have IP location-based attributes.</p><p>First, go ahead a create an account at <a rel="noopener" class="markup--anchor markup--p-anchor" target='_blank' title="https://app.permit.io/" href="https://app.permit.io/">https://app.permit.io</a>. You will be presented with the onboarding, but once you enter your organization name, you can just <strong>skip</strong> the setup.</p><p>Once in the dashboard, navigate to the policy screen and manage our roles.</p><img src="https://media.graphassets.com/A0Ap1yPmRxqowufcvkgQ" alt="supertokens-9.png" title="supertokens-9.png" width="3018" height="1580" /><p>It’s time to create our first role. Each role will have specific rules associated with it, of what a user can and cannot do. We must create the <code>Admin</code> role first, as it will later serve as a building block for our ABAC conditions.</p><p>If you want to learn more about building an ABAC condition — check out our guide <a rel="noopener" class="markup--anchor markup--p-anchor" target='_blank' title="https://docs.permit.io/features/policy-editor/abac/overview" href="https://docs.permit.io/features/policy-editor/abac/overview">here</a>.</p><img src="https://media.graphassets.com/9jUYKbubTyKvEVTNSFT6" alt="ip-info-2.png" title="ip-info-2.png" width="1232" height="954" /><p></p><img src="https://media.graphassets.com/4yAozS3TbSBAQpR3Lm0h" alt="ip-info-3.png" title="ip-info-3.png" width="1600" height="324" /><p>Success!</p><p>Next, we need to create the two other roles with attributes (or otherwise known in Permit as <code>User Sets.</code></p><p><code>User Sets</code> are <em>groups of users</em> that adhere to <em>pre-defined attribute-based conditions</em>. These are conditions based on individual user characteristics.</p><p>However, before we jump into creating the User Sets, we need to define the attributes that will also be used for building our conditions. In this case, the attribute we will need to add will be <code>ip_location</code>. </p><p><code>Attributes</code> are values that serve as a declaration of what the condition rule will be. </p><p>Now — ABAC is not enabled by default within Permit, so we need to switch the toggle. In the policy screen, at the top, you will see a tab called <code>ABAC Rules</code>. Click on it and toggle ABAC on.</p><img src="https://media.graphassets.com/fVPtBVe0SRuDX1QrXo9c" alt="ip-info-4.png" title="ip-info-4.png" width="1168" height="354" /><p>Now as we navigate to the Users panel in Permit, a new tab will appear called <code>Attributes</code>. Click on it, and add a new user attribute called <code>ip_location</code> with the type of <code>String</code>. We need to define the type — this is a declaration of the value we will compare the attribute to. </p><img src="https://media.graphassets.com/vjAODwSHCLgJ0nOQkfgf" alt="ip-info-5.png" title="ip-info-5.png" width="undefined" height="undefined" /><p>While we are in the Users panel — let’s add a sample user. In general, this would be the user and their unique ID that you would get from the JWT (JSON Web Token) upon successful authentication, but for this demo we will just fake that process and pretend it has already happened. </p><p>If you need suggestions on the best Authentication Providers to work with, just <a rel="noopener" class="markup--anchor markup--p-anchor" target='_blank' title="https://io.permit.io/permitslack" href="https://io.permit.io/permitslack"><strong>message us on</strong> <strong>Slack</strong></a>, and we will be more than happy to suggest some. </p><p>If you would like to check out a guide on how to add a user to Permit after successful authentication with <a rel="noopener" class="markup--anchor markup--p-anchor" target='_blank' title="https://auth0.com/" href="https://auth0.com/">Auth0</a>, check out the article <a rel="noopener" class="markup--anchor markup--p-anchor" target='_blank' title="https://www.permit.io/blog/add-rbac-authorization-to-auth0" href="https://www.permit.io/blog/add-rbac-authorization-to-auth0">here</a>.</p><img src="https://media.graphassets.com/eB6f4HEyQUOuzlXnkWg1" alt="ip-info-6.png" title="ip-info-6.png" width="1600" height="1186" /><p>You can name the user however you’d like.</p><p>Now that we have the attribute and user set up, we can continue creating the two other roles (with conditions) — which means we will be creating <code>User Sets</code>.</p><p>Navigate to the User panel and into the <code>ABAC Rules</code> tab. Here, let’s create a new User Set. </p><img src="https://media.graphassets.com/e6OqiEobQYieAioFg9Zb" alt="uk-admin.png" title="uk-admin.png" width="1096" height="1366" /><p>Our <code>UK Admin</code> role needs extra conditions, so let’s create a condition group. We stated that the <code>ip_location</code> is equal to the country code <code>UK</code>.</p><img src="https://media.graphassets.com/NUNUHwI1TxiXMxjRTeV5" alt="ip-info-7.png" title="ip-info-7.png" width="1282" height="560" /><p>Now you can do the same for the <code>Polish Admin</code> role.</p><img src="https://media.graphassets.com/oVIGT6m0QtGtoQIA1LUx" alt="poland-admin.png" title="poland-admin.png" width="1098" height="1368" /><p>Well done! You should now see two User Sets.</p><img src="https://media.graphassets.com/ZotpapOsRkqZFwe9fxq2" alt="ip-info-8.png" title="ip-info-8.png" width="1600" height="340" /><p>Great work so far. The last part that we need to create in the no-code dashboard is a <code>resource</code> and the <code>actions</code> we want to allow the roles to perform on the resource. The resource will be our restricted page called <code>only-uk</code> , and the action will be <code>view</code>. You can have as many actions as you want, but in order to keep this demo very simple, we will just create one.</p><p>In order to create a resource, navigate to the policy panel and click on the <code>Resources</code> tab and <code>create a resource</code>. </p><p>A resource is the target object we want to authorize access to. It’s what the user will or won’t be able to perform actions on. </p><img src="https://media.graphassets.com/DvpCt5hnQxSDrtHdLu1w" alt="ip-info-9.png" title="ip-info-9.png" width="1232" height="1302" /><p>Once the resource is created and as we navigate to the main Policy Editor, you should see something like this:</p><img src="https://media.graphassets.com/uBHSuQuzT4SeyWPb5531" alt="abac-policy-undelected.png" title="abac-policy-undelected.png" width="1058" height="1394" /><p>Our policy is finished. Now, let’s enforce it in the UI. The only role that should be able to view the restricted page is <code>UK Admin</code>. Let’s tick the <code>view</code> box. </p><img src="https://media.graphassets.com/vCyYCWA1QF2H1LGiU6FA" alt="abac-selected.png" title="abac-selected.png" width="1008" height="1384" /><p>Voila! Our Permit Policy configuration is finished!</p><h2>Installing dependencies</h2><p>Next, install the necessary dependencies by running the following command:</p><pre><code>npm install permitio ipinfo swr --save</code></pre><h2>Initializing the Permit instance and running the PDP</h2><p>When writing the code, we will need to consider two things:</p><ol><li><div>Creating an API endpoint that will handle the authorization and IP fetching.</div></li><li><div>Adjust the restricted page to show a message based on the result of the enforcement. </div></li></ol><p>Inside of our <code>/pages</code> folder, let’s create another folder called <code>/api</code> , and inside that folder, we need to create a file — let’s call it <code>restrict.js</code>. This will become the URL endpoint that we call from our frontend, and it will appear under the endpoint path <code>/api/restrict</code>.</p><p>Inside the restrict folder, we need to import Permit and initialize the instance. </p><pre><code>import { Permit } from &quot;permitio&quot;;

const permit = new Permit({
 pdp: &quot;http://localhost:7766&quot;,
 // your API Key
 token: process.env.PERMIT_API_KEY,
});</code></pre><p>To be able to use ABAC within Permit, we have to deploy the PDP (Policy-Decision-Point).</p><p>Just run these two commands in your terminal to download the container and run it:</p><pre><code>$ docker pull permitio/pdp-v2:latest
$ docker run -p 7766:7000 --env PDP_API_KEY=&lt;YOUR_API_KEY&gt; permitio/pdp-v2:latest</code></pre><p>Make sure to replace the API Key inside the Permit instance and the docker run command. You can find your PermitAPI Key by clicking on your profile image and copying the key.</p><img src="https://media.graphassets.com/YDDGQ9CZRPqx7hXyr97w" alt="supertokens-8.png" title="supertokens-8.png" width="1352" height="806" /><h2>Coding the Permit ABAC enforcement check</h2><p>In order to restrict access, we need to include the <code>permit.check()</code> function in our code to check a specific user against our configured policy. </p><p>Let’s add the below code to our <code>restrict.js</code> file.</p><pre><code>import { Permit } from &quot;permitio&quot;;

const permit = new Permit({
 pdp: &quot;http://localhost:7766&quot;,
 // your API Key
 token: process.env.PERMIT_API_KEY,
});

#################### ADD CODE BELOW ###################

export default async function enforceAccess(req, res) {

 const allowed = await permit.check(
  {
   key: &quot;demo_user@gmail.com&quot;,
   attributes: {
    ip_location: SOME_LOCATION,
   },
  },
  &quot;view&quot;,
  {
   type: &quot;only-uk&quot;,
   tenant: &quot;default&quot;,
  }
 );

 res.status(200).send({ allowed });

 return allowed;
}</code></pre><p>Inside the <code>permit.check()</code> function, we pass three parameters: the <code>user object with attributes</code> that we are checking for, the <code>action</code> being performed and then <code>resource object</code>, passing in the <code>resource name</code> and the <code>tenant</code>.</p><p>A <code>tenant</code> is as a silo of resources and users; which in policy terms means only users within a tenant can act on the resources within the tenant. Tenants are isolated from one another.</p><p>Now if we look at the code, as part of the passed-in attributes, we are missing the IP location — which we are currently not handling at all. Not to worry, we have IPinfo to help us!</p><h2>Creating an account with IPinfo</h2><p>To utilize the IPinfo service, you must sign up for an account and acquire an Access Token. IPinfo offers 50,000 free geolocation requests every month. Visit the<a rel="noopener" class="markup--anchor markup--p-anchor" target='_blank' title="https://ipinfo.io/" href="https://ipinfo.io/"> IPinfo page</a>, sign up for a free account, and enter the dashboard:</p><img src="https://media.graphassets.com/1BbxH7Q5yMvwG9g2kW2g" alt="Screenshot 2023-06-13 at 15.01.37.png" title="Screenshot 2023-06-13 at 15.01.37.png" width="3016" height="1612" /><p>In general, IPinfo is very simple to set up, and you can start using it within minutes. If you check out their developer <a rel="noopener" class="markup--anchor markup--p-anchor" target='_blank' title="https://ipinfo.io/developers" href="https://ipinfo.io/developers">documentation</a>, they give you many ways to run a simple request to fetch the user country and IP.</p><p>We will be using the <code>async/await</code> Fetch API to get the user country code.</p><p>As we are dealing with an access token here, it’s always best practice to store these tokens in an <code>.env</code> file to ensure you don’t accidentally share sensitive information.</p><img src="https://media.graphassets.com/j7RKUjhmTfWBvaFPn7xe" alt="ip.png" title="ip.png" width="1642" height="532" /><p>I have an <code>.env.local</code> file setup with the below configuration:</p><pre><code>PERMIT_API_KEY=
IP_INFO_TOKEN=</code></pre><h2>Fetching a users IP address and Country Code</h2><p>Now let’s add a function into the <code>/restrict.js</code>file to fetch the IP of the current user trying to access the restricted /<code>only-uk</code> page.</p><pre><code>const fetchLocationByIP = async () =&gt; {
 const request = await fetch(
  `https://ipinfo.io/json?token=${process.env.IP_INFO_TOKEN}`
 );
 const jsonResponse = await request.json();

 console.log(jsonResponse.ip, jsonResponse.country);

 return jsonResponse.country;
};</code></pre><p>The above code will fetch the user details, extract the IP and country, and return the two-letter country code.</p><p>Now we need to pass the returned country code to the<code>ip_location</code> attribute. The whole code should look something like the example below.</p><h2>Making it all work together</h2><pre><code>import { Permit } from &quot;permitio&quot;;

const permit = new Permit({
 pdp: &quot;http://localhost:7766&quot;,
 // your API Key
 token: process.env.PERMIT_API_KEY,
});

const fetchLocationByIP = async () =&gt; {
 const request = await fetch(
  `https://ipinfo.io/json?token=${process.env.IP_INFO_TOKEN}`
 );
 const jsonResponse = await request.json();

 console.log(jsonResponse.ip, jsonResponse.country);

 return jsonResponse.country;
};

export default async function enforceAccess(req, res) {

 // Getting the country code and storing in a variable
 const IPlocation = await fetchLocationByIP();

 const allowed = await permit.check(
  {
   key: &quot;demo_user@gmail.com&quot;,
   attributes: {
    // Passing the variable to the ip_location attribute
    ip_location: IPlocation,
   },
  },
  &quot;view&quot;,
  {
   type: &quot;only-uk&quot;,
   tenant: &quot;default&quot;,
  }
 );

 res.status(200).send({ allowed });

 return allowed;
}</code></pre><p>Great! Now, as a final step, let’s edit the<code>/only-uk</code> page to handle the response correctly and display the appropriate message.</p><pre><code>import React from &quot;react&quot;;
import useSWR from &quot;swr&quot;;

export default function UnitedKingdomOnly() {
 const fetcher = (url) =&gt; fetch(url).then((res) =&gt; res.json());
 const { data, error } = useSWR(&quot;/api/restrict&quot;, fetcher);

 if (error) return &lt;div&gt;Failed to load.&lt;/div&gt;;
 if (!data) {
  return &lt;div&gt;Loading...&lt;/div&gt;;
 } else {
  if (data.allowed) {
   return (
    &lt;div&gt;
     If you are currently in the UK you will be able to see this page.
    &lt;/div&gt;
   );
  } else {
   return &lt;div&gt;User is not based in the UK.&lt;/div&gt;;
  }
 }
}</code></pre><p>As I am currently in the UK myself, so if I try to access the page, I will get the below message:</p><img src="https://media.graphassets.com/OnGyGenSOuTGQRb5culb" alt="ip-info-1.png" title="ip-info-1.png" width="840" height="148" /><p>However, now I will change my location to Poland using a VPN, and as I refresh the page and try to reaccess the page, we will see this:</p><img src="https://media.graphassets.com/ncBEjm8eQbaxgiIO25pq" alt="Screenshot 2023-06-13 at 14.53.33.png" title="Screenshot 2023-06-13 at 14.53.33.png" width="622" height="156" /><p>Hurray! Our application now uses both IPinfo to fetch the user&#39;s current location, and Permit to enforce the access based on the location.</p><p>Learn more about <a rel="noopener" class="markup--anchor markup--p-anchor" target='_blank' title="https://permit.io" href="https://permit.io">Permit</a> or <a rel="noopener" class="markup--anchor markup--p-anchor" target='_blank' title="https://ipinfo.io" href="https://ipinfo.io">IPinfo</a> — or access the whole code repository for this project <a rel="noopener" class="markup--anchor markup--p-anchor" target='_blank' title="https://github.com/filipermit/demo-projects/tree/main/ip-based-access-control" href="https://github.com/filipermit/demo-projects/tree/main/ip-based-access-control">here</a>.</p>]]></content>
        <author>
            <name>Filip Grebowski</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Authorization still tops OWASP top 10 API Security risks for 2023]]></title>
        <id>owasp-2023</id>
        <link href="https://www.permit.io/blog/owasp-2023"/>
        <updated>2023-06-20T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[The latest OWASP "Top 10 API Security Risks" report once again lists "Broken Object Level Authorization" as its top 1 vulnerability. What can be done about it?]]></summary>
        <content type="html"><![CDATA[<h2>Introduction</h2><p>API security is a critical concern for every developer in today&#39;s digital landscape. The <a title="https://owasp.org/" href="https://owasp.org/"><u>Open Worldwide Application Security Project (OWASP)</u></a> plays a vital role in highlighting the most significant security risks associated with APIs. The latest <a title="https://owasp.org/API-Security/editions/2023/en/0x11-t10/" href="https://owasp.org/API-Security/editions/2023/en/0x11-t10/"><u><strong>2023 OWASP Top 10 API Security Risks Report</strong></u></a> offers valuable insights into the evolving threat landscape. Among the various risks identified, one item stands out as the most crucial: <strong>broken access control</strong>, and, specifically, <strong>authorization</strong>. In this blog post, we will delve into the latest OWASP report, focusing on the importance of authorization, and what best practices you should implement to avoid potential security risks. <br></p><h2>Broken-Access-Control Remains the Number 1 Concern </h2><p>The OWASP Top 10 API Security risks for 2023 provide a comprehensive understanding of the most critical vulnerabilities that organizations face. These risks evolve over time, and it is crucial for businesses to stay up to date with the latest security concerns. As in the previous lists (<a title="https://owasp.org/API-Security/editions/2019/en/0x11-t10/" href="https://owasp.org/API-Security/editions/2019/en/0x11-t10/"><u>OWASP 2019</u></a> Top 10 API Security Risks, and  <a title="https://owasp.org/Top10/A01_2021-Broken_Access_Control/" href="https://owasp.org/Top10/A01_2021-Broken_Access_Control/"><u>OWASP 2021</u></a> Top 10 Web Application Security Risks), the top two items remain broken access-control-related risks: <strong>Broken Object Level Authorization, and Broken Authentication</strong>.</p><p>These items are described in the OWASP Top 10 API Security risks for 2023 in the following way: </p><table><tbody><tr><td><p>API1:2023 - Broken Object Level Authorization</p></td><td><p>APIs tend to expose endpoints that handle object identifiers, creating a wide attack surface of Object Level Access Control issues. Object level authorization checks should be considered in every function that accesses a data source using an ID from the user.</p></td></tr><tr><td><p>API2:2023 - Broken Authentication</p></td><td><p>Authentication mechanisms are often implemented incorrectly, allowing attackers to compromise authentication tokens or to exploit implementation flaws to assume other user&#39;s identities temporarily or permanently. Compromising a system&#39;s ability to identify the client/user, compromises API security overall.</p></td></tr></tbody></table><p>Despite ongoing efforts to improve API security, broken access control continues to be a significant concern. Its consistent position at the top of the OWASP Security risk list underscores its relevance and the urgent need for organizations to address this vulnerability effectively. The OWASP community is not the only one concerned about this issue - the <a title="https://www.permit.io/blog/nsa" href="https://www.permit.io/blog/nsa"><u><strong>NSA </strong></u><u>“Advancing Zero Trust Maturity Throughout the User Pillar” cybersecurity information sheet </u></a>discusses similar issues - mainly the importance of implementing proper access control.<br></p><h2>What can you do about it?</h2><p>Developing secure systems is a challenge for every developer. To truly excel in this field, it is essential to learn from the identified threats, adapt to them, and continuously enhance our knowledge and skills. By following best practices for secure access control, and only using the right tools and OSS which utilize them, developers can ensure that the systems they build are robust, resilient, and reliable.<br></p><h2>Best Practices for Avoiding Broken Access Control</h2><p>To mitigate the risks associated with broken access control, we must adopt best practices and implement robust access control measures. Here are some key practices to consider:</p><p><strong>Mapping Your Authorization Layer in Advance:</strong> <br>Take the time to plan user roles and authorizations in advance. Understand your application-level roles and identify the actions each role should be able to perform on specific resources. This helps establish a solid authorization layer and ensures that access to data is granted only to those who need it. Don’t know where to start? <a title="https://www.permit.io/blog/planning-app-rbac" href="https://www.permit.io/blog/planning-app-rbac"><u>Check out this guide</u></a>.</p><p><strong>Choose an Authorization Model that fits your needs:</strong> <br>Choosing the appropriate authorization model is crucial for effectively managing permissions in your application. The two primary models to consider are <a title="https://www.permit.io/blog/rbac-with-permit" href="https://www.permit.io/blog/rbac-with-permit"><u>Role-Based Access Control (RBAC)</u></a> and<a title="https://www.permit.io/blog/what-is-abac" href="https://www.permit.io/blog/what-is-abac"><u> Attribute-Based Access Control (ABAC)</u></a>. RBAC provides a straightforward solution for determining authorization based on predefined roles, while ABAC offers a more comprehensive approach by incorporating attributes into the decision-making process. By selecting the appropriate authorization model and leveraging the right tools, you can establish a robust and flexible access control framework that aligns with your organization&#39;s needs. Remember that access control is not a one-size-fits-all approach, and it requires continuous evaluation and adaptation as your application and security requirements evolve. To make the right choice, learn more about <a title="https://www.permit.io/blog/rbac-vs-abac" href="https://www.permit.io/blog/rbac-vs-abac"><u>RBAC VS ABAC</u></a>. </p><p><strong>Build a flexible authorization system:</strong> <br>Implementing and maintaining authorization can in itself be quite challenging. Creating a structure that allows you to switch from one model to another or use them together is even more complicated. The best solution is to use an <a title="https://www.permit.io/blog/choose-an-authz-service" href="https://www.permit.io/blog/choose-an-authz-service"><u>authorization solution</u></a> that allows for this flexibility. </p><p><strong>Don’t mix application code with authorization logic:</strong><br>Coupling the code of the authorization layer into the application code is a bad idea <a title="https://www.permit.io/blog/four-mistakes-you-make-when-building-permissions#2-mixing-up-app-logic-and-authorization" href="https://www.permit.io/blog/four-mistakes-you-make-when-building-permissions#2-mixing-up-app-logic-and-authorization"><u>for several reasons</u></a>. Each upgrade or added capability would require us to refactor large areas of code that only drift further from one another. </p><p>There are several solutions that allow you to both create a separate microservice for authorization and decouple policy and code, such as <a title="https://www.permit.io/blog/introduction-to-opa" href="https://www.permit.io/blog/introduction-to-opa"><u>Open Policy Agent (OPA)</u></a> and <a title="https://www.permit.io/blog/cedar-rbac" href="https://www.permit.io/blog/cedar-rbac"><u>AWS’ Cedar</u></a> + <a title="https://github.com/permitio/cedar-agent" href="https://github.com/permitio/cedar-agent"><u>Cedar Agent</u></a>. Which you can use to manage authorization in a separate service.</p><p><strong>Utilize event-driven authorization:</strong><br>In addition to granular access rules, keeping your authorization layer up to date in real-time is a must for every modern application. <a title="https://www.permit.io/blog/introduction-to-opal" href="https://www.permit.io/blog/introduction-to-opal"><u>OPAL (Open Policy Administration Layer)</u></a>, for example, is an open-source project that makes policy engines like OPA and Cedar event-driven. This allows you to respond to policy and data changes instantly as they happen, push live updates to your agents, and bring open policy up to the speed needed by live applications.<br></p><h2>Keep evolving!</h2><p>Authorization, particularly broken access control, remains a top concern in API security. The 2023 OWASP Top 10 API Security Risks report emphasizes the importance of addressing this vulnerability effectively. By following best practices such as <strong>mapping your authorization layer</strong>, <strong>choosing the right authorization model</strong>, <strong>building a flexible authorization system</strong>,<strong> separating application code from authorization logic</strong>, and<strong> utilizing event-driven authorization, </strong>you can significantly enhance your API security. </p><p>Authorization is a critical aspect of securing your APIs. By implementing the recommended best practices, you can build a robust access control layer that ensures only authorized users can access sensitive resources and <a title="https://www.permit.io/blog/four-mistakes-you-make-when-building-permissions" href="https://www.permit.io/blog/four-mistakes-you-make-when-building-permissions"><u>avoid major access control pitfalls</u></a>. Stay proactive, stay secure!</p><p>Want to learn more about Authorization and access control? Join our <a title="https://io.permit.io/permitslack" href="https://io.permit.io/permitslack"><u>Slack Community</u></a>, where world-class authorization specialists and hundreds of devs are discussing, building, and implementing authorization together.</p>]]></content>
        <author>
            <name>Daniel Bass</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Implementing Role-Based Access Control (RBAC) with AWS’ Cedar]]></title>
        <id>cedar-rbac</id>
        <link href="https://www.permit.io/blog/cedar-rbac"/>
        <updated>2023-06-13T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[How (and why) should you implement RBAC with AWS' new Cedar policy engine]]></summary>
        <content type="html"><![CDATA[<p>Building authorization for your application can be a complicated endeavor. There are various policy models to choose from (Like <a title="https://www.permit.io/blog/rbac-with-permit" href="https://www.permit.io/blog/rbac-with-permit">RBAC</a>, <a title="https://www.permit.io/blog/what-is-abac" href="https://www.permit.io/blog/what-is-abac">ABAC</a>, and <a title="https://www.permit.io/blog/what-is-rebac" href="https://www.permit.io/blog/what-is-rebac">ReBAC</a>), and several policy-as-code engines and languages to implement with.</p><p>In this tutorial, we will focus on Role-Based Access Control (RBAC) and how (and why) you should implement it using the AWS Cedar policy engine - which allows you to create a separate microservice for authorization, <a title="https://www.permit.io/blog/5-best-practices-for-building-cloud-native-permissions#the-5-best-practices" href="https://www.permit.io/blog/5-best-practices-for-building-cloud-native-permissions#the-5-best-practices"><u>decoupling our policy from our code</u></a>.<br><br>This tutorial was created with the help of <a title="https://www.linkedin.com/in/mike-hicks-a053311/" href="https://www.linkedin.com/in/mike-hicks-a053311/"><a title="https://www.linkedin.com/in/mike-hicks-a053311/" href="https://www.linkedin.com/in/mike-hicks-a053311/"><strong>Mike Hicks</strong></a></a> - Senior Principal Scientist at AWS and  Co-lead of the <a title="https://www.cedarpolicy.com/en" href="https://www.cedarpolicy.com/en">Cedar policy language open-source project.</a> </p><h2>What is RBAC?</h2><p><a title="https://www.permit.io/blog/rbac-with-permit" href="https://www.permit.io/blog/rbac-with-permit"><strong>Role-based access control (RBAC)</strong></a> is an authorization model used to determine access control <strong>based on predefined roles</strong>. Permissions are assigned to roles (Like “Admin or “User”), and roles are assigned to users by the administrator. The RBAC model allows you to easily understand who has access to what and is one of the most popular policy models for building authorization. </p><p>Other models like <a title="https://www.permit.io/blog/what-is-abac" href="https://www.permit.io/blog/what-is-abac">Attribute Based Access Control (ABAC)</a>, allow for more granular access control. Creating policies with Cedar allows you to write policies that use RBAC, ABAC, or elements of both. </p><p>You can read more about different policy models and when they should be applied <a title="https://www.permit.io/blog/rbac-vs-abac" href="https://www.permit.io/blog/rbac-vs-abac"><u>here</u></a>. </p><h2><strong>Why Policy-As-Code?</strong> </h2><p>After making the decision that you need an RBAC model in your application, it is important to note the challenges you’ll have to face along the way: </p><p>The set of policies for each individual service has to be <strong>manually set up inside the service itself</strong>. This can be quite a pain to do - as the amount of policies, users, and services grows, updating them in each relevant service becomes super tedious and time-consuming. Considering the fact that policies change all the time - <strong>they have to be at least somewhat fluid</strong>. </p><p>Having the code of the authorization layer mixed in with the code of the application itself is also a major pitfall you should avoid. Hard-coding authorization into your application creates a situation where every upgrade, added capability and monitoring of the code as it is replicated between different microservices become a huge hassle. Each change would require<strong> refactoring large areas of code</strong> that only drift further from one another as these microservices develop. </p><p>How can we avoid this?</p><p><strong>Creating a separate microservice for authorization</strong>, thus decoupling our policy from our code. Controlling access management centrally through a separate authorization service allows you to offer it as a service to every system in your application that needs to check whether a resource can be accessed. One way to achieve this separation is by using <strong>AWS Cedar</strong>. </p><h2>What is AWS Cedar?</h2><p>Cedar is a language for writing authorization policies, together with an engine for evaluating those policies to make authorization decisions. <br><br>You can run Cedar in the cloud with<a title="https://aws.amazon.com/verified-permissions/" href="https://aws.amazon.com/verified-permissions/"> Amazon Verified Permissions</a>, and deploy Cedar as a standalone agent (e.g. locally, in other cloud environments, or as a sidecar in K8s) with <a title="https://www.permit.io/blog/cedar-rbac#the-cedar-agent" href="https://www.permit.io/blog/cedar-rbac#the-cedar-agent">Cedar-Agent</a>.</p><p>Cedar offers a unique approach to the <a title="https://www.permit.io/blog/opa-vs-cedar#the-benefits-of-using-pac" href="https://www.permit.io/blog/opa-vs-cedar#the-benefits-of-using-pac">Policy-as-Code trend</a>. While other policy languages (like Rego) tend to offer a multi-propose language that could fit into application-level authorization, Cedar is built with application-level authorization in mind. <br><br>You can learn about how Cedar compares other policy languages (Namely OPA’s Rego) <a title="https://www.permit.io/blog/opa-vs-cedar" href="https://www.permit.io/blog/opa-vs-cedar"><u>here</u></a>.<br><br>Let’s dig into how the Cedar policy language works - </p><h2>The Cedar Policy Syntax</h2><p>Roughly speaking, the policy scope describes a role-based access control (RBAC)-style policy, while the conditional clauses refine it to express an attribute-based access control (ABAC) policy. The effect and policy scope are mandatory, but the conditional clauses are optional. </p><p>Like every authorization policy, Cedar aims to answer the question of: <strong>Who </strong>can perform which <strong>Actions </strong>on which <strong>Resource</strong></p><p>In Cedar, this type of question is asked in the following terms: Which <strong>Principal </strong>can perform what <strong>Actions </strong>on a given <strong>Resource.</strong></p><p>The structure of a Cedar policy looks like this:</p><ul><li><div><p><strong>Effect </strong>- Either <strong>Permit </strong>or <strong>Forbid </strong> All requests are set to be denied by default. Choosing an <strong>effect </strong>allows us to define two types of policies - based on either permitting or forbidding requests. A <strong>permit </strong>policy grants access, while a <strong>forbid </strong>policy restricts access by overriding a permit policy. </p></div></li><li><div><p><strong>Policy Scope</strong>- Describes the <strong>Principal, Action, and Resource </strong>the policy applies to, partly based on role or group membership.</p></div></li></ul><p>This structure describes an RBAC policy.  To extend upon basic RBAC, Cedar offers a <strong>Condition</strong> clause. </p><ul><li><div><p><strong>Condition</strong> - Allows adding more granular permissions by adding generic conditions to them This is relevant for attribute-based access control (ABAC) policies where a <strong>Context</strong> and <strong>Attributes </strong>can be added. </p></div></li></ul><h2>Sample policy - ‘User’ can perform ‘Action’ on ‘Resource’</h2><p>Principals, Actions, and Resources are objects called <strong>Entities. </strong>An <strong>Entity </strong>is composed of a <strong>Type </strong>and an <strong>ID</strong> in the following format:</p><p><code>principal == Type::”ID”</code></p><p>Combining the syntax we learned so far, we can create the following policy: </p><pre><code>permit (
      principal == User::”Frank”, 
      action == Action::”get_document”, 
      resource == Document::”cedar_tutorial.pdf”
);</code></pre><p>This policy allows the user ‘<code>Frank’</code> to ‘<code>get_document</code>’ ‘<code>cedar_tutorial.pdf</code>’. </p><p>Principals and resources are identified by a unique combination of a <strong>Type </strong>and an <strong>ID</strong>. <br>For example, a principal of type ‘<code>User</code>’ called ‘<code>Frank</code>’. Each time a policy references a principal or a resource, it must call out both the type and the ID. </p><p>So far, our policy allows a specific user (‘<code>Frank</code>’) access to a specific resource. In order to achieve RBAC, we need to be able to define <strong>Roles</strong>. This can be done by using the concept of Parents<strong> </strong>and the<strong> ‘In’</strong> keyword. Let’s dive into those. </p><h2>Creating Roles - Parents<strong>, </strong>the ‘In’ keyword</h2><p>In addition to the <strong>Type</strong> and <strong>ID</strong> discussed previously, an <strong>Entity</strong> also possesses <strong>Parents</strong>. <strong>Parents</strong> help establish connections between multiple entities and enable us to create enforcements within our policy.</p><p>In real-world applications, it&#39;s common to have multiple users sharing the same permissions. <br>To address this, we often group them using <strong>Roles</strong>. That’s what the <strong>Parents</strong> feature is here for. Let&#39;s consider an example with three types of users: <strong>Admin</strong>, <strong>Editor</strong>, and <strong>Viewer</strong>.</p><p><strong>Admins</strong> can &quot;<code>get</code>,&quot; &quot;<code>update</code>,&quot; &quot;<code>create</code>,&quot; and &quot;<code>delete</code>&quot; documents.</p><p><strong>Editors</strong> can &quot;<code>get</code>&quot; and &quot;<code>update</code>&quot; documents.</p><p><strong>Viewers</strong> can &quot;<code>get</code>&quot; documents.</p><p>Now, let&#39;s modify the previous policy example to align with our new policy:</p><pre><code>permit (
    principal in Role::&quot;Admin&quot;,
    action in [Action::&quot;get_document&quot;, Action::&quot;update_document&quot;, Action::&quot;create_document&quot;, Action::&quot;delete_document&quot;],
    resource == Document::&quot;cedar_tutorial.pdf&quot;
    );

    permit (
    principal in Role::&quot;Editor&quot;,
    action in [Action::&quot;get_document&quot;, Action::&quot;update_document&quot;],
    resource == Document::&quot;cedar_tutorial.pdf&quot;
    );   
    
    permit (
    principal in Role::&quot;Viewer&quot;,
    action in [Action::&quot;get_document&quot;],
    resource == Document::&quot;cedar_tutorial.pdf&quot;
    );
</code></pre><p>Consider a scenario where you have 1000 users. Without grouping, you would need to create a separate policy for each user. However, with the concept of grouping, you can significantly reduce the number of required policies.</p><p>You may have noticed a new keyword called &quot;<strong>in</strong>”. By utilizing this keyword, you can recursively check if an entity is under a parent or if an entity exists in an array. </p><p>In this example, we defined an <strong>Entity</strong> of <strong>Type</strong> <strong>Role</strong>. We&#39;ll group our users by assigning these entities as <strong>Parents </strong>(Or, an <strong>ancestor - </strong>a parent, grandparent, great-grandparent, etc.) in the following manner:</p><ul><li><div><p>Every admin user will have the <code><strong>Role::&quot;Admin&quot;</strong></code> as an ancestor.</p></div></li><li><div><p>Every editor user will have the <code><strong>Role::&quot;Editor&quot;</strong></code> as an ancestor.</p></div></li><li><div><p>Every viewer user will have the <code><strong>Role::&quot;Viewer&quot;</strong></code> as an ancestor.</p></div></li></ul><p>Ancestors create a hierarchy of roles, as can be seen in this diagram:</p><img src="https://media.graphassets.com/dizGnt4VTYCA6aktKhtH" alt="Group 67736.png" title="Group 67736.png" width="1481" height="1481" /><p>In this particular example, Admin has both Editor and Viewer as its parents, and Editor has Viewer as its parent. Thus, all Editors are Viewers, and all Admins are both Viewers and Editors. There&#39;s no need to put the “view” operations in both the Admin and Editor policies — users will inherit them from the Viewer policy.<br><br>This <strong>Parent</strong> relationship allows for efficient management and fewer policies.</p><p><strong>So how do we define these entities? </strong></p><p>The JSON format of an <strong>Entity</strong> is:</p><pre><code>{
  &quot;uid&quot;: {
    &quot;id&quot;: &quot;Frank&quot;,
    &quot;type&quot;: &quot;User&quot;
  },
  &quot;parents&quot;: [
    {
      &quot;id&quot;: &quot;Admin&quot;,
      &quot;type&quot;: &quot;Role&quot;
    }
  ],
  &quot;attrs&quot;: {}
}</code></pre><p>The <code><strong>uid</strong></code> key represents the <strong>Type</strong> and <strong>ID</strong>, and the <strong>parents</strong> key represents the <strong>Parents</strong>. This Entity defines Frank as a User, with his parents being the Admin role. </p><p>‘<code><strong>attrs</strong></code><strong>’</strong> represent entity attributes, which allow adding specific attributes to entities, thus creating more granular policies (ABAC).</p><h2>Policy examples</h2><p>To check the examples yourself, use the following entities at: <a title="https://www.cedarpolicy.com/en/playground" href="https://www.cedarpolicy.com/en/playground">https://www.cedarpolicy.com/en/playground</a>.</p><pre><code>[
    {
        &quot;uid&quot;: {
            &quot;id&quot;: &quot;Frank&quot;,
            &quot;type&quot;: &quot;User&quot;
        },
        &quot;parents&quot;: [
            {
                &quot;id&quot;: &quot;Admin&quot;,
                &quot;type&quot;: &quot;Role&quot;
            }
        ],
        &quot;attrs&quot;: {}
    },
    {
        &quot;uid&quot;: {
            &quot;id&quot;: &quot;John&quot;,
            &quot;type&quot;: &quot;User&quot;
        },
        &quot;parents&quot;:[
            {
                &quot;type&quot;:&quot;Role&quot;,
                &quot;id&quot;:&quot;Viewer&quot;
            }
            ],
        &quot;attrs&quot;: {}
    },
    {
        &quot;uid&quot;: {
            &quot;id&quot;: &quot;Admin&quot;,
            &quot;type&quot;: &quot;Role&quot;
        },
        &quot;parents&quot;: [
            {
                &quot;id&quot;: &quot;Editor&quot;,
                &quot;type&quot;: &quot;Role&quot;
            }
        ],
        &quot;attrs&quot;: {}
    },
    {
        &quot;uid&quot;: {
            &quot;id&quot;: &quot;Editor&quot;,
            &quot;type&quot;: &quot;Role&quot;
        },
        &quot;parents&quot;: [
            {
                &quot;id&quot;: &quot;Viewer&quot;,
                &quot;type&quot;: &quot;Role&quot;
            }
        ],
        &quot;attrs&quot;: {}
    },    
    {
        &quot;uid&quot;: {
            &quot;id&quot;: &quot;cedar_tutorial.pdf&quot;,
            &quot;type&quot;: &quot;Document&quot;
        },
        &quot;attrs&quot;:{},
        &quot;parents&quot;:[]
    },
    {
        &quot;uid&quot;: {
            &quot;id&quot;: &quot;non_viewer.pdf&quot;,
            &quot;type&quot;: &quot;Document&quot;
        },
        &quot;parents&quot;:[],
        &quot;attrs&quot;: {}
    }
]</code></pre><ol><li><div><p>Every <strong>principal</strong> is allowed to perform the ‘<code><strong>get_document</strong></code><strong>’</strong> <strong>Action</strong> on the <strong>Document</strong> ‘<code><strong>cedar_tutorial.pdf</strong></code><strong>’</strong></p></div></li></ol><pre><code>permit(
    principal,
    action == Action::”get_document”,
    resource == Document::”cedar_tutorial.pdf”
    );</code></pre><p>The following authorization request will be allowed because all three parameters in the policy scope are matched:<br><br>Principal: </p><pre><code>User::&quot;unknown-user&quot;</code></pre><p>Action: </p><pre><code>Action::&quot;get_document&quot;</code></pre><p>Resource:</p><pre><code>Document::&quot;cedar_tutorial.pdf&quot;</code></pre><p>The following authorization request will be denied because the resource doesn’t match our allowing policy:</p><p>Principal: </p><pre><code>User::&quot;unknown-user&quot;</code></pre><p>Action: </p><pre><code>Action::&quot;get_document&quot;</code></pre><p>Resource:</p><pre><code>Document::&quot;internal_doc.pdf&quot;</code></pre><p><br>2. A <strong>principal </strong>that is a part of <strong>‘</strong><code><strong>Role::Admin</strong></code><strong>’ </strong>is allowed to perform any <strong>Action</strong> on the <strong>Document ‘</strong><code><strong>cedar_tutorial.pdf</strong></code><strong>’</strong>. </p><pre><code>permit(
    principal in Role::”Admin”,
    action,
    resource == Document::”cedar_tutorial.pdf”
    );</code></pre><p>The following authorization request will be allowed because all three parameters in the policy scope are matched ( User:::”Frank” has the Role::”Admin” ancestor):<br><br>Principal: </p><pre><code>User::&quot;Frank&quot;</code></pre><p>Action: </p><pre><code>Action::&quot;update_document&quot;</code></pre><p>Resource:</p><pre><code>Document::&quot;cedar_tutorial.pdf&quot;</code></pre><p>The following authorization request will be denied because User::”John” doesn’t have the Role::”Admin” ancestor:</p><p>Principal: </p><pre><code>User::&quot;John&quot;</code></pre><p>Action: </p><pre><code>Action::&quot;update_document&quot;</code></pre><p>Resource:</p><pre><code>Document::&quot;cedar_tutorial.pdf&quot;</code></pre><p><br>3. A <strong>principal</strong> that is a part of <code><strong>‘Role::Viewer</strong></code><strong>’</strong> is allowed to perform ‘<code><strong>get</strong></code><strong>’</strong> <strong>Action</strong> on any resource.</p><pre><code>permit(
    principal in Role::”Viewer”,
    action == Action::”get”,
    resource
    );</code></pre><p>The following authorization request will be allowed because all three parameters in the policy scope are matched ( User:::”John” has the Role::”Viewer” ancestor ):</p><p>Principal: </p><pre><code>User::&quot;John&quot;</code></pre><p>Action: </p><pre><code>Action::&quot;get&quot;</code></pre><p>Resource:</p><pre><code>Document::&quot;some_document.pdf&quot;</code></pre><p>The following authorization request will be denied because the action doesn’t match our allowing policy:</p><p>Principal: </p><pre><code>User::&quot;John&quot;</code></pre><p>Action: </p><pre><code>Action::&quot;delete&quot;</code></pre><p>Resource:</p><pre><code>Document::&quot;some_document.pdf&quot;</code></pre><p></p><p>4. A principal that is a part of <strong>‘</strong><code><strong>Role::Viewer</strong></code><strong>’</strong> is allowed to perform the &#39;<code><strong>get</strong></code><strong>&#39;</strong> <strong>Action</strong> on any resource except <strong>Document</strong> <strong>‘</strong><code><strong>non_viewer.pdf</strong></code><strong>’</strong>, to do this, we’ll use both permit and forbid to easily manage this rule.</p><pre><code>permit(
    principal in Role::”Viewer”,
    action == Action::”get”,
    resource
    );
    
forbid(
    principal in Role::”Viewer”,
    action,
    resource == Document::”non_viewer.pdf”
⁠    );</code></pre><p>The following authorization request will be allowed because all three parameters in the policy scope are matched ( User:::”John” has the Role::”Viewer” ancestor ):</p><p>Principal: </p><pre><code>User::&quot;John&quot;</code></pre><p>Action: </p><pre><code>Action::&quot;get&quot;</code></pre><p>Resource:</p><pre><code>Document::&quot;some_document.pdf&quot;</code></pre><p>The following authorization request will be denied because the query matches our forbid policy:</p><p>Principal: </p><pre><code>User::&quot;John&quot;</code></pre><p>Action: </p><pre><code>Action::&quot;get&quot;</code></pre><p>Resource:</p><pre><code>Document::&quot;non_viewer.pdf&quot;</code></pre><p><br>Now that we understand how Cedar policies are built, it&#39;s important to mention two open-source tools that could significantly aid with our Cedar implementation: </p><h2>The ‘Cedar Agent’</h2><p><a title="https://github.com/permitio/cedar-agent" href="https://github.com/permitio/cedar-agent"><u>Cedar Agent</u></a> is an open-source project that allows for easy deployment of Cedar policies within your application. Acting as an HTTP server, Cedar Agent efficiently manages a policy store and a data store, allowing you to easily control and monitor access to your application&#39;s resources. “Cedar Agent” includes: </p><ul><li><div><p>Policy Store Management: Cedar-Agent includes a centralized store for creating, retrieving, updating, and deleting policies. This allows fine-grained control over user access, defining who should have access to specific application resources.</p></div></li><li><div><p>Data Store Management: Cedar-Agent offers an efficient in-memory data store for managing application data. By integrating it with Cedar-Agent, authorized checks can be performed on stored data based on incoming HTTP requests, ensuring secure and controlled access.</p></div></li><li><div><p>Authorization Checks: Cedar-Agent excels at performing authorization checks on stored policies and data. Evaluating Cedar policies, it restricts user access to permitted resources. These checks are seamlessly performed based on incoming HTTP requests, providing a robust and secure mechanism for access control within your application.</p></div></li></ul><p>While Cedar provides us with a centralized authorization solution, the enforcement itself is still distributed - a Cedar agent is deployed next to every microservice, providing decisions and enforcement with near-zero network latency. The Cedar agents are distributed and can grow along with the services as they grow in scale. </p><h2>Real-time dynamic authorization - Cedar + OPAL </h2><p>Scaling the deployment of Cedar for policy evaluation in production can be challenging. <br>While Cedar provides the necessary building blocks for defining policies and evaluating decisions, deploying it with your application at scale requires a solution. This is where <a title="https://github.com/permitio/opal" href="https://github.com/permitio/opal"><u>OPAL</u></a> comes in. OPAL is an open-source project which serves as an administration layer that simplifies the deployment of Cedar engines and ensures seamless scalability. </p><p>With OPAL, you can effortlessly keep your policy configuration up to date across all deployed policy engines, ensuring consistency and accuracy. It also guarantees that the data used for evaluation remains current, facilitating precise policy enforcement. OPAL&#39;s configuration-as-code approach simplifies the deployment process by providing a centralized and easily manageable configuration. You can <a title="https://www.permit.io/blog/scaling-authorization-with-cedar-and-opal" href="https://www.permit.io/blog/scaling-authorization-with-cedar-and-opal"><u>learn more about how Cedar works with OPAL here.</u></a><br></p><h2>Learn more!</h2><p>Implementing Role-Based Access Control (RBAC) using AWS&#39; Cedar Policy Language offers a powerful solution for managing access to resources within your application. We explored the challenges associated with setting up RBAC policies and how AWS Cedar provides a robust framework to address them. </p><p>Want to know more about building and implementing authorization? Join our <a title="https://io.permit.io/permitslack" href="https://io.permit.io/permitslack"><u>Slack community</u></a>, where hundreds of developers are discussing, building, and implementing access control into their applications.<br><br>Cedar is a new and evolving policy language. Join the <a title="https://communityinviter.com/apps/cedar-policy/cedar-policy-language" href="https://communityinviter.com/apps/cedar-policy/cedar-policy-language"><u>Cedar Slack community</u></a> for questions about Cedar-specific use cases, new ideas, and feedback.</p>]]></content>
        <author>
            <name>Daniel Bass</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Next.js Passwordless Authentication with SuperTokens & Twilio]]></title>
        <id>nextjs-passwordless-authentication-with-supertokens-and-twilio</id>
        <link href="https://www.permit.io/blog/nextjs-passwordless-authentication-with-supertokens-and-twilio"/>
        <updated>2023-06-12T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Learn passwordless authentication and basic authorization with SuperTokens, Twilio and Permit.io. Simplify login, enhance security, and eliminate passwords.]]></summary>
        <content type="html"><![CDATA[<p><strong>TL;DR:</strong> Passwordless authentication replaces traditional login methods with secure alternatives, like one-time passwords or biometrics, simplifying user experience. As a Developer Advocate at Permit.io, I encourage developers to learn this process through code and practical examples.</p><p>In this tutorial, we’ll learn <strong>how to set up </strong><a rel="noopener" class="markup--anchor markup--p-anchor" target='_blank' title="https://supertokens.com/" href="https://supertokens.com/"><strong>SuperTokens</strong></a><strong> Passwordless Authentication</strong> and <strong>How to implement basic Authorization with </strong><a rel="noopener" class="markup--anchor markup--p-anchor" target='_blank' title="https://permit.io" href="https://permit.io"><strong>Permit.io</strong></a>.</p><h2>What is Passwordless Authentication</h2><p>Passwordless authentication is a method of verifying a user’s identity without relying on traditional username/password combinations. Instead, it uses alternative means, such as one-time codes, magic links sent via email, or biometric data like fingerprints or facial recognition. This approach simplifies the login process and enhances security by eliminating the need to remember and manage passwords.</p><p>If you still find yourself confused about the difference between Authentication and Authorization (as they sound very similar), check out <a rel="noopener" class="markup--anchor markup--p-anchor" target='_blank' title="https://www.permit.io/blog/authn-vs-authz" href="https://www.permit.io/blog/authn-vs-authz"><strong>this great article</strong></a>.</p><p><a rel="noopener" class="markup--anchor markup--p-anchor" target='_blank' title="https://supertokens.com/" href="https://supertokens.com/"><strong>SuperTokens</strong></a> is an open-source authentication provider designed to simplify adding secure, scalable, and easily customizable authentication to your applications. It provides various features like passwordless login, email verification, OAuth support, and session management.</p><p><strong>Next.js</strong> is a popular React framework built by Vercel, which provides features such as server-side rendering (SSR), static site generation (SSG), and API routes. It’s designed to make building scalable, high-performance web applications easier while offering a rich developer experience.</p><p><strong>Prerequisites</strong>: Basic knowledge of NextJS and JavaScript</p><h2>Let’s create a basic starter App in Next.js!</h2><p>As a Developer Advocate at <a rel="noopener" class="markup--anchor markup--p-anchor" target='_blank' title="https://io.permit.io/supertokens-passwordless-blog" href="https://io.permit.io/supertokens-passwordless-blog">Permit.io</a>, I have consistently been guided to believe that when developers aspire to navigate the intricate realm of Authentication and Authorization, the most effective approach is to demonstrate them through code and practical examples. </p><p>Let’s dive into that.</p><p>To get started, you’ll need to have <a rel="noopener" class="markup--anchor markup--p-anchor" target='_blank' title="https://nodejs.org/en" href="https://nodejs.org/en">Node.js installed on your computer</a>. Then, follow these steps:</p><ol><li><div>Install the <code>create-next-app</code> CLI tool globally.</div></li></ol><pre><code>npm install -g create-next-app</code></pre><p>2. Create a new Next.js application. You will be prompted with several questions to setup your project.</p><pre><code>create-next-app my-supertokens-app</code></pre><p>3. Navigate to the newly created directory.</p><pre><code>cd my-supertokens-app</code></pre><p>4. Run the development server.</p><pre><code>npm run dev</code></pre><p>Now you should see your Next.js application running on <code>http://localhost:3000</code>.</p><img src="https://media.graphassets.com/fFEKatkZRZWYGtjBtFbH" alt="2.png" title="2.png" width="3248" height="2004" /><p>Congratulations!</p><h2>Setting up SuperTokens Passwordless Authentication</h2><p>This guide will cover a few steps:</p><ol><li><div>Creating our frontend and backend configurations</div></li><li><div>Showing the Login UI</div></li><li><div>Configuring Twilio and setting up SMS OTPs</div></li><li><div>Adding SMS Delivery Functionality</div></li><li><div>Adding Authentication APIs</div></li><li><div>Protecting restricted website routes with session verification</div></li><li><div>Implementing basic authorization with Permit</div></li></ol><p>For us to get started, we need to make sure we have the required dependencies installed  — </p><pre><code>npm install supertokens-node@latest supertokens-auth-react@latest supertokens-web-js@latest nextjs-cors dotenv swr</code></pre><h3>1. Creating our frontend and backend configurations</h3><ul><li><div>Create an <code>.env.local</code> file at the root of the project with the following content. We will fill these in as we proceed with the tutorial.</div></li></ul><pre><code>SUPERTOKENS_CONNECTION_URI=
SUPERTOKENS_API_KEY=

TWILIO_ACCOUNT_SID=
TWILIO_AUTH_TOKEN=
TWILIO_TRIAL_PHONE_NUMBER=</code></pre><ul><li><div>Create a <code>config</code> folder at the root of your project. </div></li><li><div>Now create an <code>appInfo.js</code> inside the <code>config</code> folder with the following content:</div></li></ul><pre><code>const port = process.env.APP_PORT || 3000;

const apiBasePath = &quot;/api/auth/&quot;;

export const websiteDomain =
 process.env.APP_URL ||
 process.env.NEXT_PUBLIC_APP_URL ||
 `http://localhost:${port}`;

export const appInfo = {
 appName: &quot;SuperTokens with Passwordless by Permit.io&quot;,
 websiteDomain,
 apiDomain: websiteDomain,
 apiBasePath,
};</code></pre><p>The <code>appInfo</code> file is crucial for implementing SuperTokens Passwordless Authentication. It specifies essential details such as the app’s name, API domain, and website domain. These configurations enable SuperTokens to correctly manage sessions, cookies, and CORS settings. This ensures seamless integration and secure authentication for the frontend and backend. You can read more about the <code>appInfo</code> file <a rel="noopener" class="markup--anchor markup--p-anchor" target='_blank' title="https://supertokens.com/docs/passwordless/appinfo" href="https://supertokens.com/docs/passwordless/appinfo">here</a>.</p><p>We need two more configuration files in our <code>config</code> folder. One for the frontend and one for the backend.</p><ul><li><div>Create a <code>frontendConfig.js</code> file inside the <code>config</code> folder. </div></li></ul><p>We need to construct a function that generates the SuperTokens’ front-end SDK configuration. We will explore how to utilize this function later. Take note of the contact method, <code>PHONE</code>, which signifies that passwordless authentication will be facilitated through sending an OTP only to the email or phone number specified by the user during login. You can also specify <code>PHONE_OR_EMAIL</code>to have the flexibility of authenticating with a Magic Link too. In this tutorial, we will only allow passwordless login with the aid of a phone. </p><pre><code>import { PasswordlessPreBuiltUI } from &quot;supertokens-auth-react/recipe/passwordless/prebuiltui&quot;;
import SessionReact from &quot;supertokens-auth-react/recipe/session&quot;;
import { appInfo } from &quot;./appInfo&quot;;
import Router from &quot;next/router&quot;;
import PasswordlessReact from &quot;supertokens-auth-react/recipe/passwordless&quot;;

export let frontendConfig = () =&gt; {
 return {
  appInfo,
  recipeList: [
   PasswordlessReact.init({
    contactMethod: &quot;PHONE&quot;,
   }),
   SessionReact.init(),
  ],
  // this is so that the SDK uses the next router for navigation
  windowHandler: (oI) =&gt; {
   return {
    ...oI,
    location: {
     ...oI.location,
     setHref: (href) =&gt; {
      Router.push(href);
     },
    },
   };
  },
 };
};

export const PreBuiltUIList = [PasswordlessPreBuiltUI];</code></pre><p>Now let’s create the back-end configurations - </p><ul><li><div>Create a file called <code>backendConfig.js</code> inside the <code>config</code> folder.</div></li></ul><pre><code>require(&quot;dotenv&quot;).config();

import SessionNode from &quot;supertokens-node/recipe/session&quot;;
import Dashboard from &quot;supertokens-node/recipe/dashboard&quot;;
import { appInfo } from &quot;./appInfo&quot;;
import PasswordlessNode from &quot;supertokens-node/recipe/passwordless&quot;;

export let backendConfig = () =&gt; {
 return {
  framework: &quot;express&quot;,
  supertokens: {
   // this is the location of the SuperTokens core.
   connectionURI:
    process.env.SUPERTOKENS_CONNECTION_URI,
   apiKey: process.env.SUPERTOKENS_API_KEY,
  },
  appInfo,
  // recipeList contains all the modules that you want to
  // use from SuperTokens. See the full list here: https://supertokens.com/docs/guides
  recipeList: [
   PasswordlessNode.init({
    flowType: &quot;USER_INPUT_CODE&quot;,
    contactMethod: &quot;PHONE&quot;,
   }),
   SessionNode.init(),
   Dashboard.init(),
  ],
  isInServerlessEnv: true,
 };
};</code></pre><p>To properly configure your application, you must set up your own SuperTokens core and replace the core address above.</p><p>There are two methods for setting up your own core:</p><ol><li><div><strong>Self-hosting SuperTokens</strong>: You can host the SuperTokens core on your own infrastructure, utilizing your database of choice (MySQL or PostgreSQL). This can be done through manual installation or by using Docker.</div></li><li><div><strong>Using the managed service option</strong>: To establish a SuperTokens core via the managed service, create a free account with <a rel="noopener" class="markup--anchor markup--li-anchor" target='_blank' title="https://supertokens.com/" href="https://supertokens.com/">Supertokens</a> and log in. From the dashboard, create a new app. You can obtain the connection URL and API key from the app details page upon completion.</div></li></ol><p>For this example, I went for the managed service option. It’s fast and easy to get started. This is what you should see in the SuperTokens dashboard once you create an account, and complete the simple “Get Started” section:</p><p>(!) Make sure that the Development Environment is version <code>v5.0</code>.</p><img src="https://media.graphassets.com/OQbQ74Q5QOivBFi4hQTk" alt="3.png" title="3.png" width="1726" height="1940" /><p>Under <code>setup</code> you will be able to find the <code>URL</code> and the <code>API Key</code>. Please make sure you add them to the <code>.env.local</code> file.</p><p>Next, we’ll need to call the front-end initialization functions from the <code>_app.js</code> file. To do this, follow these steps:</p><ul><li><div>Locate the <code>_app.js</code> file inside the <code>pages</code>folder.</div></li><li><div>Replace its content with the provided code snippet.</div></li></ul><pre><code>import &quot;../styles/globals.css&quot;;
import React from &quot;react&quot;;
import { useEffect } from &quot;react&quot;;
import SuperTokensReact, { SuperTokensWrapper } from &quot;supertokens-auth-react&quot;;
import * as SuperTokensConfig from &quot;../../config/frontendConfig&quot;;
import Session from &quot;supertokens-auth-react/recipe/session&quot;;

if (typeof window !== &quot;undefined&quot;) {
 SuperTokensReact.init(SuperTokensConfig.frontendConfig());
}

function MyApp({ Component, pageProps }) {
 useEffect(() =&gt; {
  async function doRefresh() {
   if (pageProps.fromSupertokens === &quot;needs-refresh&quot;) {
    if (await Session.attemptRefreshingSession()) {
     location.reload();
    } else {
     // user has been logged out
     SuperTokensReact.redirectToAuth();
    }
   }
  }
  doRefresh();
 }, [pageProps.fromSupertokens]);
 if (pageProps.fromSupertokens === &quot;needs-refresh&quot;) {
  return null;
 }

 return (
  &lt;SuperTokensWrapper&gt;
   &lt;Component {...pageProps} /&gt;
  &lt;/SuperTokensWrapper&gt;
 );
}

export default MyApp;</code></pre><p>Congratulations — All the integrations are now complete. Let’s now display a Login UI.</p><h3>2. Showing the Login UI</h3><p>Adding the UI is simple. </p><ul><li><div>Create a new folder called <code>auth</code> inside the <code>pages</code> folder.</div></li><li><div>Inside the <code>auth</code> folder, create a file called <code>[[...path]].js</code>. This naming represents a catch-all dynamic route. </div></li><li><div>Paste the below code into the <code>[[...path]].js</code> file.</div></li></ul><pre><code>import React, { useEffect } from &quot;react&quot;;
import dynamic from &quot;next/dynamic&quot;;
import SuperTokens from &quot;supertokens-auth-react&quot;;
import { canHandleRoute, getRoutingComponent } from &quot;supertokens-auth-react/ui&quot;;
import { PreBuiltUIList } from &quot;../../../config/frontendConfig&quot;;

const SuperTokensComponentNoSSR = dynamic(
 new Promise((res) =&gt; res(() =&gt; getRoutingComponent(PreBuiltUIList))),
 { ssr: false }
);

export default function Auth() {
 useEffect(() =&gt; {
  if (canHandleRoute(PreBuiltUIList) === false) {
   SuperTokens.redirectToAuth({
    redirectBack: false,
   });
  }
 }, []);

 return (
  &lt;main&gt;
   &lt;SuperTokensComponentNoSSR /&gt;
  &lt;/main&gt;
 );
}</code></pre><p>Navigate to your <a class="markup--anchor markup--li-anchor" target='_blank' title="http://localhost:3000/auth" href="http://localhost:3000/auth"><code>http://localhost:3000/auth</code></a>. You should see the passwordless login screen.</p><img src="https://media.graphassets.com/oTYH5nDSYyqtemWy62nh" alt="4.png" title="4.png" width="1394" height="1032" /><p>In general, authentication serves the purpose of restricting users from accessing certain parts of a site. It might seem that we are good to go, but we haven’t yet secured any other part of the URL. We will do that in a later part of the tutorial. Let’s now set up our Twilio account, configure the phone numbers and add our private keys to the <code>.env.local</code>file.</p><h3>3. Configuring Twilio and setting up SMS OTP’s</h3><p>Let’s take a moment to discuss the Twilio OTP method for delivering your authentication code. Don’t worry if you’re new to coding, and it might seem scary; I’ll explain everything in a beginner-friendly manner.</p><p>To get started with <a rel="noopener" class="markup--anchor markup--p-anchor" target='_blank' title="https://www.twilio.com/" href="https://www.twilio.com/">Twilio</a>, <a rel="noopener" class="markup--anchor markup--p-anchor" target='_blank' title="https://www.twilio.com/try-twilio" href="https://www.twilio.com/try-twilio"><strong>sign up for an account</strong></a> and follow a few straightforward steps. You can find an example of how to set this up <a rel="noopener" class="markup--anchor markup--p-anchor" target='_blank' title="https://github.com/supertokens/supertokens-auth-react/blob/2e50d0c5d98dffe45396a7ac7d0a002613a54ffc/examples/with-passwordless/api-server/index.js#L53" href="https://github.com/supertokens/supertokens-auth-react/blob/2e50d0c5d98dffe45396a7ac7d0a002613a54ffc/examples/with-passwordless/api-server/index.js#L53">here</a>.</p><p>You will need to go through the process of <code>verifying a service</code> to be able to send verification codes.</p><p>Once you end up in the console, this is what the Twilio dashboard looks like. Create your free account, and you will have access to your <code>Account SID</code> and <code>Auth Token</code>. Please make sure to add them to your <code>.env.local</code> file.</p><img src="https://media.graphassets.com/L4UrV64RTa7NxdcD6vda" alt="5.png" title="5.png" width="2458" height="2078" /><p>As part of our free trial, we also need to verify our own phone number and get a free Twilio-generated phone number we can use to receive our texts. The free phone number comes as part of the trial package, so there is no need for you to pay.</p><h4>Adding a verified phone number &amp; a Twilio Active Number</h4><p>From the console, navigate to <code>Phone Numbers</code> &gt; <code>Verified Caller IDs</code>. Next, in the top right corner, click <code>Add a new Called ID</code>.</p><p>Fill out the box with your area code and phone number.</p><img src="https://media.graphassets.com/m9v6XBvFQuK5Orxdr60P" alt="6.png" title="6.png" width="2346" height="1872" /><p>Next, navigate to <code>Phone Numbers</code> &gt; <code>Active Numbers</code>, and create your free phone number as part of the trial.</p><h3>4. Adding SMS Delivery Functionality</h3><p>It’s now time to see SuperTokens and Twilio in action. In the <code>backendConfig.js</code> file, add the below import:</p><pre><code>import { TwilioService } from &quot;supertokens-node/recipe/passwordless/smsdelivery&quot;;</code></pre><p>Now add the code snippet below:</p><pre><code>require(&quot;dotenv&quot;).config();

import SessionNode from &quot;supertokens-node/recipe/session&quot;;
import Dashboard from &quot;supertokens-node/recipe/dashboard&quot;;
import { appInfo } from &quot;./appInfo&quot;;
import PasswordlessNode from &quot;supertokens-node/recipe/passwordless&quot;;
import { TwilioService } from &quot;supertokens-node/recipe/passwordless/smsdelivery&quot;;

export let backendConfig = () =&gt; {
 return {
  framework: &quot;express&quot;,
  supertokens: {
   // this is the location of the SuperTokens core.
   connectionURI:
    &quot;https://dev-d8165211046a11ee8b9f3fc3a7d3670f-eu-west-1.aws.supertokens.io:3569&quot;,
   apiKey: &quot;9JjevRnn9-7FdexV-1OoDiYyHYglv-&quot;,
  },
  appInfo,
  // recipeList contains all the modules that you want to
  // use from SuperTokens. See the full list here: https://supertokens.com/docs/guides
  recipeList: [
   PasswordlessNode.init({
    flowType: &quot;USER_INPUT_CODE&quot;,
    contactMethod: &quot;PHONE&quot;,

// ############### ADD THE SNIPPET BELOW ##############

    smsDelivery: {
     service: new TwilioService({
      twilioSettings: {
       accountSid: process.env.TWILIO_ACCOUNT_SID,
       authToken: process.env.TWILIO_AUTH_TOKEN,
       from: process.env.TWILIO_TRIAL_PHONE_NUMBER,
      },
     }),
    },

// #####################################################

   }),
   SessionNode.init(),
   Dashboard.init(),
  ],
  isInServerlessEnv: true,
 };
};</code></pre><p>It’s time to test — navigate to <a class="markup--anchor markup--p-anchor" target='_blank' title="http://localhost:3000/auth," href="http://localhost:3000/auth,"><code>http://localhost:3000/auth</code></a><a class="markup--anchor markup--p-anchor" target='_blank' title="http://localhost:3000/auth," href="http://localhost:3000/auth,">,</a> select your country code, enter your phone number, and wait until the code arrives. Got it? Hurray!!!</p><img src="https://media.graphassets.com/kuK4o5XuSC2GhLhmxN9A" alt="7.jpeg" title="7.jpeg" width="1007" height="432" /><h3>5. Adding Authentication API’s to secure URL access</h3><p>Implementing the backend APIs for authentication is fairly simple. Here are the steps:</p><ul><li><div>Create an <code>auth</code> folder within the <code>pages/api/</code> directory. </div></li><li><div>Create a file named <code>[[…path]].js</code> , and insert the following code into it:</div></li></ul><pre><code>import { superTokensNextWrapper } from &quot;supertokens-node/nextjs&quot;;
import supertokens from &quot;supertokens-node&quot;;
import { middleware } from &quot;supertokens-node/framework/express&quot;;
import { backendConfig } from &quot;../../../../config/backendConfig&quot;;

supertokens.init(backendConfig());

export default async function superTokens(req, res) {
 await superTokensNextWrapper(
  async (next) =&gt; {
   res.setHeader(
    &quot;Cache-Control&quot;,
    &quot;no-cache, no-store, max-age=0, must-revalidate&quot;
   );
   await middleware()(req, res, next);
  },
  req,
  res
 );
 if (!res.writableEnded) {
  res.status(404).send(&quot;Not found&quot;);
 }
}</code></pre><p>The <code>[[…path]].js</code> file leverages the middleware provided by <code>supertokens-node</code>, which exposes essential APIs, such as <strong>sign-in</strong> and <strong>sign-up</strong>.</p><h3>6. Protect restricted website routes with session verification</h3><p>To see this inaction, let’s create a restricted page. </p><ul><li><div>Under the <code>pages</code> folder, add a new file called <code>restricted.js</code>. </div></li><li><div>Inside this file, paste the following code:</div></li></ul><pre><code>import React from &quot;react&quot;;

export default function Restricted() {
 return (
  &lt;div style={{ widows: &quot;100%&quot;, padding: &quot;10%&quot; }}&gt;
   &lt;h2
    style={{
     display: &quot;flex&quot;,
     alignItems: &quot;center&quot;,
     justifyContent: &quot;center&quot;,
     fontFamily: &quot;sans-serif&quot;,
    }}
   &gt;
    Restricted File - Only Authenticated Users can access this page.
   &lt;/h2&gt;
  &lt;/div&gt;
 );
}</code></pre><ul><li><div>Try accessing <a class="markup--anchor markup--li-anchor" target='_blank' title="http://localhost:3000/restricted." href="http://localhost:3000/restricted."><code>http://localhost:3000/restricted</code></a><a class="markup--anchor markup--li-anchor" target='_blank' title="http://localhost:3000/restricted." href="http://localhost:3000/restricted.">.</a> You should see the page below.</div></li></ul><img src="https://media.graphassets.com/C44h0ksQKSfQFjUsUC3W" alt="8.png" title="8.png" width="1922" height="966" /><p>Currently, it’s accessible even if we have not logged in — so let’s put the restrictions in place. We need to add enforcement code to the <code>restricted.js</code> file. It will look like this:</p><pre><code>import React from &quot;react&quot;;
import { SessionAuth } from &quot;supertokens-auth-react/recipe/session&quot;;

export default function Restricted() {
 return (
  &lt;SessionAuth&gt;
   &lt;div style={{ widows: &quot;100%&quot;, padding: &quot;10%&quot; }}&gt;
    &lt;h2
     style={{
      display: &quot;flex&quot;,
      alignItems: &quot;center&quot;,
      justifyContent: &quot;center&quot;,
      fontFamily: &quot;sans-serif&quot;,
     }}
    &gt;
     Restricted File - You can see this because your are authenticated!
    &lt;/h2&gt;
   &lt;/div&gt;
  &lt;/SessionAuth&gt;
 );
}</code></pre><p>As you can see, any page you don’t want anyone to access must be wrapped in <code>&lt;SessionAuth&gt;</code> tags. They will automatically redirect users to the login if they are unauthenticated (currently do not have a session). </p><p>Before we go ahead and test all of this, we need the option to log users out. Let’s add this quickly. </p><p>Navigate to the <code>index.js</code> file and replace the first <code>&lt;p&gt;</code> under the <code>&lt;main&gt;</code> element with the following:</p><pre><code>&lt;p style={{ cursor: &quot;pointer&quot; }} onClick={() =&gt; signOut()}&gt;
      Sign Out
&lt;/p&gt;</code></pre><p>Even though this will give you no visual feedback, it should have worked!</p><p>Give it a shot and navigate to <a class="markup--anchor markup--p-anchor" target='_blank' title="http://localhost:3000/restricted" href="http://localhost:3000/restricted">http://localhost:3000/restricted</a> to witness all the updates firsthand. Initially, you’ll encounter a login screen. Any attempts to reach the <code>/restricted</code> page will redirect you back to the login. Proceed by logging in and entering your OTP code for access. Upon successful login, try revisiting the page. You should have unrestricted access by now.</p><h3>7. Implementing Basic Authorization</h3><p>Authentication is <strong>just confirming a user’s identity</strong>  —  are they really the person they claim to be? Once a user is authenticated, it is important to enforce <strong>what the authenticated user can do inside the application itself</strong>. That’s <strong>Authorization</strong>.</p><p>Every user that successfully authenticates will need to be assigned a role. Access to different parts of the application or a user&#39;s actions will be decided based on their designated role. <strong>That’s a policy</strong>.</p><p>The <code>/restricted</code> page is currently available to everyone who is authenticated. However, we only want users to access the restricted page if they are an <code>Administrator</code>.</p><p>To get started, make an account with Permit <a rel="noopener" class="markup--anchor markup--p-anchor" target='_blank' title="https://io.permit.io/supertokens-passwordless-blog" href="https://io.permit.io/supertokens-passwordless-blog">here</a>. Permit is a full-stack authorization service that allows us to manage the policies we assign to each role with a no-code UI. </p><p>There are a few steps we need to go through to set this up:</p><ul><li><div>Install the Permit SDK</div></li></ul><pre><code>npm install permitio</code></pre><ul><li><div>Create a Permit instance within your application through our cloud PDP, a dedicated microservice for authorization. Inside the <code>/pages/api</code>directory, establish a new subdirectory named <code>/access</code>and include a file named <code>authorize.js</code> in it. Finally, input the following code into that file:</div></li></ul><pre><code>import { Permit } from &quot;permitio&quot;;

const permit = new Permit({
 pdp: &quot;https://cloudpdp.api.permit.io&quot;,
 token: process.env.PERMIT_SDK_TOKEN || &quot;YOUR_PERMIT_SDK_API_KEY_HERE&quot;,
});</code></pre><ul><li><div>Retrieve the Permit API Key and pass it into the Permit instance object. Make sure to add this to your <code>.env.local</code> file.</div></li></ul><img src="https://media.graphassets.com/u6a4Pr6BSiG4zYyjPpQy" alt="9.png" title="9.png" width="1352" height="806" /><p>You can follow this simple Quickstart guide which you can find <a rel="noopener" class="markup--anchor markup--p-anchor" target='_blank' title="https://io.permit.io/docs-quickstart" href="https://io.permit.io/docs-quickstart"><strong>here</strong></a><strong> </strong>if you prefer. </p><p>Once we have everything set up, we can start to configure our policies to enforce access and make sure only administrators can access the <code>/restricted</code> page.</p><h4>1. Setting up a basic policy in Permit’s no-code dashboard</h4><p>Navigate to the <strong>Policy</strong> page - you can find it on the left navigation bar.</p><img src="https://media.graphassets.com/A0Ap1yPmRxqowufcvkgQ" alt="supertokens-9.png" title="supertokens-9.png" width="3018" height="1580" /><p>As we have no roles yet, as soon as we click <code>Manage Roles</code> we will be prompted to create our first role. Let’s do that!</p><img src="https://media.graphassets.com/IVcOdi0YSACIZY5kEgO1" alt="supertokens-10.png" title="supertokens-10.png" width="3016" height="1576" /><p>We only need one role, an administrator, and we can add a short description of the role.</p><img src="https://media.graphassets.com/z1nbPpXSiCUcfcwibnNY" alt="supertokens-11.png" title="supertokens-11.png" width="1244" height="966" /><p>We created a role! Now what? Now we need to add a resource, something we will be performing an action on — and thus testing if we have the permission to do so.</p><img src="https://media.graphassets.com/qIoEtFmYR92LsM09LiTm" alt="supertokens-12.png" title="supertokens-12.png" width="2514" height="566" /><p>Navigate to the <code>Resources</code> tab at the top, and let’s create a new resource.</p><img src="https://media.graphassets.com/NGBR2IwSQ6WuGnYp3Txu" alt="supertokens-13.png" title="supertokens-13.png" width="3014" height="1574" /><p>The resource will be the restricted page. Either someone with the role of administrator will be able to access it, or not at all. We named the resource <code>restricted-page</code> , and we added just one action; <code>view</code>. Let’s save it.</p><img src="https://media.graphassets.com/tJelUOWTPOgTEa9RX70Y" alt="supertokens-14.png" title="supertokens-14.png" width="1226" height="1302" /><img src="https://media.graphassets.com/ac5vKokoRj21SouAyHqC" alt="supertokens-15.png" title="supertokens-15.png" width="2520" height="528" /><p>Great! We are all good to go to enforce the policy in our code.</p><img src="https://media.graphassets.com/uFTOdfGRSjyID1itZXsU" alt="supertokens-16.png" title="supertokens-16.png" width="2516" height="698" /><h4>2. Enforcing the Permit Policy</h4><p>We need to add some more logic to our <code>authorize.js</code> page. Firstly, let’s enforce that only users who are currently in a session can access this page.</p><p>As you can notice, if the session exists, we print the <code>userId</code>. We will be using that to identify our users within Permit.</p><pre><code>export default async function isAllowed(req, res) {
 await superTokensNextWrapper(
  async (next) =&gt; {
   await verifySession({ sessionRequired: false })(req, res, next);
  },
  req,
  res
 );

 let session = req.session;

 if (session !== undefined) {
  // session exists
  let userId = session.getUserId();
  console.log(&quot;USER_ID: &quot;, userId);
 } else {
  // session doesn&#39;t exist
 }
}</code></pre><p>Now let’s add a function to control the enforcement with <code>permit.check()</code>. Here we are passing in four parameters to the function. The <code>current user ID from the session</code>, the <code>action</code> we are performing, the <code>resource</code> we are performing the action on, and finally, the <code>tenant</code> our user is part of.</p><pre><code>const checkPermission = async (userId) =&gt; {
 const access = await permit.check(
  userId,
  &quot;view&quot;,
  &quot;restricted-page&quot;,
  &quot;default&quot;
 );
 return access;
};</code></pre><p>What is a tenant? It’s a silo of resources and users, which in policy terms, means only users within a tenant can act on the resources within the tenant. Tenants are isolated from one another. You can read more about tenants <a rel="noopener" class="markup--anchor markup--p-anchor" target='_blank' title="https://docs.permit.io/features/multitenancy#tenants-in-permitio" href="https://docs.permit.io/features/multitenancy#tenants-in-permitio">here</a>. The principle is that a user has to be part of a tenant. </p><p>Let’s create a tenant and add our user using the permit no-code dashboard.</p><img src="https://media.graphassets.com/MLw9QfWGQMmbaoLmWwiA" alt="supertokens-17.png" title="supertokens-17.png" width="3018" height="1570" /><p>We can call the tenant <code>default</code>.</p><img src="https://media.graphassets.com/NQ4GGGuvTKqvdKZsSuvX" alt="supertokens-18.png" title="supertokens-18.png" width="1230" height="696" /><p>Now we need to add our user. </p><img src="https://media.graphassets.com/48Vd2MyiQpSvz8bR91Iu" alt="supertokens-19.png" title="supertokens-19.png" width="3018" height="1570" /><p>Here we passed in an email and, most importantly a <code>key</code>. The key is the unique id of the user we have taken from the session. If you run the code, you will be able to fetch your current <code>userId</code> and paste it into the <code>key</code> field.</p><img src="https://media.graphassets.com/mggSsuB1S5y9sP3u4ykL" alt="supertokens-20.png" title="supertokens-20.png" width="1226" height="1060" /><p>Now, let’s add the enforcement login to the current <code>autorize.js</code> code.</p><pre><code>export default async function isAllowed(req, res) {
 await superTokensNextWrapper(
  async (next) =&gt; {
   await verifySession({ sessionRequired: false })(req, res, next);
  },
  req,
  res
 );

 let session = req.session;

 if (session !== undefined) {
  // session exists
  let userId = session.getUserId();
  console.log(&quot;USER_ID: &quot;, userId);

// ############### NEW CODE #################

  // Calling the previously defined function
  const hasAccess = await checkPermission(userId);
  console.log(hasAccess);

  // sending back a status based on the access
  if (hasAccess) {
   res.status(200).send({ id: userId, allowed: hasAccess });
  } else {
   res.status(404).send({ id: userId, allowed: hasAccess });
   return;
  }
 } else {
  // session doesn&#39;t exist
  console.log(&quot;Session does not exist&quot;);
  res.status(401).send(&quot;Unauthorized&quot;);
 }
}</code></pre><p>Finally, let’s edit our <code>/restricted</code> page. This time, we need to call the <code>/api/access/authorize</code> endpoint and based on the result, restrict the access.</p><p>Change the <code>restricted.js</code> code to this:</p><pre><code>import React, { useEffect } from &quot;react&quot;;
import useSWR from &quot;swr&quot;;

export default function Restricted() {
 const fetcher = (url) =&gt; fetch(url).then((res) =&gt; res.json());
 const { data, error } = useSWR(&quot;/api/access/authorize&quot;, fetcher);

 if (error) return &lt;div&gt;failed to load&lt;/div&gt;;
 if (!data) {
  return &lt;div&gt;Loading...&lt;/div&gt;;
 } else {
  if (data.allowed) {
   return &lt;div&gt;Welcome user: {data.id}&lt;/div&gt;;
  } else {
   return &lt;div&gt;User is not an administrator&lt;/div&gt;;
  }
 }
}</code></pre><p>Yay! We are done! Now — let’s test the app!</p><p>If we try to access the restricted page while we are not logged in, we get a <code>failed to load</code> message.</p><img src="https://media.graphassets.com/17Vudl2PSBylo8fhBYWp" alt="supertokens-21.png" title="supertokens-21.png" width="678" height="164" /><p>Now let&#39;s login.</p><img src="https://media.graphassets.com/p4h8OgPITUayP04aIvtJ" alt="supertokens-22.png" title="supertokens-22.png" width="902" height="884" /><p>What will we see now when we try to access the restricted page?</p><img src="https://media.graphassets.com/dVdxAXlRQeNKAYI9oZSN" alt="supertokens-23.png" title="supertokens-23.png" width="720" height="156" /><p>Oh no! It looks scary, but it’s not a problem. As Permit’s UI is so easy to use, we can very quickly change the permission for that user, without adding any extra code.</p><p>Let’s go back to Permit’s Policy Editor. While here, we just need to check the <code>view</code> action for the <code>restricted-page</code> resource, and save the changes!</p><img src="https://media.graphassets.com/hzTC8DuJSsO6FF0c2AkI" alt="supertokens-24.png" title="supertokens-24.png" width="806" height="472" /><p>Let’s go back to the restricted page and see the outcome!</p><img src="https://media.graphassets.com/gxtXA8YBTXumG7zbwR7R" alt="supertokens-25.png" title="supertokens-25.png" width="788" height="180" /><p>Amazing! Congratulations! You have successfully built a passwordless login with SuperTokens and Twilio, and even went as far as implementing basic authorization. </p><p>If you want to learn more about Permit — check out <a rel="noopener" class="markup--anchor markup--p-anchor" target='_blank' title="https://www.permit.io/" href="https://www.permit.io/">Permit.io</a> — otherwise, you can download this whole demo project <a rel="noopener" class="markup--anchor markup--p-anchor" target='_blank' title="https://github.com/filipermit/demo-projects/tree/main/supertokens-twilio-starter" href="https://github.com/filipermit/demo-projects/tree/main/supertokens-twilio-starter">here</a>.</p>]]></content>
        <author>
            <name>Filip Grebowski</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Send Emails via Mailgun’s API directly from the browser]]></title>
        <id>mailgun-foaz</id>
        <link href="https://www.permit.io/blog/mailgun-foaz"/>
        <updated>2023-06-08T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Learn how to send Emails with the Mailgun API directly from the browser using Frontend Only Authorization (FoAz)  - A backendless communication solution.]]></summary>
        <content type="html"><![CDATA[<p>With the evolution of frontend development and the advent of backendless tools, frontend developers now possess significant power to build complete applications without relying on backend code. However, one area that often necessitates backend involvement is enforcing access control for backend-oriented APIs. This is due to the requirement of authenticating these APIs with a secret key that cannot be exposed on the frontend. But there is a solution!<br><br>In this article, we&#39;ll examine <strong>how to utilize </strong><a title="http://permit.io/foaz" href="http://permit.io/foaz"><u><strong>Frontend Only Authorization (FoAz)</strong></u></a> - a new open standard to<strong> use </strong><a title="https://www.mailgun.com/" href="https://www.mailgun.com/"><u><strong>Mailgun</strong></u></a><strong>’s API directly from the frontend</strong>. This will allow us to designate specific users who can send emails with Mailgun without the need for any backend setup.</p><p>Granting the right permissions for sending emails with the use of Mailgun can be a challenge. The integration of Mailgun with FoAz will allow us to directly utilize Mailgun’s API and add an authorization layer on top of it, eliminating the need for time-consuming server modifications or developer involvement.</p><h2>What is Frontend Only Authorization (FoAz)</h2><p><strong>FoAz</strong> accepts API calls, verifies identity, checks for permissions, and adds secrets - allowing secure use of APIs with granular permissions directly from the frontend.<strong> </strong>In this case, FoAz will verify the user&#39;s frontend JWT token, check if they have proper permissions to perform the API call, and then forward the call to the backend API.</p><img src="https://media.graphassets.com/m5Cu3kKUSzye36DvSU2Q" alt="foaz_diagram.png" title="foaz_diagram.png" width="969" height="100" /><p>By using FoAz, we can authenticate our users in the frontend, and then use the same JWT token to authorize them to perform API calls.</p><h2>Why Use Mailgun with FoAz:</h2><p>Integrating Mailgun with Foaz allows users (in our example, marketing managers) to gain direct authorization to send emails. Administrators can define access rules using <a title="https://www.permit.io/" href="https://www.permit.io/"><u>Permit.io</u></a>, granting permission to authorized personnel. This simplifies the process and eliminates the need for server modifications or developer involvement.</p><h2>Example scenario: Sending e-commerce discount coupon codes </h2><p>Our example is set in an e-commerce store with a sales department. Customers often request discount coupons,<strong> which can be created by sales department employees</strong>. However, <strong>only the sales manager</strong> has the authority to send an email to the user with the coupon. <br><br>While we want to create a UI for sending emails, we would also like to keep the permissions model we have on the server side for our users. Having all the permissions streamlined and managed by Permit.io, and the email-sending being handled by the Mailgun service, we’ve got a comprehensive solution that combines the best of both worlds. This combination allows us to grant exclusive email-sending privileges to the sales manager, saving time and ensuring proper access control.</p><p>Let’s see how it’s done.</p><h3>1. Sign up to Mailgun</h3><img src="https://media.graphassets.com/Ld7gF4rvS2OlRIUKWDGw" alt="1.png" title="1.png" width="1600" height="790" /><p>If you have signed up for Mailgun&#39;s service, you can click on login and connect. If not, <a title="https://www.mailgun.com/de/" href="https://www.mailgun.com/de/"><u>sign up for the service now</u></a>.</p><h3>2. Find your API key</h3><p>To send an email with Mailgun we need to send a <strong>post request</strong> with a <strong>private API key</strong>. To get those, click <strong>Overview:</strong></p><img src="https://media.graphassets.com/mifwSpgfSAm7GRmhs0gk" alt="12.png" title="12.png" width="1565" height="549" /><p><br></p><img src="https://media.graphassets.com/BfN4fSxcQ1S2E9L4cujk" alt="2.png" title="2.png" width="1496" height="900" /><p>Now that we have a private API key and we know how to create an API request, we will connect to Permit.</p><h3>3. Sign up to Permit</h3><p>Go to <a title="https://app.permit.io/" href="https://app.permit.io/"><u>app.permit.io</u></a> <br>If you are not registered, please register; <a title="https://www.permit.io/blog/rbac-with-permit" href="https://www.permit.io/blog/rbac-with-permit"><u>it&#39;s really easy</u></a>. After onboarding or logging in, we need to define our users and assign them authorization policies. </p><h3>4. Setup some basic application-level roles and resources </h3><ul><li><div><p><strong>Define roles:</strong><br><br>For the purpose of this tutorial, we will create 2 roles: <br>a role designated for the <strong>Head of Sales</strong>, titled “sales_sdmin,” and a second role designated for the <strong>Sales Representatives</strong>, titled “salesperson”.  <br><br>To create new roles, go to the <strong>Policy </strong>screen, Click <strong>Roles</strong>, and <strong>Add Role</strong>. <br><br>Note:<br><br>In this example, we have translated our <strong>organization-level roles</strong> into <strong>application-level roles</strong>. This will be done differently for every application, and it is up to you to decide how this role translation should be done. To learn more about planning role-based access control (RBAC) for your application, <a title="https://www.permit.io/blog/planning-app-rbac" href="https://www.permit.io/blog/planning-app-rbac"><u>check out this blog</u></a>. <br></p><img src="https://media.graphassets.com/birotmtsS2WmcfndXdas" alt="4.png" title="4.png" width="848" height="244" /><p>With our roles defined, let’s define some <strong>resources</strong>. </p></div></li></ul><ul><li><div><p><strong>Define Resources:<br><br></strong>In the <strong>Policy </strong>screen, Click <strong>Resources</strong>, and <strong>Create a Resource</strong>. <br><br>Create a resource named “coupon”. <br><br>Each resource has <strong>actions </strong>that can be performed on it. For the purpose of this tutorial, we will be adding a “share” action, and, in the next step, restrict it to the “sales_admin” role. <br><br>You can, of course, create additional actions (Such as “create”, “edit”, “view,” or anything else applicable in your use-case) and assign them to other roles, as can be seen in the screenshot:</p><img src="https://media.graphassets.com/yw9AuE0QAa4dS3pevjyQ" alt="10.png" title="10.png" width="592" height="626" /><p></p></div></li></ul><ul><li><div><p><strong>Define a Policy <br><br></strong>Now that we have a <strong>User</strong>, <strong>Resource, </strong>and <strong>Action</strong>, it’s time to create an authorization policy. <br><br>Go to the <strong>Policy </strong>screen, to set your sales_admin to be able to share a coupon. It’s as easy as checking a checkbox 🙂<br><br></p><img src="https://media.graphassets.com/2SxGSZEJQxOwJvEkpVTz" alt="11.png" title="11.png" width="246" height="706" /><p><br>In the screenshot, you can see the sales_admin can create, edit, share and view a coupon, while a salesperson can only view it. </p></div></li></ul><h3>5. Set up FoAz</h3><p>Now that we have basic RBAC setup, it is time to connect Permit to Mailgun through FoAz:</p><ul><li><div><p>Go to the FoAz Proxy screen. </p></div></li><li><div><p>If you receive the following prompt:<br><br>“There are no JWKs configured to this environment. In order to enable FoAz you need to make sure you have JWKs configured”. </p><img src="https://media.graphassets.com/tcPP21jTjiwXSwsCP7Uw" alt="9.png" title="9.png" width="1146" height="228" /><p>Click “JWKS configured”, and add the relevant configuration for your JWKs per environment and project. <a title="https://docs.permit.io/foaz/fetching-jwks/#what-are-jwks" href="https://docs.permit.io/foaz/fetching-jwks/#what-are-jwks"><u>Learn more about JWKs here</u></a>.</p><img src="https://media.graphassets.com/ExAiXGxXQpGkBROjDcNE" alt="8.png" title="8.png" width="1594" height="339" /></div></li></ul><ul><li><div>Fill out the FoAz form in the following order:<br>Proxy Name<strong><br>Proxy Request URL</strong> - Fill in <a title="https://documentation.mailgun.com/en/latest/api-intro.html#base-url-1" href="https://documentation.mailgun.com/en/latest/api-intro.html#base-url-1"><u>Mailgun’s base API URL</u></a><br><strong>HTTP method</strong> - select POST<br><strong>Resource</strong> - select “coupon”<br><strong>Action </strong>- select “share”<br><strong>Secret configuration</strong> - Under “Authentication Mechanism” select <strong>Basic</strong>, under User write “API”, and in Password fill in your MailGun API key.<br><br></div><div><img src="https://media.graphassets.com/FFQnSFOMTK28Jc3EXRfM" alt="7.png" title="7.png" width="857" height="427" /></div></li></ul><ul><li><div>Click “Create” in the top right corner.</div></li><li><div>Once the form is full and saved, click “Example Code &lt;&gt;” in the top right corner</div></li></ul><img src="https://media.graphassets.com/DpWleQd6T2C6e523xjgz" alt="1.png" title="1.png" width="231" height="47" /><h3>6. Create a request</h3><img src="https://media.graphassets.com/HRZQPONrS1OteCFSr24D" alt="5.png" title="5.png" width="883" height="523" /><p>To create your proxy request based on the example code:</p><ul><li><div><p>Replace <strong>HTTP_METHOD</strong> with POST</p></div></li><li><div><p>In <strong>USER_JWT</strong> add the token compatible with the defined JWKs</p></div></li><li><div><p>In <strong>PROXIED_URL</strong>,<strong> </strong>copy the API base URL from Mailgun.<br><br>This is a basic example of using FoAz, but we need to provide additional information in both the body and the header of the request. This information includes details like the sender&#39;s name, the email subject, and more.<br><br>This code is a sample JavaScript code that you can integrate into your front-end application. Its purpose is to send an email containing a coupon code by utilizing the integration between FOAZ and Mailgun:</p></div></li></ul><ul><li><div><pre><code>const sendCoupon = () =&gt; {
    const myHeaders = { Authorization: TOKEN };
   
    const formData = new FormData();
    formData.append(
      &#39;from&#39;,
      &#39;Excited User &lt;mailgun@ggggbbbb.org&gt;&#39;
    );
    formData.append(&#39;to&#39;, &#39;exppp@gmail.com&#39;);
    formData.append(&#39;subject&#39;, &#39;Hello Permit&#39;);
    formData.append(&#39;text&#39;, &#39;Coupon= 1234556&#39;);
   
    fetch(`https://proxy.api.permit.io/proxy/${FOAZ_ID}?url=${URL_MAILGUN}`, {
      method: &#39;POST&#39;,
      headers: myHeaders,
      body: formData,
      redirect: &#39;follow&#39;,
    })
      .then((response) =&gt; response.text())
      .then((result) =&gt; console.log(result))
      .catch((error) =&gt; console.log(&#39;error&#39;, error));
   };</code></pre></div></li></ul><h2>Conclusion</h2><p>In this article, we discovered the simplicity of connecting our frontend application directly to Mailgan in a secure manner, with the added benefit of user-based permissions, all thanks to FoAz. This approach has allowed us to save valuable time in server development and significantly expedite our development process within the company.</p><p>FoAz is not limited to Email sending. You can use FoAz to access any API that requires authentication, and you can use it to build a complete application without any backend code. </p><p>Want to stay in touch and contribute to the revolution of frontend development? <a title="https://io.permit.io/permitslack" href="https://io.permit.io/permitslack"><u>Join our community</u></a>.</p>]]></content>
        <author>
            <name>Shuvy Ankor </name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Google Zanzibar vs OPA - Graph vs. Code Based Authorization]]></title>
        <id>zanzibar-vs-opa</id>
        <link href="https://www.permit.io/blog/zanzibar-vs-opa"/>
        <updated>2023-06-07T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Graph-based or policy-as-code? Explore access control systems in this comparative analysis. Discover pros, cons, and a hybrid solution.]]></summary>
        <content type="html"><![CDATA[<h2>Introduction</h2><p>In today&#39;s data-driven world, managing access control and authorization in software systems is paramount. Achieving this task with precision, scalability, and flexibility is no mean feat, considering the multitude of complex relationships and high volumes of data to handle. This blog post dives into a comparative analysis of graph-based and policy-as-code authorization systems, showcasing their pros and cons in diverse scenarios. Our spotlight will be on renowned systems like <a target='_blank' title="https://zanzibar.academy/" href="https://zanzibar.academy/"><u>Google Zanzibar</u></a>, <a target='_blank' title="https://github.com/authzed/spicedb" href="https://github.com/authzed/spicedb"><u>SpiceDB</u></a>, <a target='_blank' title="https://www.ory.sh/keto/" href="https://www.ory.sh/keto/"><u>Ory Keto</u></a>, <a target='_blank' title="https://github.com/openfga/openfga" href="https://github.com/openfga/openfga"><u>OpenFGA</u></a>, <a target='_blank' title="https://github.com/open-policy-agent/opa" href="https://github.com/open-policy-agent/opa"><u>Open Policy Agent</u></a>, <a target='_blank' title="https://www.osohq.com/" href="https://www.osohq.com/"><u>OSO</u></a>, and <a target='_blank' title="https://www.cedarpolicy.com/en" href="https://www.cedarpolicy.com/en"><u>AWS Cedar</u></a>.</p><h2>Graph-Based Authorization Systems</h2><p>Graph-based authorization systems employ a graphical representation to illustrate relationships between users and resources. They excel at mapping hierarchies and nested relationships, offering a natural avenue for Relationship-based Access Control (ReBAC). Given their ability to manage high volumes of data while maintaining consistency, these systems prove effective in large-scale environments.</p><p>The inception of graph-based authorization systems can be traced back to Google Zanzibar. Renowned for its distributed, scalable, and consistent architecture, Zanzibar serves as Google&#39;s gatekeeper for access control. Underpinning Zanzibar is a graph data model and a distributed consensus algorithm ensuring consistent authorization decisions across the board.</p><p>Drawing inspiration from Zanzibar, there’s SpiceDB - a mature open-source graph-based authorization system. Extending beyond the original specifications of Zanzibar, SpiceDB introduces features such as Caveats and adopts the role of a permissions database, emphasizing its centrality in the authorization domain.</p><p>Despite their advantages, deploying a Zanzibar-based graph invariably introduces a sizable and complex system into your cloud environment, often necessitating reliance on a hosted service. This dependency can instigate latency concerns and further scaling challenges.</p><h2>Policy as Code Authorization Systems</h2><p>In contrast to graph-based systems, <a title="https://www.permit.io/blog/what-is-policy-as-code" href="https://www.permit.io/blog/what-is-policy-as-code"><u>policy-as-code</u></a> authorization utilizes code to define authorization policies, facilitating their modification and offering a higher degree of flexibility. They effectively handle complex rules and relationships, with Open Policy Agent (OPA) and AWS Cedar being prime examples.</p><p>OPA, popular across numerous organizations, employs a declarative policy language (Rego) that simplifies the definition of complex authorization policies. AWS Cedar, on the other hand, focuses on application-level authorization, providing a simple policy language that promotes easy readability and analyzability.</p><h2>Weighing the Pros and Cons</h2><p>When choosing between graph-based and policy-as-code systems, understanding their strengths and limitations is critical.</p><p>Graph-based systems shine in scenarios requiring ReBAC and are adept at describing hierarchical and nested relationships. They ensure data consistency even in high-volume scenarios and offer reverse indices, enabling reverse queries (not only does x have access to y, but also who has access to y).</p><p>However, they do come with drawbacks. Compared to policy-as-code, graph-based systems exhibit lower performance and are practically unfeasible to run at the edge due to their size. They also come with higher latency, owing to their non-local nature, and are limited to simple ReBAC policies (even SpiceDB Caveats you end up with a limited form of ABAC, crippled even further with loading dynamic data).</p><p>Policy-as-code systems, on the other hand, offer great flexibility and ease of policy update. They&#39;re adept at managing complex policies like <a title="https://www.permit.io/blog/what-is-abac" href="https://www.permit.io/blog/what-is-abac"><u>ABAC</u></a> and boast a mature ecosystem with a variety of plugins and engines. Despite these advantages, they have their limitations. These systems can struggle with high volumes of data without appropriate sharding, require learning complex languages, and do not support reverse indices.</p><h3>Table Summary:</h3><table><tbody><tr><td><p></p></td><td><p><strong>Graph-Based Authorization</strong></p></td><td><p><strong>Policy-as-Code Authorization</strong> </p></td></tr><tr><td><p><strong>Nature of Access Control</strong></p></td><td><p>Natural fit for Relationship-based Access Control (ReBAC)</p></td><td><p>Excels at managing complex policies (e.g., ABAC)</p></td></tr><tr><td><p><strong>Representation of Relationships</strong></p></td><td><p>Excellent for representing hierarchies and nested relationships</p></td><td><p>Flexible and can manage complex relationships, but not inherently hierarchical</p></td></tr><tr><td><p><strong>Data Volume Management</strong></p></td><td><p>Manages high volumes of data consistently</p></td><td><p>Can struggle with large amounts of data without sharding</p></td></tr><tr><td><p><strong>Reverse Indices</strong></p></td><td><p>Supports reverse indices</p></td><td><p>Does not support reverse indices</p></td></tr><tr><td><p><strong>Performance</strong></p></td><td><p>Lower performance compared to policy-as-code</p></td><td><p>Generally high performance</p></td></tr><tr><td><p><strong>Deployment at Edge</strong></p></td><td><p>Practically impossible due to size</p></td><td><p>Feasible and efficient</p></td></tr><tr><td><p><strong>Latency</strong></p></td><td><p>Higher due to non-locality</p></td><td><p>Lower due to local deployment</p></td></tr><tr><td><p><strong>Ease of Updates</strong></p></td><td><p>Less flexible for updates</p></td><td><p>Highly flexible and easy to update</p></td></tr><tr><td><p><strong>Ecosystem</strong></p></td><td><p>Emerging ecosystem</p></td><td><p>Robust ecosystem with plugins and multiple engines</p></td></tr><tr><td><p><strong>Learning Curve</strong></p></td><td><p>Moderate</p></td><td><p>Can be high due to complex languages</p></td></tr></tbody></table><h2>Deciding Factor: Scale vs. Complexity</h2><p>In our experience, the choice between these two primarily hinges on the scale and complexity of the system in question. For systems catering to fewer than 1 million users requiring complex policies, policy-as-code is a leading option. For those catering to more than 1 million users and relying on simpler policies, graph-based systems are a better fit.</p><h2>Why Not Both?</h2><p>But who said you must choose? These systems are highly complementary; where one struggles, the other excels. Marrying these two approaches via an event-driven link like <a target='_blank' title="https://github.com/permitio/opal" href="https://github.com/permitio/opal">OPAL</a>, topped with abstraction interfaces, provides the best of both worlds. You can leverage a reverse-indexable graph-based database in the cloud as a primary data source, feeding policy-as-code engines at the edge. This configuration allows for complex policy implementation, reduced latency, and consistent large-scale data management, offering a hybrid, versatile solution to the ever-evolving authorization conundrum.</p><h2>Conclusion</h2><p>In the vast realm of authorization systems, there is no one-size-fits-all solution. The choice between graph-based systems like Google Zanzibar or <a target='_blank' title="https://github.com/authzed/spicedb" href="https://github.com/authzed/spicedb">SpiceDB</a> and policy-as-code systems like <a target='_blank' title="https://github.com/open-policy-agent/opa" href="https://github.com/open-policy-agent/opa">Open Policy Agent</a> or <a target='_blank' title="https://github.com/permitio/cedar-agent" href="https://github.com/permitio/cedar-agent">AWS Cedar</a> is not about picking the superior technology, but rather about aligning your selection with the specific needs, scale, and complexity of your environment.</p><p>While graph-based systems excel in managing high volumes of data and effectively representing relationships in large-scale applications, policy-as-code systems bring flexibility, ease of policy updates, and proficiency in handling complex policies. Each has its strengths and shortcomings and should be chosen after a careful analysis of the system requirements and the trade-offs you&#39;re willing to accept.</p><p>Moreover, it&#39;s crucial to remember that these systems can be complementary. They can be combined to create a hybrid system that leverages the advantages of both, thereby addressing diverse authorization needs. In the end, the goal is to effectively control access to your services, ensure data privacy, and maintain system integrity, regardless of the authorization strategy you choose.</p>]]></content>
        <author>
            <name>Or Weis</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Send SMS Directly from the Browser (No Backend Code Required!)]]></title>
        <id>send-sms-from-the-browser-no-backend-code-required</id>
        <link href="https://www.permit.io/blog/send-sms-from-the-browser-no-backend-code-required"/>
        <updated>2023-05-31T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Learn how to send SMS messages directly from the browser using Frontend Only Authorization (FoAz) standard. Backendless communication solution.]]></summary>
        <content type="html"><![CDATA[<h2>Do More With Frontend</h2><p>With just frontend code, frontend developers today have a great deal more power. It&#39;s not just about new browser APIs, but also about backendless tools that let you build complete applications without any backend code. However, there&#39;s still one area where backend code is required: backend-oriented APIs that need access control enforcement. The reason for that is that those APIs need to be authenticated with a secret key that cannot be exposed in the frontend. But guess what? There’s a solution for that. </p><p>In this article, we&#39;ll explore an awesome new way to use backend APIs that are often needed as a feature in frontend applications. We&#39;ll learn how to send SMS (or messages on WhatsApp, Viber, and Facebook Messenger) directly from the browser. To authenticate our users in the browser, we&#39;ll use <a title="https://clerk.dev/" href="https://clerk.dev/"><u>Clerk.dev</u></a>, and for managing their permissions to send messages using <a title="https://www.vonage.com/" href="https://www.vonage.com/"><u>Vonage</u></a> APIs, we&#39;ll rely on Permit.io. So let&#39;s dive in and see how it&#39;s done!</p><h2>Frontend Only Authorization</h2><p>The approach we will take in this article to authorize our users to send messages is called <a title="http://permit.io/foaz" href="http://permit.io/foaz"><u>Frontend Only Authorization (FoAz)</u></a>, an open standard created by Permit.io. FoAz is based on a proxy service that verifies the user&#39;s frontend JWT token, checks if they have proper permissions to perform the API call, and then forwards the call to the backend API.</p><p></p><img src="https://media.graphassets.com/m5Cu3kKUSzye36DvSU2Q" alt="foaz_diagram.png" title="foaz_diagram.png" width="969" height="100" /><p>By using FoAz, we can authenticate our users in the frontend, and then use the same JWT token to authorize them to perform API calls. Let&#39;s start the tutorial by setting up our application.</p><h2>Setup the Application</h2><p>For building our application, we will use the React framework. You don&#39;t need any prior knowledge of react to follow along, as the code is short, and we will explain it as we go.</p><p>Note: <em>You&#39;ll need a local </em><a title="https://nodejs.org/en/download" href="https://nodejs.org/en/download"><em>installation of node.js and npm</em></a><em> to continue with the tutorial.</em></p><p><a title="https://github.com/permitio/foaz-vonage-sample" href="https://github.com/permitio/foaz-vonage-sample"><em>Tutorial code repository</em></a></p><p>First, let&#39;s create a new React app by using <a title="https://vitejs.dev/" href="https://vitejs.dev/"><u>Vite</u></a>, a fast-build tool for modern web apps. Open your terminal and run the following command in your desired projects directory:</p><pre><code>npm create vite@latest frontend-messages-demo --template react \
    &amp;&amp; cd frontend-messages-demo \
    &amp;&amp; npm install</code></pre><p>This will create a new react app in the frontend-messages-demo directory.</p><p>We can see our app by running the following command:</p><pre><code>npm run dev</code></pre><p>This will start a local development server and open a browser window with our app.</p><h2>Setup Authentication in the App</h2><p>As a first step to access control, we will need a way to authenticate our application users, so we can verify their identity. For this, we will use <a title="https://clerk.dev/" href="https://clerk.dev/"><u>Clerk.dev</u></a>, a frontend-first authentication platform that lets you add authentication to your application in minutes. Clerk offers a free tier that is more than enough for our needs, let&#39;s go to <a title="https://dashboard.clerk.com/sign-up" href="https://dashboard.clerk.com/sign-up">https://dashboard.clerk.com/sign-up</a> and create an account there. Let&#39;s set up our newly created Vite app to use Clerk.dev for authentication.</p><ol><li><div><p>Go to <a target='_blank' title="https://dashboard.clerk.com" href="https://dashboard.clerk.com">Clerk.com</a> dashboard</p></div></li><li><div><p>In the Clerk dashboard, click on Add Application</p><img src="https://media.graphassets.com/Q1XGH8VTXmNTLgNobsRx" alt="clerk_add_application.png" title="clerk_add_application.png" width="552" height="611" /></div></li><li><div><p>Give your application a name, and click Create Application (I named mine <code>Frontend Messages Demo</code>)</p><img src="https://media.graphassets.com/Mzm3TNuVRkSZiRjujIsI" alt="clerk_create_application.png" title="clerk_create_application.png" width="1438" height="884" /></div></li><li><div><p>In the next screen, choose the React option, and copy the key that shows up.</p><img src="https://media.graphassets.com/LFDWiVTwOY77KbKDioAz" alt="clerk_react.png" title="clerk_react.png" width="1052" height="579" /></div></li><li><div><p>In our React app, create a new file in the root folder called .env and add the following line to it (It is important to add the VITE_ prefix to the variable name, as Vite will use it to inject the variable into our app):</p><pre><code>VITE_CLERK_FRONTEND_API_KEY=&lt;YOUR_API_KEY_HERE&gt;</code></pre></div></li><li><div><p>In the same folder, run the following command on your terminal to install the Clerk SDK:</p><pre><code>npm install @clerk/clerk-react</code></pre></div></li></ol><p>Now that we have setup the Clerk account in our application, it is time to test the user authentication.</p><ol><li><div><p>In the App.tsx file, remove the whole content of the return section of the App function and replace it with the following code:</p><pre><code>function App() {
    return (
        &lt;&gt;
            &lt;ClerkProvider publishableKey={clerkPubKey}&gt;
                &lt;SignedIn&gt;
                    &lt;SendMessage /&gt;
                &lt;/SignedIn&gt;
                &lt;SignedOut&gt;
                    &lt;RedirectToSignIn /&gt;
                &lt;/SignedOut&gt;
            &lt;/ClerkProvider&gt;
        &lt;/&gt;
    )
}</code></pre></div></li><li><div><p>At the top of the file, before the App function, let&#39;s paste the following code that will create an empty component to verify our users&#39; login status and add the required imports to the file:</p><pre><code>import { ClerkProvider, RedirectToSignIn, SignedIn, SignedOut, useAuth, useClerk } from &#39;@clerk/clerk-react&#39;

const clerkPubKey = import.meta.env.VITE_REACT_APP_CLERK_PUBLISHABLE_KEY;

function SendMessage() {
    const { isSignedIn, getToken } = useAuth();
    const { signOut } = useClerk();

    if (!isSignedIn) {
        return null;
    }

    return (
        &lt;div&gt;
            &lt;h1&gt;Hello&lt;/h1&gt;
            &lt;button onClick={() =&gt; signOut()}&gt;Sign Out&lt;/button&gt;
        &lt;/div&gt;
    )
}</code></pre></div></li><li><div><p>Going now back to the browser, we can see that the app is now showing a login screen.</p><img src="https://media.graphassets.com/ySUTHAnzTLWXlh8H0vF7" alt="clerk_login.png" title="clerk_login.png" width="1484" height="1804" /></div></li><li><div><p>Let&#39;s go back to Clerk and create two users in the `Users` screen to mock our permission model with two users. For the example, let&#39;s used the following emails: <code>admin@messaging-foaz.app </code>and <code>user@messaging-foaz.app</code> (choose any password you want).</p><img src="https://media.graphassets.com/o8lJlPMlT2aO6aIJV8XV" alt="clerk_users.png" title="clerk_users.png" width="2854" height="910" /></div></li><li><div><p>With the users created, let&#39;s go back to our newly created app and login with one of the users, and check that we see the correct name in the app.</p></div></li></ol><p>At this point, we have our users authenticated, and we can start working on the permissions model.</p><h2>Setting Up Permissions for Sending SMS</h2><p>Now that we have our users authenticated, we need to setup the permissions for sending messages. Let&#39;s say that our application has two kinds of users: admins and regular users. We want to allow admins to send messages and deny regular users from sending messages.</p><p>Let&#39;s configure the API call to Vonage in Permit.io to allow admins to send messages.</p><h3>Get API Secret from Vonage</h3><p>Sending an SMS is something that requires a service provider, and in this tutorial, we will use Vonage. Vonage is a cloud communications platform that offers APIs for SMS, voice, and video.</p><p>After signing up, you will need to create a new API key and secret. You can find your Vonage API key and secret in the <a title="https://dashboard.nexmo.com/" href="https://dashboard.nexmo.com/">Vonage dashboard</a>.</p><img src="https://media.graphassets.com/MgDCUhQTp6onmLWuYRlz" alt="vonage_dashboard.png" title="vonage_dashboard.png" width="840" height="233" /><h3>Configure the API Call Permissions in Permit.io</h3><p>To use FoAz, we will need to setup the particular SMS sending API call to Vonage in Permit.io, and let users perform that call only if they have the right permissions. If you are not a Permit.io user yet, go to <a target='_blank' title="https://app.permit.io/" href="https://app.permit.io/">app.permit.io</a> and create a free account.</p><p>After signing in, you&#39;ll have to go to FoAz Proxy page and click Add Configuration.</p><p>This is how the configuration page should look like:</p><img src="https://media.graphassets.com/Zm6QcASISGKPmJ0UU64D" alt="proxy_config.png" title="proxy_config.png" width="2960" height="1222" /><p>Let&#39;s go over the fields to make sure we understand what we are doing here:</p><ol><li><div><p>In the URL field, enter <code>api.nexmo.com/v1/messages</code>. This is the API endpoint we will use to send messages.</p></div></li><li><div><p>In the <code>HTTP Method</code> field, select <code>POST</code>. This is the HTTP method we will use to send messages.</p></div></li><li><div><p>In the <code>Select Resource</code> field, choose to create a new resource and call it <code>Message</code>. This is the name of the resource we will use to give permissions.</p></div></li><li><div><p>When you create the resource, also assign one action to it. Let&#39;s call it <code>Send</code>.</p></div></li><li><div><p>After creating the resource, Choose the <code>Send</code> action in the <code>Select Action</code> field.</p></div></li><li><div><p>In the <code>Secret Configuration</code> field, choose <code>Basic</code> and insert the API key and secret you got from Vonage in the relevant fields.</p></div></li></ol><p>At this point, we configure the FoAz proxy to support our call to Vonage, we can now configure the permissions for our users.</p><h3>Assigning Permissions to Users</h3><p>One of the easiest methods to check if a user has permission to perform an action is to use the Role-Based Access Control (RBAC) model. In RBAC, we assign role(s) to users, and then we can define which roles can perform which actions on which resources.</p><ol><li><div><p>In the Permit.io Policy page, go to the Roles tab and create two roles: Admin and User.</p><img src="https://media.graphassets.com/0XbGhU81QGKUNgEvczCH" alt="roles_permit.png" title="roles_permit.png" width="2462" height="746" /></div></li><li><div><p>Let&#39;s go to the Clerk dashboard, and find the User ID of the admin user we created earlier. You can find the User ID in the User Profile page.</p><img src="https://media.graphassets.com/InQfAExCTk2XD8OIiSIP" alt="copy_user_id.png" title="copy_user_id.png" width="2678" height="920" /></div></li><li><div><p>In Permit.io, go to the Users tab and create a new user with the User ID of the admin user we found in the previous step, and assign the Admin role to the user.</p><img src="https://media.graphassets.com/ZRa305T6TD2x2ZRetInE" alt="permit_create_user.png" title="permit_create_user.png" width="2958" height="1306" /></div></li><li><div><p>Repeat the previous two steps for the regular user we created earlier, but assign the User role to the user.</p></div></li></ol><p>Now that we have our users and roles, we can assign permissions to them. In Permit.io, go to the Policy Editor. In the Admin check the box next to the Send action we created earlier for the Message resource.<br></p><img src="https://media.graphassets.com/L6BddS5R2aKdEywfFVki" alt="Screenshot 2023-05-31 at 16.48.37.png" title="Screenshot 2023-05-31 at 16.48.37.png" width="822" height="529" /><h3>Configure Clerk JWKs in Permit.io</h3><p>Now, that we have all our permissions configured, we need to configure the way that Permit.io will verify the JWT token that Clerk generates for our users. With our users authenticated, Clerk generates a JWT token for them. Permit.io is using Clerk JWKs to verify the JWT token, so we need to configure the JWKs in Permit.io.</p><ol><li><div><p>In the Clerk dashboard, go to <code>JWT Template</code> page and click <code>New Template</code>. This template will use to configure JWTs that are generated for FoAz.</p><img src="https://media.graphassets.com/yoJiliyxQgKkJ5pxj2C0" alt="clerk_new_template.png" title="clerk_new_template.png" width="758" height="433" /></div></li><li><div><p>In the popup opened, click <code>Blank</code> </p><img src="https://media.graphassets.com/zRL6ptzQQqGHfoBolgaQ" alt="jwt_template_blank.png" title="jwt_template_blank.png" width="2356" height="1406" /></div></li><li><div><p>Give our token a name and leave all the other fields with their default values.</p><img src="https://media.graphassets.com/kLBuf2EcRbm2jVUoPMhR" alt="jwt_template_new.png" title="jwt_template_new.png" width="2246" height="1168" /></div></li><li><div><p>Copy the <code>JWKS Endpoint</code> URL and open it in a new tab.</p></div></li><li><div><p>In Permit.io, Go to the <code>Settings</code> screen, and then in the <code>JWKs Config</code> tab, click <code>Configure</code> on the Environment you use (you can see the active environment in the left sidebar)</p><img src="https://media.graphassets.com/a7L4IRtkT9eqysPc12L3" alt="configure_jwk_permit.png" title="configure_jwk_permit.png" width="2256" height="714" /></div></li><li><div><p>In the popup, paste the content from the JWKS Endpoint page we opened in the previous step, and click <code>Save</code>. </p><img src="https://media.graphassets.com/bAtkcLQHRe6eu85YrS7C" alt="configure_jwks_popup.png" title="configure_jwks_popup.png" width="1444" height="1290" /></div></li></ol><p>Now that we are done will the configuration, let&#39;s go back to our application code and send our first message!</p><h2>Sending Messages from the Browser</h2><p>First, to send a message, let&#39;s create the UI components that will use as a form for sending messages. To make our UI look nicer, we will install Material UI, a popular React UI framework for fancy UI components.</p><p>In the terminal, run the following command to install Material UI:</p><pre><code>npm install @mui/material @emotion/react @emotion/styled --save</code></pre><p>Now, let&#39;s create the UI components for sending messages. In the SendMessage function in App.tsx file, replace the return statement of the function with the following code:</p><pre><code>&lt;&gt;
    &lt;Container maxWidth=&quot;sm&quot;&gt;
        &lt;Paper component={&#39;form&#39;} sx={{ p: 1 }} onSubmit={send}&gt;
            {error &amp;&amp; &lt;Alert severity=&#39;error&#39; sx={{ mb: 1 }} onClose={() =&gt; (setError(&#39;&#39;))}&gt;{error}&lt;/Alert&gt;}
            {success &amp;&amp; &lt;Alert severity=&#39;success&#39; sx={{ mb: 1 }} onClose={() =&gt; (setSuccess(&#39;&#39;))}&gt;{success}&lt;/Alert&gt;}
            &lt;Box sx={{ display: &#39;flex&#39; }}&gt;
                &lt;FormControl sx={{ mb: 1, flex: 1 }}&gt;
                    &lt;TextField label=&#39;To&#39; id=&quot;to&quot; value={to} onChange={(e) =&gt; setTo(e.target.value)} /&gt;
                &lt;/FormControl&gt;
            &lt;/Box&gt;
            &lt;Box sx={{ display: &#39;flex&#39; }}&gt;
                &lt;FormControl sx={{ m: 0, minWidth: 200, flex: 1 }}&gt;
                    &lt;TextField label=&#39;message&#39; id=&quot;message&quot; multiline rows={4} value={message} onChange={(e) =&gt; setMessage(e.target.value)} /&gt;
                &lt;/FormControl&gt;
            &lt;/Box&gt;
            &lt;Button variant=&quot;contained&quot; type=&quot;submit&quot; fullWidth sx={{ mt: 1 }}&gt;Send&lt;/Button&gt;
        &lt;/Paper&gt;
        &lt;Button variant=&#39;outlined&#39; fullWidth sx={{ mt: 1 }} onClick={() =&gt; (signOut())}&gt;Sign Out&lt;/Button&gt;
    &lt;/Container&gt;
&lt;/&gt;</code></pre><p>In the top of the function, add the following assignemetns and an empty send function:</p><pre><code>const [error, setError] = useState &lt; string | null &gt; (&#39;&#39;);
const [success, setSuccess] = useState &lt; string | null &gt; (&#39;&#39;);
const [to, setTo] = useState &lt; string &gt; (&#39;&#39;);
const [message, setMessage] = useState &lt; string &gt; (&#39;&#39;);

const send = async (e: FormEvent&lt;HTMLFormElement&gt;) =&gt; {};</code></pre><p>Going back to the browser, you should see a message sending form like this:</p><img src="https://media.graphassets.com/K0B3sjpjSjSrmEsrrSMB" alt="message_form.png" title="message_form.png" width="1128" height="628" /><p>Now, let&#39;s fill the code that will send the message. In the App.tsx file, add the following code to the SendMessage function (<a title="https://github.com/permitio/foaz-vonage-sample/blob/main/src/App.tsx" href="https://github.com/permitio/foaz-vonage-sample/blob/main/src/App.tsx">you can see the whole file version here</a>):</p><pre><code>e.preventDefault();
const token = await getToken();
if (!token) {
    setError(&#39;No token&#39;);
    return;
}
try {
    const res = await fetch(&#39;PASTE_YOUR_URL_FROM_FOAZ_CONFIG&#39;, {
        method: &#39;POST&#39;,
        headers: {
            &#39;Content-Type&#39;: &#39;application/json&#39;,
            &#39;Authorization&#39;: `Bearer ${token}`,
        },
        body: JSON.stringify({
            from: &#39;14157386102&#39;,
            to,
            text: message,
            channel: &#39;sms&#39;,
            message_type: &#39;text&#39;,
        }),
    });
    if (res.status !== 202) {
        const body = await res.json();
        setError(body?.detail || &#39;Error sending message&#39;);
        return;
    }
    setSuccess(&#39;Message sent&#39;);
} catch (error: any) {
    setError(error.message);
    return;
}</code></pre><p>As you can see, the fetch function we added, is empty. We should grab the fetch config from Permit.io proxy settings. You can get the code easily by clicking the copy button on the FoAz proxy page, and pasting it in the code.</p><img src="https://media.graphassets.com/OJkIg0HgSGytRcSxI9k7" alt="copy_sample.png" title="copy_sample.png" width="2258" height="1148" /><p>Returning to the browser, let&#39;s try to send a message.</p><p></p><img src="https://media.graphassets.com/ncY7zbTQtit60vHRXMNn" alt="success_message.png" title="success_message.png" width="1152" height="730" /><p>And, it works!</p><p>To ensure our safety with FoAz permissions, let&#39;s log out with the admin user and log in with another user who doesn&#39;t have a role in Permit.io (you can use the user@foaz-messaging.app user we created earlier).</p><p>Now, when we try to send a message, it fails!</p><p></p><img src="https://media.graphassets.com/ilR2dn5lQzKaaShwYbsZ" alt="failed_message.png" title="failed_message.png" width="1150" height="780" /><p>🥳 Congratulations! You just sent your first message from the browser without any backend code!</p><h2>What Next?</h2><p>In this article, we touched on just the tip of what FoAz can do. Even if we continue with the SMS-sending example, there are many things we can do to improve our application. Sending messages in different channels and limiting the send only for particular users, limiting roles to send only to particular countries, and more.</p><p>But, FoAz is not limited to SMS sending. You can use FoAz to access any API that requires authentication, and you can use it to build a complete application without any backend code. And you can use it with any frontend framework, not just React.</p><p>We hope you enjoyed this article and are already thinking about how you can use FoAz in your next project. To stay in touch and contribute to the revolution of frontend development, join our <a title="https://io.permit.io/permitslack" href="https://io.permit.io/permitslack">Slack community</a>.</p>]]></content>
        <author>
            <name>Gabriel L. Manor</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Introducing FoAz: Frontend-only-Authorization]]></title>
        <id>foaz</id>
        <link href="https://www.permit.io/blog/foaz"/>
        <updated>2023-05-31T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Introducing FoAz - Use Secure APIs directly from the Frontend]]></summary>
        <content type="html"><![CDATA[<p>We are thrilled to announce the launch of a game-changing new feature for Permit.io - <a title="http://permit.io/foaz" href="http://permit.io/foaz"><strong>Frontend-only-Authorization (FoAz)</strong></a>. FoAz is a breakthrough technology that empowers frontend developers to use sensitive APIs directly from the frontend, without requiring any backend code, while maintaining the highest level of security.</p><p>FoAz is designed to solve two key problems faced by modern application developers. Firstly, it allows developers to &quot;slap on permissions&quot; on existing services that don&#39;t have an authorization layer yet, require better policy models (e.g. RBAC, ABAC, ReBAC), or enhanced permission granularity.</p><p>To achieve this, FoAz acts as a proxy service that accepts incoming API calls from the frontend. The API Calls are checked against their assigned policies and the current identity (in the form of the application&#39;s own JWT). Then, only if allowed, secrets for the target are added, and the target service is called.</p><p>Secondly, FoAz allows frontend applications to call services directly without having to add backend glue-code. For example, an app wanting to send an SMS can call Twilio without the need for backend engineering. The same goes for other services like OpenAI, Stripe, <a title="https://www.permit.io/blog/mailgun-foaz" href="https://www.permit.io/blog/mailgun-foaz">Mailgun</a>, and many more API-driven services.</p><p>FoAz is a game-changer - saving frontend developers a ton of time and dramatically improving their velocity while taking shift-left even further to the left, finally empowering frontend engineers to take charge of application security. FoAz is built on the low-code interfaces of Permit.io, especially the Permit Policy Editor, which generates policy as code.</p><p>We are excited to share FoAz with everyone as a ready-to-use SaaS service, but more importantly, as an open-source standard and spec. With FoAz, frontend developers can now work independently without having to rely on backend engineers, giving them greater autonomy, and enabling them to build and deploy new features faster and more securely.</p><p>Permit.io is committed to providing cutting-edge technologies that empower developers, and FoAz is another example of our commitment to innovation. We can&#39;t wait to see what developers create using FoAz, and we invite you to<a title="https://app.permit.io" href="https://app.permit.io"> try it out for yourselves</a> and join us on this exciting journey!</p>]]></content>
        <author>
            <name>Or Weis</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[How to Implement Authorization in an Express Application]]></title>
        <id>implement-rbac-authorization-in-express</id>
        <link href="https://www.permit.io/blog/implement-rbac-authorization-in-express"/>
        <updated>2023-05-29T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Learn how to create authorization middleware for an ExpressJS application. Use RBAC and ABAC permissions models seamlessly in your Express app.]]></summary>
        <content type="html"><![CDATA[<h2>Introduction</h2><p>It&#39;s hard to imagine the Node.JS ecosystem without the Express framework. Not only is it one of the most popular frameworks, but it also inspired many others. Almost every modern web framework today contains a flavor that originated from Express.</p><p>If you ever use Express in production, there is a good chance you will need to embed it with an authorization/permission solution - A middleware that can <strong>determine what your users can and can&#39;t do within your Express endpoints</strong>. </p><p>Even though it always starts simple, as the one-line ticket states: Add RBAC to the project, it always ends up with writing a lot of code, and annoying bugs that come with it.</p><p>In this article, I suggest a new, efficient way to deal with permissions in Express applications. I will demonstrate how to use <a title="https://www.permit.io/" href="https://www.permit.io/"><u>Permit</u></a> to create lean and fast authorization middleware for your Express application. By the end of this article, you will be able to implement a much better authorization solution for your application with much less code and bugs. Let&#39;s dive in.</p><h2>The Homebrewed Authorization Problem</h2><p>One of the main reasons for the authorization mess we describe is the usage of policy logic inside the middleware. While in an ideal world, the middleware will only enforce the policy, in the real world, it is also responsible for the policy logic. Let&#39;s take a classic code example: In the beginning, you only have one row that checks the user role and verifies the DB for the permissions:</p><pre><code>if (user.role === &#39;admin&#39;) {
    next();
} else {
    res.status(403).send(&#39;Forbidden&#39;);
}</code></pre><p>But then, you need to add a new role, so you add a new row to the middleware:</p><pre><code>if (user.role === &#39;admin&#39; || user.role === &#39;manager&#39;) {
    next();
} else {
    res.status(403).send(&#39;Forbidden&#39;);
}</code></pre><p>Then, you need to add a new permission, and you add a new row to the middleware:</p><pre><code>if (user.role === &#39;admin&#39; || user.role === &#39;manager&#39; || user.role === &#39;user&#39; &amp;&amp; user.permissions.includes(&#39;read&#39;)) {
    next();
} else {
    res.status(403).send(&#39;Forbidden&#39;);
}</code></pre><p>Continuing this pattern, you’ll end up with a huge middleware that is hard to maintain and hard to test. There are two best practices that can help you avoid this mess:</p><ol><li><div><p>Design your permissions model in a way that does not depend on the application implementation. Instead of ‘Add RBAC to the project’, think about ‘Design a Permission Model for the Application’ and only then implement the details that are relevant to you.</p></div></li><li><div><p>Do not use policy logic inside the middleware. Instead of it, use a dedicated service that will be responsible for the policy logic. We&#39;ll discuss how you can solve it with Permit.io later.</p></div></li></ol><p>We will start with designing your application’s permissions model. To do that, let’s look at a demo application:</p><h2>A Demo Application</h2><p>For the purpose of this article, we will use an <a title="https://github.com/permitio/permit-express-tutorial" href="https://github.com/permitio/permit-express-tutorial"><u>Express-based blogging application</u></a>. The application code is available on GitHub and we encourage you to clone it and work on this tutorial interactively. The code consists of three files:</p><ol><li><div><p><code>app.js</code> - The main application file. Consist of the relevant API endpoints for a working blogging application (the real function is just a mock).</p><pre><code>...
app.get(&#39;/post&#39;, mockPublic);
app.get(&#39;/post/:id&#39;, mockPublic);
app.post(&#39;/post&#39;, authentication, mockPrivate);
app.put(&#39;/post/:id&#39;, authentication, mockPrivate);
app.delete(&#39;/post/:id&#39;, authentication, mockPrivate);

app.get(&#39;/author&#39;, mockPublic);
app.get(&#39;/author/:id&#39;, mockPublic);
app.post(&#39;/author&#39;, authentication, mockPrivate);
app.put(&#39;/author/:id&#39;, authentication, mockPrivate);
app.delete(&#39;/author/:id&#39;, authentication, mockPrivate);

app.get(&#39;/comment&#39;, mockPublic);
app.get(&#39;/comment/:id&#39;, mockPublic);
app.post(&#39;/comment&#39;, authentication, mockPrivate);
app.put(&#39;/comment/:id&#39;, authentication, mockPrivate);
app.delete(&#39;/comment/:id&#39;, authentication, mockPrivate);
...</code></pre></div></li><li><div><p><code>middleware/authentication.js</code> - The authentication middleware. A simple authentication mock will add a user object from a JWT token to the request object.</p><pre><code>...
const authentication = (req, res, next) =&gt; {
    const authHeader = req.headers[&#39;authorization&#39;];
    const token = authHeader &amp;&amp; authHeader.split(&#39; &#39;)[1];
    if (token == null) return res.sendStatus(401);

    jwt.verify(token, process.env.ACCESS_TOKEN_SECRET, (err, user) =&gt; {
        if (err) return res.sendStatus(403);
        req.user = user;
        next();
    });
};
...</code></pre></div></li><li><div><p><code>app.test.js</code> - The test file. A simple test file that will verify that the application is working as expected.</p><pre><code>...
// Init a token for authenticated requests
const token = &#39;Bearer &#39; + jwt.sign({ username: &#39;admin@permit-blog.app&#39; }, process.env.ACCESS_TOKEN_SECRET, { expiresIn: &#39;15m&#39; });
...
test(&#39;CRUD Posts&#39;, async () =&gt; {
    await request(app).get(&#39;/post&#39;).expect(200);
    await request(app).get(&#39;/post/1&#39;).expect(200);
    await request(app).post(&#39;/post&#39;).expect(401);
    await request(app).put(&#39;/post/1&#39;).expect(401);
    await request(app).delete(&#39;/post/1&#39;).expect(401);

    await request(app).post(&#39;/post&#39;).set(&#39;Authorization&#39;, token).expect(200);
    await request(app).put(&#39;/post/1&#39;).set(&#39;Authorization&#39;, token).expect(200);
    await request(app).delete(&#39;/post/1&#39;).set(&#39;Authorization&#39;, token).expect(200);
});
...</code></pre></div></li></ol><p>To see it in action, run the following commands (assuming you have <a title="https://nodejs.org/en/download" href="https://nodejs.org/en/download">Node.JS and NPM installed</a> on your machine):</p><ol><li><div><p>Clone the repository in your desired location</p><pre><code>git clone -b tutorial git@github.com:permitio/permit-express-tutorial.git</code></pre></div></li><li><div><p>Install the dependencies</p><pre><code>npm install</code></pre></div></li><li><div><p>Run the tests that will verify that everything is working as expected</p><pre><code>npm run test</code></pre></div></li></ol><p>As you can see in the output, the tests are passing and the application is working as expected.</p><h2>Designing a Permission Model</h2><p><br>When integrating permissions into an application, it is crucial to carefully design the model and determine which permissions should be granted to users. <br><br>To achieve this, we consider three key components: the user&#39;s<strong> identity and role</strong>, the <strong>resources</strong> being accessed, and the <strong>actions</strong> that can be performed on those resources. <br><br>The amalgamation of these components is referred to as a &quot;<strong>Policy</strong>.&quot;</p><p>Keeping these entities in mind, we can translate our application requirements into specific conditions and policies that reflect the desired permissions.</p><p>Let&#39;s analyze the APIs of our demonstration blog:</p><ul><li><div><p><strong>Roles </strong>can be assigned to authenticated users, such as Admin, Writer, and Commenter.</p></div></li><li><div><p><strong>Actions </strong>can be associated with HTTP methods (Get, Create, Update, Delete, Patch) to simplify the process.</p></div></li><li><div><p><strong>Resources </strong>represent the various endpoints we need to manage access for, including posts, authors, comments, and so on.</p></div></li></ul><p>By mapping all these elements, we can create the following table:</p><table><tbody><tr><td><p>Role</p></td><td><p>Resource</p></td><td><p>Action</p></td></tr><tr><td><p>Admin</p><p>Writer</p><p>Commenter</p></td><td><p>Post</p><p>Author</p><p>Comment</p></td><td><p>Get</p><p>Create</p><p>Update</p><p>Delete</p><p>Patch</p></td></tr></tbody></table><p>Having established the foundational roles, resources, and actions, we can now map the desired permissions based on the principle of least privilege:</p><ul><li><div><p>Admins have the ability to perform any action on any resource.</p></div></li><li><div><p>Writers can create, update, patch, and delete posts, as well as retrieve comments.</p></div></li><li><div><p>Commenters can retrieve and create comments.</p></div></li></ul><p>By adhering to these defined conditions, we ensure that the permission model follows the principle of least privilege, granting users only the necessary access required for their respective roles and tasks.</p><h2>Configuring the Permissions Model with Permit.io</h2><p>Now that our model is designed, it&#39;s time to put it into action! As mentioned before, <a title="https://www.permit.io/blog/four-mistakes-you-make-when-building-permissions#2-mixing-up-app-logic-and-authorization" href="https://www.permit.io/blog/four-mistakes-you-make-when-building-permissions#2-mixing-up-app-logic-and-authorization"><u>we don&#39;t want to mix the policy code with the API logic</u></a>. To maintain a clean structure, we&#39;ll utilize a separate service specifically designed for defining and configuring policies. This approach allows the service to focus on enforcing permissions while the application code handles critical application logic.</p><p>Permit.io, provides authorization-as-a-service, streamlines permission configuration and enforcement, and ensures your code remains organized, and access to your application is controlled. The platform offers an extensive free tier and operates on a self-service basis.</p><p>To configure the desired application permissions, follow these steps:</p><ol><li><div><p>Log in to Permit.io <a title="http://app.permit.io" href="http://app.permit.io"><u>here</u></a></p></div></li><li><div><p>Once logged in, navigate to the Policy page and create the following roles:</p><img src="https://media.graphassets.com/rl4unQM2SzSwNn5E8b7T" alt="Create roles blog.png" title="Create roles blog.png" width="1437" height="778" /></div></li><li><div><p>Proceed by creating the necessary resources along with their respective actions:</p><img src="https://media.graphassets.com/Gurboi71RGTog7ZE21aA" alt="Resources Blog.png" title="Resources Blog.png" width="1919" height="641" /></div></li><li><div><p>Customize the policy table by implementing the desired conditions through the selection of relevant checkboxes:</p><img src="https://media.graphassets.com/lwNUckXwQZGMUcLp2Q9q" alt="Policy editor blog.png" title="Policy editor blog.png" width="1401" height="918" /></div></li><li><div><p>To complete the configuration, create three user accounts and assign them the appropriate roles using the Users screen:</p><img src="https://media.graphassets.com/QIW5E9rpT2GXf2Dhmbij" alt="Users blog.png" title="Users blog.png" width="1466" height="469" /></div></li></ol><p>That&#39;s it! Now that we&#39;ve established our permissions, it&#39;s time to integrate them with our Express application.</p><h2>Using the Permit.io SDK in the Application</h2><p>Now that we configured the permissions model in Permit.io, we can use it in our application. As you remember, our main goal is to keep the middleware as lean as possible. Make it only check and enforce the permissions against the configuration made in Permit.io.</p><h3>Install and Initialize Permit.io SDK</h3><ol><li><div><p>Before we start using Permit.io, we need to install the Permit.io SDK.</p><pre><code>⁠npm install permitio</code></pre></div></li><li><div><p>Now that we have the SDK installed, we need to get the SDK key from Permit.io. Go to the <code>Settings</code> page, and grab the SDK key.</p><img src="https://media.graphassets.com/5MK16idBQNOURkWcnkyD" alt="sdk_key.png" title="sdk_key.png" width="972" height="1001" /></div></li><li><div><p>Let&#39;s save the SDK key in the .env file at the root of the project</p><pre><code>⁠PERMIT_SDK_SECRET=YOUR_SDK_KEY</code></pre></div></li><li><div><p>With our SDK key configured, let&#39;s create a new file called <code>middleware/authorization.js</code> and add the following code to it:</p><pre><code>const permit = require(&#39;permitio&#39;);

const permit = new Permit({
    token: process.env.PERMIT_SDK_SECRET,
    pdp: process.env.PDP_URL
});

const authorization = (req, res, next) =&gt; {

}

module.exports = authorization;</code></pre></div></li></ol><h3>Add Authorization to the Application</h3><ol><li><div><p>With empty authorization middleware set up, we can add the middleware to the relevant protected routes in the app.js file.</p><pre><code>const authorization = require(&#39;./middleware/authorization&#39;);

...
app.post(&#39;/post&#39;, authentication, authorization, mockPrivate);
app.put(&#39;/post/:id&#39;, authentication, authorization, mockPrivate);
app.delete(&#39;/post/:id&#39;, authentication, authorization, mockPrivate);
...
app.post(&#39;/author&#39;, authentication, authorization, mockPrivate);
app.put(&#39;/author/:id&#39;, authentication, authorization, mockPrivate);
app.delete(&#39;/author/:id&#39;, authentication, authorization, mockPrivate);
...
app.post(&#39;/comment&#39;, authentication, authorization, mockPrivate);
app.put(&#39;/comment/:id&#39;, authentication, authorization, mockPrivate);
app.delete(&#39;/comment/:id&#39;, authentication, authorization, mockPrivate);
...</code></pre></div></li><li><div><p>Let&#39;s run the tests again and see that everything is still passed (remember our authorization logic is still empty).</p><pre><code>npm test</code></pre></div></li><li><div><p>Now, let&#39;s add the logic to the middleware. In the function, add a call to permit.check with the user, action, and resource we want to call.</p><pre><code>...
const action = method.toLowerCase(),
    url_parts = url.split(&#39;/&#39;),
    type = url_parts[1],
    key = url_parts[2] || null;
const allowed = await permit.check(username, action, {
    type,
    key,
    attributes: body || {}
});

if (!allowed) {
    res.sendStatus(403);
    return;
}
next();
...</code></pre></div></li><li><div><p>Let&#39;s rerun the tests and see the failed results as our tests configured user has no admin role:</p><pre><code>npm test
#  FAIL  ./app.test.js
#   API Test
#     ✕ CRUD Post (802 ms)
#     ✕ CRUD Author (615 ms)
#     ✕ CRUD Comment (664 ms)
#   ● API Test › CRUD Post
#     expected 200 &quot;OK&quot;, got 403 &quot;Forbidden&quot;</code></pre></div></li><li><div><p>To fix the tests, let&#39;s change the username in our tests to: admin@permit-blog.app</p><pre><code>...
const token = &#39;Bearer &#39; + jwt.sign({ username: &#39;admin@permit-blog.app&#39; }, process.env.ACCESS_TOKEN_SECRET, { expiresIn: &#39;15m&#39; });
...</code></pre></div></li><li><div><p>Tests should now pass!</p></div></li></ol><ol><li><div><pre><code>npm test</code></pre></div></li></ol><h3>Test the Permission Model</h3><p>At this point, as we protected all the endpoints, we can test the permission model.</p><ol><li><div><p>Let&#39;s add more tokens for different users at the beginning of the test file.</p><pre><code>...
    const token = &#39;Bearer &#39; + jwt.sign({ username: &#39;admin@permit-blog.app&#39; }, process.env.ACCESS_TOKEN_SECRET, { expiresIn: &#39;15m&#39; });
    const writer = &#39;Bearer &#39; + jwt.sign({ username: &#39;writer@permit-blog.app&#39; }, process.env.ACCESS_TOKEN_SECRET, { expiresIn: &#39;15m&#39; });
    const commenter = &#39;Bearer &#39; + jwt.sign({ username: &#39;commenter@permit-blog.app&#39; }, process.env.ACCESS_TOKEN_SECRET, { expiresIn: &#39;15m&#39; });
...</code></pre></div></li><li><div><p>And add the tests for the writer and commenter users.</p><pre><code>...
await request(app).post(&#39;/post&#39;).set(&#39;Authorization&#39;, writer).expect(200);
await request(app).put(&#39;/post/1&#39;).set(&#39;Authorization&#39;, writer).expect(200);
await request(app).delete(&#39;/post/1&#39;).set(&#39;Authorization&#39;, writer).expect(200);
await request(app).post(&#39;/post&#39;).set(&#39;Authorization&#39;, commenter).expect(403);
await request(app).put(&#39;/post/1&#39;).set(&#39;Authorization&#39;, commenter).expect(403);
await request(app).delete(&#39;/post/1&#39;).set(&#39;Authorization&#39;, commenter).expect(403);
...</code></pre></div></li></ol><h2>Improve Authorization with ABAC</h2><p><em>Note: Enforcing ABAC policies requires deploying a local PDP - to get started, follow this guide.</em></p><p>Streamlining our Identity, Resource, and Action into a concise list of Roles, Resource types, and Action names can pose challenges in real-world scenarios, as demonstrated in our previous example.</p><p>However, simple Role-Based Access Control (RBAC) may not be sufficient if we encounter more complex requirements. For instance, if we want to create an approval flow for blog content, allowing only approved writers to publish articles and restricting comments from specific geolocations, or applying other fine-grained limitations, we need to consider <a title="https://www.permit.io/blog/what-is-abac" href="https://www.permit.io/blog/what-is-abac"><u>Attribute-Based Access Control (ABAC)</u></a>.</p><p>Let&#39;s delve into the details of these conditions by incorporating attributes:</p><ul><li><div><p>Admin users possess unrestricted access, enabling them to perform any action on any resource.</p></div></li><li><div><p>Writers have the ability to edit and delete posts, but they can only create unpublished posts.</p></div></li><li><div><p>Approved writers enjoy the freedom to create any type of post.</p></div></li><li><div><p>Commenters are permitted to create comments.</p></div></li></ul><p>Implementing ABAC by introducing attributes to an RBAC model <a title="https://www.permit.io/blog/rbac-to-abac" href="https://www.permit.io/blog/rbac-to-abac"><u>can be a complex task</u></a>. However, Permit.io simplifies this process by facilitating a configuration change to support the new permission model without requiring modifications to the application code.</p><p>An effective approach to implementing ABAC involves utilizing Resource Sets and User Sets, which are constructed based on conditions that combine user and resource attributes. Let&#39;s explore how Permit enables us to configure these policies:</p><ol><li><div><p>First, to enable ABAC in Permit, go to the `ABAC Rules` tab in the policy editor and toggle the `ABAC Options` switch.</p></div></li><li><div><p>Begin by configuring attributes for the relevant resources. Access the Policy Editor, click the three dots on the resource table, and select &quot;Add Attribute.&quot;</p><img src="https://media.graphassets.com/sDIFnoOgTm6t2VAZ9Xxo" alt="Resource attribute config blog.png" title="Resource attribute config blog.png" width="875" height="682" /></div></li><li><div><p>With the resource attributes defined, create Resource Sets within the Policy Editor to establish the necessary conditions.</p><img src="https://media.graphassets.com/LJtUXBM6Q9Orn2ZDxF4L" alt="Resource set config blog.png" title="Resource set config blog.png" width="1439" height="682" /></div></li><li><div><p>To match the policy with user attributes, configure user attributes as well. Access the Users screen, navigate to the &quot;Attributes&quot; tab, and create the desired approved attribute. </p><img src="https://media.graphassets.com/xhSGr1ROq7JbAQQvm9GA" alt="Create user attributes blog.png" title="Create user attributes blog.png" width="1437" height="778" /></div></li><li><div><p>Create a new user in the Writer role and assign them the approved attribute in their profile. This user will serve as a reference for evaluating the ABAC policy later. Let&#39;s use the following username <code>approved_writer@permit-blog.app </code></p><img src="https://media.graphassets.com/PPfZBWu5RRStf8eCrwQG" alt="Create roles ABAC.png" title="Create roles ABAC.png" width="1437" height="778" /></div></li><li><div><p>Now that Permit.io recognizes the custom user attributes create User Sets in the Policy Editor to accommodate these conditions. </p><img src="https://media.graphassets.com/QSZspQWJRLD9wTDcqwt6" alt="User Sets blog.png" title="User Sets blog.png" width="842" height="641" /></div></li><li><div><p>With the conditions in place, adapt the policy configuration in the policy table to align with the newly defined conditions. </p><img src="https://media.graphassets.com/05N4WVJTKaNPK7zk0ilB" alt="Policy editor ABAC blog.png" title="Policy editor ABAC blog.png" width="1293" height="918" /></div></li></ol><p>By adopting this approach, we can enforce permissions without the need to rewrite our application code. The middleware we initially developed for private routes will seamlessly continue its role by enforcing permissions based on the new policy model configuration we assigned.</p><h3>Add Test to our New ABAC Policy</h3><ol><li><div><p>By running our current tests, you can see that now our writer can&#39;t create a post.</p><pre><code>npm test
#  FAIL  ./app.test.js (8.677 s)
#   API Test
#     ✓ CRUD Post (2909 ms)
#     ✕ CRUD Post by writer and commenter (893 ms)
#     ✓ CRUD Author (2146 ms)
#     ✓ CRUD Comment (2256 ms)
#   ● API Test › CRUD Post by writer and commenter
#     expected 200 &quot;OK&quot;, got 403 &quot;Forbidden&quot;
#       24 |
#       25 |     test(&#39;CRUD Post by writer and commenter&#39;, async () =&gt; {
#     &gt; 26 |         await request(app).post(&#39;/post&#39;).set(&#39;Authorization&#39;, writer).expect(200);</code></pre></div></li><li><div><p>Let&#39;s fix those tests by passing objects with the different published attributes.</p><pre><code>await request(app).post(&#39;/post&#39;).send({
    published: false,
}).set(&#39;Authorization&#39;, writer).expect(200);
await request(app).put(&#39;/post/1&#39;).send({
    published: false,
}).set(&#39;Authorization&#39;, writer).expect(200);    </code></pre></div></li><li><div><p>Now, let&#39;s run the tests again and see that they are now passed.</p><pre><code>npm test
#  PASS./ app.test.js
#   API Test
#     ✓ CRUD Post(132 ms)
#     ✓ CRUD Post by writer and commenter(212 ms)
#     ✓ CRUD Author(92 ms)
#     ✓ CRUD Comment(87 ms)</code></pre></div></li><li><div><p>Now, let&#39;s test the approved users. We will add a new test for the approved user.</p><pre><code>// Add a new token for the approved user we just created
const approvedWriter = &#39;Bearer &#39; + jwt.sign({ username: &#39;approved_writer@permit-blog.app&#39; }, process.env.ACCESS_TOKEN_SECRET, { expiresIn: &#39;15m&#39; });
...
// Add a test case
test(&#39;CRUD Post by approved writer&#39;, async () =&gt; {
    await request(app).post(&#39;/post&#39;).send({
        published: true,
    }).set(&#39;Authorization&#39;, approved).expect(200);
    await request(app).put(&#39;/post/1&#39;).send({
        published: true,
    }).set(&#39;Authorization&#39;, approved).expect(200);
});
...</code></pre></div></li></ol><p>As you can see, <strong>no changes to the application code were required to enforce the new policy</strong>. Permit.io&#39;s ABAC capabilities enable us to implement complex policies without the need to modify our application code.</p><h2>What&#39;s Next?</h2><p>By now, you should have a basic understanding of how to implement a basic authorization model into your Express application, enforcing permissions with just a single line of code.</p><p>The next step would be to analyze the specific requirements of your application and incorporate a dependable permission model into it. As demonstrated in the article, it doesn&#39;t have to be overly complicated.</p><p>The plugin we developed for this blog is readily available for use. Simply adjust it to accommodate the relevant request fields of your application, and you&#39;re good to go.</p><p>If your organization has already implemented an authorization model and you&#39;re interested in learning more about scaling it effectively, <a title="https://io.permit.io/permitslack" href="https://io.permit.io/permitslack"><u>join our Slack community</u></a>, where numerous developers and authorization experts discuss the process of building and implementing authorization.</p>]]></content>
        <author>
            <name>Gabriel L. Manor</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Scaling Authorization with Cedar and OPAL]]></title>
        <id>scaling-authorization-with-cedar-and-opal</id>
        <link href="https://www.permit.io/blog/scaling-authorization-with-cedar-and-opal"/>
        <updated>2023-05-24T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Learn how to build a Cedar-based application authorization system. A practical tutorial to build a comprehensive auto-scaled solution with OPAL and Cedar agent.]]></summary>
        <content type="html"><![CDATA[<h2>Revamping Application-Level Authorization with Cedar</h2><p>AWS recently rolled out Cedar, a new policy language that indicates the necessity for a revamp in application-level authorization. As opposed to embedding policy definitions in an application&#39;s code, decentralized and declarative approaches are becoming more prevalent. By separating policy configuration from application code, this fresh approach allows for a scalable and easier-to-maintain authorization system.</p><p>Cedar offers a unique and refreshing approach to the <a title="https://www.permit.io/blog/opa-vs-cedar#the-benefits-of-using-pac" href="https://www.permit.io/blog/opa-vs-cedar#the-benefits-of-using-pac"><u>Policy-as-Code trend</u></a>. While other policy languages (like Rego) tend to offer a multi-propose language that could fit into application-level authorization, Cedar is built with application-level authorization in mind.</p><p>In this article, we&#39;ll discuss the benefits of separating policy from application code, which include easier scaling, fewer bugs, quicker response times, and enhanced access control security. We&#39;ll also delve into the utilization of open-source projects like <a title="https://github.com/permitio/cedar-agent" href="https://github.com/permitio/cedar-agent"><u>Cedar-Agent</u></a> and <a title="https://github.com/permitio/opal" href="https://github.com/permitio/opal"><u>OPAL</u></a> to construct a comprehensive and scalable authorization system.</p><p>By the end of this article, you&#39;ll have the knowledge required to construct a complete open-source authorization system that is specifically designed to handle scalability.</p><h2>The OPAL-Cedar Example Repository</h2><p>To begin our exploration of modern authorization implementation, let&#39;s first clone the project we created that utilizes the entire system in an Infrastructure as Code (IaC) manner.</p><p>Clone the project using the following command:</p><pre><code>git clone git@github.com:permitio/opal-cedar.git</code></pre><p>In the upcoming sections, we will examine each component declared in the code you just cloned. We&#39;ll start with the store, which manages the policies, and then move on to the data required for policy evaluation. Next, we&#39;ll deploy an administration layer responsible for auto-scaling the policy decision-makers. Finally, we&#39;ll focus on the end applications where we will enforce our policies.</p><p>This repository example uses <a title="https://github.com/permitio/cedar-agent" href="https://github.com/permitio/cedar-agent"><u>Cedar-Agent</u></a> to run Cedar policies, but this can work similarly with Amazon Verified Permissions, or other solutions running the Cedar engine.</p><p><strong>In order to follow along with the practical portions of this article, you need a </strong><a title="https://docs.docker.com/engine/install/" href="https://docs.docker.com/engine/install/"><u><strong>local installation of Docker</strong></u></a><strong> on your machine</strong></p><h2>Setup The Policy and Its Retrieval Point</h2><p>As we are going to configure our permissions as code declaration, we would like to have one centralized store for it. To set up our policy store, we will use a Git repository. Of course, you can use any type of file system to write and maintain the policy files, but Git will help us to scale later with its built-in features like branching, version control, revisioning, and immutability.</p><p>Taking a look at the repo we just cloned, we can see two parts of our retrieval point.</p><p>First, is a folder named Policy that represents our policy storage.</p><p>Second, is the docker-compose file on our root folder that contains the configuration that creates a local git server that will serve our policy files.</p><p><em>We used a local git server to avoid a redundant mess with SSH keys for real repositories. In the real world, you will probably use a remote git server like GitHub or GitLab.</em></p><p>Let&#39;s take a look at the folder named policy in our repository. As you can see, there are 3 simple policy files, each consisting of a policy permit statement for different roles of users.</p><p><em>admin.cedar</em></p><pre><code>// Permit any action on any resource assuming the principal (user) role is admin
permit(
    principal in Role::&quot;admin&quot;,
    action,
    resource
);</code></pre><p><em>writer.cedar</em></p><pre><code>// Permit any principal (user) with the role writer to perform post/put on articles
permit(
        principal in Role::&quot;writer&quot;,
        action in [Action::&quot;post&quot;, Action::&quot;put&quot;],
        resource in ResourceType::&quot;article&quot;
    );</code></pre><p><em>user.cedar</em></p><pre><code>// Permit any principal (user) to perform the get action on any resource
permit(
        principal,
        action in Action::&quot;get&quot;,
        resource
    );    </code></pre><p>As we have done for the policy configuration, we can also configure the data sources for our application.</p><h2>Loading Data into Cedar</h2><p>Getting policy decisions in real-time always depends on the data of our application at a particular moment. For example, if we want to allow a user to post an article, we may want to know if the user is a writer, if the article is auto-published, etc.</p><p>To handle data in Cedar, we require it to be in a special format, <a title="https://docs.cedarpolicy.com/syntax-entity.html" href="https://docs.cedarpolicy.com/syntax-entity.html"><u>called Cedar entities</u></a>: A hierarchical data structure that helps us to restructure the data in a way that will be easy to use in our policy declaration.</p><p>The data.json file in our repository contains a mock data source that represents the data of our application. Let&#39;s take a look at the different data types we have in our data source, bottom down.</p><p>At the top level, we will start by defining roles we want to assign our users to.</p><pre><code>...
{
    &quot;attrs&quot;: {},
    &quot;parents&quot;: [],
    &quot;uid&quot;: {
        &quot;id&quot;: &quot;admin&quot;,
        &quot;type&quot;: &quot;Role&quot;
    }
},
...</code></pre><p>Same as for roles, we would like also to define resource types and actions.</p><pre><code>...
{
    &quot;attrs&quot;: {},
    &quot;parents&quot;: [],
    &quot;uid&quot;: {
        &quot;id&quot;: &quot;article&quot;,
        &quot;type&quot;: &quot;ResourceType&quot;
    }
},
{
    &quot;attrs&quot;: {},
    &quot;parents&quot;: [],
    &quot;uid&quot;: {
        &quot;id&quot;: &quot;put&quot;,
        &quot;type&quot;: &quot;Action&quot;
    }
},
...</code></pre><p>As we are done with the root level of our data mocking, we can define our users and assign them as children to the roles we defined earlier.</p><pre><code>...
{
    &quot;attrs&quot;: {},
    &quot;parents&quot;: [
        {
            &quot;id&quot;: &quot;admin&quot;,
            &quot;type&quot;: &quot;Role&quot;
        }
    ],
    &quot;uid&quot;: {
        &quot;id&quot;: &quot;admin@blog.app&quot;,
        &quot;type&quot;: &quot;User&quot;
    }
},
...</code></pre><p>Of course, in your application, you can always continue to nest this data by configuring resources and actions in the same hierarchical way. The main benefit of keeping those data in a hierarchical structure is that we can easily query them in our policy declaration. By using this data, we can easily see how easy it is to make decisions in the policy, like allowing if a user is a writer or denying if a user is a reader.</p><p>As we configure our both control plane (policies) and data plane (data source), we can now connect them together using the Administration point.</p><h2>Loading Policy to Cedar with OPAL </h2><p>Our administration point, <a title="https://www.opal.ac" href="https://www.opal.ac"><u>OPAL</u></a>, consists of two components, <a title="https://docs.opal.ac/overview/architecture" href="https://docs.opal.ac/overview/architecture"><u>the OPAL server, and the OPAL client.</u></a> The server is the part that tracks the changes in the policy and the data sources configuration and makes sure the client is up to date. The client, together with the configuration managed by the server, is responsible to make sure all data is updated and the decision point is ready to answer permissions decisions. The client is also running the policy agent itself, in our case, the Cedar agent - Our decision maker.</p><p>OPAL is configured as code and you can use any kind of IaC (such as <a title="https://docs.opal.ac/tutorials/helm-chart-for-kubernetes" href="https://docs.opal.ac/tutorials/helm-chart-for-kubernetes"><u>Helm, TF, or docker</u></a>) to set it up. In our case, we will use docker-compose to set up our OPAL server and client.</p><p>Let&#39;s take a look at the first services declared in the docker-compose file, where we compose the retrieval and information point. This is not a part of OPAL yet, just a way to set up everything needed to run OPAL in our demo:</p><pre><code>version: &quot;3.8&quot;
services:
  # A simple nginx server to serve our mock data sources.
  cedar_data_nginx:
      image: nginx:latest
      volumes:
        - &quot;./data:/usr/share/nginx/html:ro&quot;
  # Local git repo to host our policy.
  cedar_retrieval_repository:
      image: rockstorm/gitweb
      ports:
        - &quot;80:80&quot;
      volumes:
        - &quot;../:/srv/git:ro&quot;</code></pre><p>The second part is OPAL itself, let’s take a look at the important parts of the configuration.</p><ol><li><div><p>Initialize first the OPAL server container, responsible for syncing our policy config and scaling the clients.</p><pre><code>Opal_server:
	...
    image: permitio/opal-server:latest
	...
    environment:
        ...    
        - OPAL_POLICY_REPO_URL=http://cedar_retrieval_repository/opal-cedar/.git
        - OPAL_POLICY_REPO_MAIN_BRANCH=main</code></pre></div></li></ol><p>2. Configure the connection to our mock data source</p><pre><code>     - OPAL_DATA_CONFIG_SOURCES={&quot;config&quot;:{&quot;entries&quot;:[{&quot;url&quot;:&quot;http://cedar_data_nginx/data.json&quot;,&quot;topics&quot;:[&quot;policy_data&quot;],&quot;dst_path&quot;:&quot;&quot;},{&quot;url&quot;:&quot;http://cedar_data_nginx/data.json&quot;,&quot;topics&quot;:[&quot;policy_data&quot;],&quot;dst_path&quot;:&quot;&quot;}]}}
    - OPAL_LOG_FORMAT_INCLUDE_PID=true</code></pre><p>3. Verify we collect all the .cedar files from the policy store</p><pre><code>     # By default, the OPAL server looks for OPA rego files. Configure it to look for cedar files.
    - OPAL_FILTER_FILE_EXTENSIONS=.cedar
    - OPAL_POLICY_REPO_POLICY_EXTENSIONS=.cedar</code></pre><p>4. Finish by spinning the clients that will act as the decision points. We could auto-scale them independently to the server, and ensure the server synced them with the current data and configuration.</p><pre><code> opal_client:
    # by default we run opal-client from latest official image
    image: permitio/opal-client-cedar:latest
    environment:
      - OPAL_SERVER_URL=http://opal_server:7002
      - OPAL_LOG_FORMAT_INCLUDE_PID=true
    ports:</code></pre><p>Let&#39;s run this configuration to spin up our authorization system.</p><pre><code>docker-compose up</code></pre><p>Let&#39;s wait until OPAL finishes to set up everything and then we can start to use it.</p><h2>Query The Decision Point</h2><p>One of the benefits of using administration points is the ability to auto-scale our decision points and manage them by OPAL client. If we look at the logs of the compose we ran, we can see that our cedar-agent is running on port 8180. We now have the option to call the decision APIs via REST and enforce the permissions in our application.</p><p>We can verify that our cedar-agent is up and running, returning the right decisions, by calling the is_authorized endpoint with the following requests.</p><p>The following request requires a decision for a writer user to perform a delete action on an article, and it gets a Deny response:</p><pre><code>curl -X POST &quot;http://localhost:8180/v1/is_authorized&quot; \
 -H &quot;Accept: application/json&quot; \
 -H &quot;Content-Type: application/json&quot; \
 -d &#39;{&quot;principal&quot;:&quot;User::\&quot;writer@blog.app\&quot;&quot;,&quot;action&quot;:&quot;Action::\&quot;delete\&quot;&quot;,&quot;resource&quot;:&quot;Resource::\&quot;article\&quot;&quot;}&#39; </code></pre><p>The following request, require a decision for a writer user to perform a post action on an article, and it gets an Allowed response.</p><pre><code>curl -X POST &quot;http://localhost:8180/v1/is_authorized&quot; \
 -H &quot;Accept: application/json&quot; \
 -H &quot;Content-Type: application/json&quot; \
 -d &#39;{&quot;principal&quot;:&quot;User::\&quot;writer@blog.app\&quot;&quot;,&quot;action&quot;:&quot;Action::\&quot;post\&quot;&quot;,&quot;resource&quot;:&quot;Resource::\&quot;article\&quot;&quot;}&#39; </code></pre><h2>Enforce Permissions</h2><p>Since we configured a blog permissions mode, we also created a mock blog server, written in Node.js. Let&#39;s take a look at the file named server.js, and the authorization middleware we created there.</p><pre><code>...
// Generic authorization middleware - Enforcement Point
const authorization = async (req, res, next) =&gt; {
    const { user } = req.headers;
    const { method, originalUrl, body } = req;

    // Call the authorization service (Decision Point)
    const response = await fetch(&#39;http://host.docker.internal:8180/v1/is_authorized&#39;, {
        method: &#39;POST&#39;,
        headers: {
            &#39;Content-Type&#39;: &#39;application/json&#39;,
            &#39;Accept&#39;: &#39;application/json&#39;,
        },
        // The body of the request is the authorization request
        body: JSON.stringify({
            &quot;principal&quot;: `User::\&quot;${user}\&quot;`,
            &quot;action&quot;: `Action::\&quot;${method.toLowerCase()}\&quot;`,
            &quot;resource&quot;: `ResourceType::\&quot;${originalUrl.split(&#39;/&#39;)[1]}\&quot;`,
            &quot;context&quot;: body
        })
    });

    const { decision } = await response.json();

    // If the decision is not &#39;Allow&#39;, return a 403
    if (decision !== &#39;Allow&#39;) {
        res.status(403).send(&#39;Access Denied&#39;);
        return;
    }
    next();
};

// Mock routes
app.get(&#39;/article&#39;, authorization, async (req, res) =&gt; {
    const articles = [&#39;article1&#39;, &#39;article2&#39;, &#39;article3&#39;];
    res.send(articles);
});
...</code></pre><p>To run this server, in another terminal window, run the following command to spin up our server.</p><pre><code>docker-compose -f applications/node/docker-compose.yml up</code></pre><p>We can now use CURL or Postman to verify our permissions model. Let&#39;s run the following two calls to see our authorization magic in action.</p><h4>In case we POST an article with a writer identity, it succeeds</h4><pre><code>curl -X POST http://localhost:3000/article/2 \
    -H &#39;Content-Type: application/json&#39; \
    -H &quot;user: writer@blog.app&quot; \</code></pre><h4>In case we POST an article with a standard user identity, the access denied</h4><pre><code>curl -X POST http://localhost:3000/article/2 \
    -H &#39;Content-Type: application/json&#39; \
    -H &quot;user: user@blog.app&quot; \</code></pre><p>At this point, we have all our components up and running. As you saw, we separate all the components and verify that each of them is doing only one thing. The enforcement point is enforcing the permissions, the decision point is making permission decisions, and the administration point connects the policy and data sources to the decision point. In the control plane, we just have policy and data source declarations.</p><p></p><img src="https://media.graphassets.com/amEDs7K9SdCK5oPQ6Udq" alt="arch_with_logos.png" title="arch_with_logos.png" width="1451" height="1386" /><h2>Enforce Permissions at Scale!</h2><p>Now that we are done with spinning up our authorization system, let&#39;s test the different scale aspects of our authorization system.</p><h3>Scale Enforcement</h3><p>First, since we separated our policy configuration from our application, we can seamlessly add enforcement points in any other application we want. For example, here is a simple Python application that enforces the same permissions model we created earlier:</p><pre><code>...
# Authorization decorator middleware
def authorization(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        user = request.headers.get(&#39;user&#39;)
        method = request.method
        original_url = request.path

        # Call authorization service
        # In the request body, we pass the relevant request information
        response = requests.post(&#39;http://host.docker.internal:8180/v1/is_authorized&#39;, json={
            &quot;principal&quot;: f&quot;User::\&quot;{user}\&quot;&quot;,
            &quot;action&quot;: f&quot;Action::\&quot;{method.lower()}\&quot;&quot;,
            &quot;resource&quot;: f&quot;ResourceType::\&quot;{original_url.split(&#39;/&#39;)[1]}\&quot;&quot;,
            &quot;context&quot;: request.json
        }, headers={
            &#39;Content-Type&#39;: &#39;application/json&#39;,
            &#39;Accept&#39;: &#39;application/json&#39;
        })

        decision = response.json().get(&#39;decision&#39;)

        # If the decision is not Allow, we return a 403
        if decision != &#39;Allow&#39;:
            return &#39;Access Denied&#39;, 403    
        return f(*args, **kwargs)
    return decorated

# Mock endpoints
@app.route(&#39;/article&#39;)
@authorization
...</code></pre><p>As you can see, no more imperative code is required to enforce the permissions and streamline them on all our applications.</p><p>Let&#39;s run the application to see it in action.</p><pre><code>docker-compose -f applications/python/docker-compose.yml up</code></pre><p>Now, let&#39;s do the same CURL test we did earlier, but from the new application.</p><h4>In case we POST an article with a writer identity, it succeeds</h4><pre><code>curl -X POST http://localhost:3001/article/2 \
    -H &#39;Content-Type: application/json&#39; \
    -H &quot;user: writer@blog.app&quot; \</code></pre><h4>In case we POST an article with a writer identity, it succeeds</h4><pre><code>curl -X POST http://localhost:3001/article/2 \
    -H &#39;Content-Type: application/json&#39; \
    -H &quot;user: user@blog.app&quot; \</code></pre><h3>Scale Permissions Model</h3><p>We have a new feature request: We now want to allow writers to auto-publish their posts only if their account exceeds 1000 karma points. In the imperative style permissions model, we would need to change the code in all our applications to add this new permission. In our case, we just need to edit the policy file in our policy repository.</p><p>In our writer.cedar file, let&#39;s add the following permission. These permissions will allow writers to post published: true articles only if their account has more than 1000 karma points.</p><pre><code>permit(
    principal in Role::&quot;writer&quot;,
    action in [Action::&quot;post&quot;, Action::&quot;put&quot;],
    resource in ResourceType::&quot;article&quot;
) when { principal.karma &gt; 1000 || (context has published  &amp;&amp; context.published == false) }</code></pre><p>As you can read in the policy, we added new permission that allow users to auto-publish their posts only if their account exists for more than 30 days. Not only we can now make changes to our policy code without any change to the application, but the declaration is also much more readable and easy to understand.</p><h3>Scale Data Sources</h3><p>Adding a policy is one thing, but how would we know what is our writer karma? For that, we may want to use external data sources that will tell us more about the user. Do it in imperative style, we would need to change the code in all our applications to add this new data source. In our case, we just need to add a new data source in our policy administration layer.</p><p>To save some time and reinitialization, we just add the karma data to our main data source. In a real-world application, we could use a different data source for each data type.</p><p>Let&#39;s add the karma data to our <code>data.json</code> file.</p><pre><code>...
    {
        &quot;attrs&quot;: {
            &quot;karma&quot;: 2000
        },
        &quot;parents&quot;: [
            {
                &quot;id&quot;: &quot;writer&quot;,
                &quot;type&quot;: &quot;Role&quot;
            }
        ],
        &quot;uid&quot;: {
            &quot;id&quot;: &quot;senior_writer@blog.app&quot;,
            &quot;type&quot;: &quot;User&quot;
        }
    },
    {
        &quot;attrs&quot;: {
            &quot;karma&quot;: 500
        },
        &quot;parents&quot;: [
            {
                &quot;id&quot;: &quot;writer&quot;,
                &quot;type&quot;: &quot;Role&quot;
            }
        ],
        &quot;uid&quot;: {
            &quot;id&quot;: &quot;writer@blog.app&quot;,
            &quot;type&quot;: &quot;User&quot;
        }
    },
...</code></pre><p>Let&#39;s run now the following CURL to see our new permission in action.</p><h4>Allowed request</h4><pre><code>curl -X POST http://localhost:3001/article/2 \
    -H &#39;Content-Type: application/json&#39; \
    -H &quot;user: senior_writer@blog.app&quot; \
    -d &#39;{&quot;published&quot;: true}&#39;</code></pre><h4>Denied request</h4><pre><code>curl -X POST http://localhost:3001/article/2 \
    -H &#39;Content-Type: application/json&#39; \
    -H &quot;user: writer@blog.app&quot; \
    -d &#39;{&quot;published&quot;: true}&#39;</code></pre><h4>Allowed request with unpublished article</h4><pre><code>curl -X POST http://localhost:3001/article/2 \
    -H &#39;Content-Type: application/json&#39; \
    -H &quot;user: writer@blog.app&quot; \
    -d &#39;{&quot;published&quot;: false}&#39;</code></pre><h3>Scaling-Out Decision Points</h3><p>In this tutorial, we just use a local demonstration of OPAL running on the local machine with a docker-compose file, and run all the components on the same machine. In production, you can use OPAL to scale your decision points as you need. As we saw earlier, OPAL separates the concern of the stateful servers and stateless clients that run as sidecars in individual applications. You can find helm charts and other instructions in the OPAL repository that will help you deploy OPAL in production and scale it as needed.</p><h2>Conclusion</h2><p>We just created a basic auto-scaled authorization system that can be used to enforce permissions in any application we want. We separated the control plane from the data plane and the enforcement plane. We also separated the policy configuration from the application code. We can now scale our system in any aspect we want, without changing the application code.</p><p>As the next steps of this learning path, you can take a look at <a title="https://docs.opal.ac/" href="https://docs.opal.ac/"><u>OPAL</u></a> and <a title="https://docs.cedarpolicy.com/" href="https://docs.cedarpolicy.com/"><u>Cedar</u></a> docs, and understand more how you can customize your needs with it for authorization in scale. We would also want to invite you to our <a title="https://io.permit.io/permitslack" href="https://io.permit.io/permitslack"><u>Authorization Slack community</u></a>, hear your feedback and chat further on advanced use cases for application-level authorization.</p>]]></content>
        <author>
            <name>Gabriel L. Manor</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Permit.io Cedar Implementation Q&A: Everything you need to know ]]></title>
        <id>cedar-qna</id>
        <link href="https://www.permit.io/blog/cedar-qna"/>
        <updated>2023-05-22T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[AWS' new Cedar policy language is now open-source and live! See how you can make the best use of it with Permit.io]]></summary>
        <content type="html"><![CDATA[<h2><strong>Introduction:</strong></h2><p>We have been receiving lots of great responses and inquiries since the <a title="https://www.permit.io/blog/oss-aws-cedar-is-a-gamechanger-for-iam" href="https://www.permit.io/blog/oss-aws-cedar-is-a-gamechanger-for-iam"><u>launch of our support for AWS Cedar</u></a>. It&#39;s fantastic to see the excitement and curiosity surrounding this new integration. To address some of those questions, we&#39;ve gathered a selection of the most frequently asked ones and are thrilled to provide detailed answers right here in this blog post. </p><p>Let&#39;s dive in and explore the ins and outs of the Permit.io and AWS Cedar integration!</p><h2><strong>Q: What is AWS Cedar, and why is it significant?</strong></h2><p><strong>A:</strong> <a title="https://www.cedarpolicy.com/" href="https://www.cedarpolicy.com/"><u>AWS Cedar</u></a> is an open-source project that introduces a <a title="https://www.permit.io/blog/what-is-policy-as-code" href="https://www.permit.io/blog/what-is-policy-as-code">Policy As Code</a> (PAC) language and engine specifically designed for application-level authorization. It offers a tectonic shift in the IAM (Identity and Access Management) space by tackling the problem of managing in-app permissions, which has grown too big to ignore. With Cedar, organizations can author fine-grained access control policies, and apply them to enforcement (such as with the Permit SDK), thus ensuring that only authorized users and systems have access to the right resources.</p><h2><strong>Q: Why is having PAC important? What are the benefits of that? How does it improve the management of permissions?</strong></h2><p><strong>A:</strong> Traditionally, organizations have relied on access control lists (ACLs) and role-based access control (RBAC) to manage permissions. However, as the number of resources and users grows, it becomes difficult to manage and scale these policies. Policy as code, a software development approach, allows developers to write policies as code that can be versioned, tested, and deployed like any other code. This approach brings scalability, flexibility, and auditability to the management of permissions. <a title="https://www.permit.io/blog/opa-vs-cedar#the-benefits-of-using-pac" href="https://www.permit.io/blog/opa-vs-cedar#the-benefits-of-using-pac"><u>Learn more about the advantages of PAC here</u></a>. </p><h2><strong>Q: How does the integration between Permit.io and AWS Cedar work?</strong></h2><p><strong>A:</strong> The integration between Permit.io and AWS Cedar comprises three new exciting features:</p><ul><li><div><p>Permit is among the first to provide access to Cedar via its SaaS. This allows organizations to leverage the power of Cedar&#39;s policy engine within the Permit.io no-code permission management platform. It provides a seamless experience for managing and enforcing fine-grained access control using Cedar policies while benefiting from Permit.io&#39;s features (More on that below) and control plane.</p></div></li><li><div><p>Our new open-source project, <a title="https://github.com/permitio/cedar-agent" href="https://github.com/permitio/cedar-agent"><u>Cedar-Agent</u></a>, provides Cedar as a standalone agent you can deploy alongside your services.</p></div></li><li><div><p>Our open-source project <a title="https://github.com/permitio/opal" href="https://github.com/permitio/opal"><u>OPAL</u></a> now offers Cedar support (in addition to Open Policy Agent), expanding its ability to support more and more use cases, enabling Cedar Agents to be loaded with the policy and data they need in real-time.</p></div></li></ul><h2><strong>Q: How does Permit.io simplify the adoption of AWS Cedar?</strong></h2><p><strong>A:</strong> Permit.io simplifies the adoption of AWS Cedar by providing a low-code/no-code policy editor that generates Cedar code. This allows developers, and even non-technical stakeholders, to quickly get started with Cedar without needing to learn the intricacies of the language. It streamlines the initial adoption process and accelerates the implementation of Cedar-based access control. </p><h2><strong>Q: What features does Permit.io provide on top of Cedar?</strong></h2><p><strong>A:</strong> Permit.IO&#39;s integration of Cedar&#39;s policy engine offers several features that enhance its functionality. It can run on top of Amazon Verified Permissions (AVP) or Cedar-Agent, providing a control plane and interfaces for easier policy management. Notable features include:</p><ul><li><div><p>A policy editor that generates code and pushes it to Git</p></div></li><li><div><p>SDKs for creating enforcement points in code and across the stack </p></div></li><li><div><p>An API for managing objects like roles, resources, actions, tenants, projects, and environments, authorization for authorization to control permissions changes. </p></div></li><li><div><p>Embeddable UI components via <a title="https://www.permit.io/elements" href="https://www.permit.io/elements"><u>Permit Elements</u></a></p></div></li><li><div><p>Multi-tenancy support</p></div></li><li><div><p>Audit logs</p></div></li><li><div><p>Live data and policy updates via OPAL</p></div></li><li><div><p>And much more.</p></div></li></ul><h2><strong>Q: Is the SaaS implementation of Cedar by Permit available to everyone?</strong></h2><p><strong>A:</strong> Cedar with Permit.io is available for early access via sign-up <a title="https://forms.gle/cUtFSnXGxoWoHec19" href="https://forms.gle/cUtFSnXGxoWoHec19"><u>here</u></a>  </p><h2><strong>Q: What is Cedar-Agent?</strong></h2><p><strong>A:</strong> <a title="https://github.com/permitio/cedar-agent" href="https://github.com/permitio/cedar-agent"><u>Cedar-Agent</u></a> is an open-source project developed by Permit.io that enables the deployment and execution of AWS Cedar as a standalone agent. Similar to how you would use <a title="https://github.com/open-policy-agent/opa" href="https://github.com/open-policy-agent/opa"><u>OPA (Open Policy Agent)</u></a>, Cedar-Agent allows you to run Cedar independently and leverage its powerful authorization capabilities. With Cedar-Agent, you have the flexibility to manage and enforce policies using the Cedar language in various environments.</p><h2><strong>Q: What is OPAL? How does it help enhance Cedar?</strong></h2><p><strong>A:</strong> <a title="https://github.com/permitio/opal" href="https://github.com/permitio/opal"><u>OPAL</u></a> (Open Policy Administration Layer) is an open-source project created by Permit.io. OPAL plays a crucial role in enhancing your policy engine of choice (be it Cedar or OPA) by providing it with real-time policy and data updates, ensuring your agents are equipped with the necessary policies and data for consistent and reliable enforcement. By expanding the OPAL ecosystem, the project fosters collaboration, establishes standards, and promotes best practices in policy management.</p><h2><strong>Q: What is the difference between Cedar and OPA? </strong></h2><p><strong>A: </strong>Cedar and OPA (Open Policy Agent) are both powerful policy-as-code languages and engines, but they have distinct characteristics and areas of focus. Cedar, developed by AWS, is specifically designed for application-level authorization. On the other hand, OPA, a CNCF project, is widely used for infrastructure-level access control and admission control in Kubernetes. To delve deeper into the differences between Cedar and OPA, <a title="https://www.permit.io/blog/opa-vs-cedar" href="https://www.permit.io/blog/opa-vs-cedar"><u>check out this blog</u></a>.<br></p><h2><strong>Q: Can the Cedar agent be self-hosted on Kubernetes and later moved to the cloud version?</strong></h2><p><strong>A:</strong> Yes, the Cedar agent can be self-hosted on Kubernetes. Running the agent locally (known as the PDP or Policy Decision Point) is the default option for production when using OPA or Cedar agent. It provides flexibility and control during development and testing. However, the agent can also be hosted in the cloud. While hosting the agent in the cloud is possible, it is recommended to work with it locally and manage it in the cloud for better control and performance.</p><h2><strong>Q: How does Permit.IO&#39;s implementation of Cedar compare to Amazon Verified Permissions Service?</strong></h2><p>A: Permit.io (with Cedar) runs on top of Amazon Verified Permissions (AVP) or Cedar-Agent. It adds a control plane and interfaces on top, such as the policy editor that generates Cedar (or Rego) code for easier policy management.</p><p>The integration between Permit.io and AWS Cedar brings together the power of fine-grained authorization and a comprehensive control plane, enabling developers and organizations to manage permissions and access control in the cloud-native world effectively. By leveraging policy as code and the capabilities of Cedar-Agent and OPAL, teams can easily decouple policy from code, achieve greater flexibility, and enhance auditability. </p><h2><strong>Got more questions? </strong></h2><p><a title="https://io.permit.io/permitslack" href="https://io.permit.io/permitslack"><u>Join our community</u></a> to explore more about Permit.io&#39;s integration with Cedar, ask questions, and get support for your authorization needs! </p>]]></content>
        <author>
            <name>Daniel Bass</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Migrating from RBAC to ABAC with Permit.io]]></title>
        <id>rbac-to-abac</id>
        <link href="https://www.permit.io/blog/rbac-to-abac"/>
        <updated>2023-05-16T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Migrating from Role-based access control (RBAC) to Attribute-based access control (ABAC) can prove quite challenging - here's how you can do it painlessly. ]]></summary>
        <content type="html"><![CDATA[<h2>RBAC VS ABAC</h2><p><a title="https://www.permit.io/blog/rbac-with-permit" href="https://www.permit.io/blog/rbac-with-permit"><strong>Role-based access control (RBAC)</strong></a> has been a popular authorization approach for decades. After a user logs in to the system (is Authenticated), RBAC allows assigning permissions to application-level roles, which in turn provide or deny access to certain areas of an application. <br><br>However, RBAC has limitations and is often insufficient for modern applications with complex authorization requirements. <br><br>This is where <a title="https://www.permit.io/blog/what-is-abac" href="https://www.permit.io/blog/what-is-abac"><u><strong>Attribute-based access control (ABAC)</strong></u></a> comes in.</p><p>ABAC is a more granular method of managing permissions. Instead of relying solely on predefined roles, it allows considering various attributes to make access decisions. These attributes can include user data, location, time, and many more. While ABAC provides a more flexible and fine-grained approach to authorization, it can be really complex to set up and manage - making the migration process from RBAC to ABAC extremely challenging for developers.</p><h2>When is RBAC not enough? </h2><p>Let&#39;s consider a practical example. Imagine a fintech application that allows users to invest in various financial products, such as stocks, bonds, and funds. Initially, the application uses a traditional RBAC approach to manage authorization, with roles such as &quot;basic user,&quot; &quot;premium user,&quot; and &quot;administrator.&quot;</p><p>Over time, the application evolves, and the variety of services it provides increases. It now needs to provide access based on attributes such as: <br></p><ol><li><div><p>Time of day: Certain financial products may only be available for investment during specific times of the day, such as when certain markets are open.</p></div></li><li><div><p>Investment type: Users may only be authorized to invest in certain types of financial products based on their risk profile, investment objectives, and other factors.</p></div></li><li><div><p>Investment amount: Depending on the user&#39;s investment history, they may be authorized to invest higher or lower amounts in certain financial products.</p></div></li><li><div><p>Location: Certain financial products may only be available for investment in certain geographic locations, depending on local regulations and laws.</p></div></li></ol><p>In a Fin-Tech application, we can have more application-specific attributes like ”Portfolio diversity, which authorizes users to invest in a certain number of different financial products to ensure portfolio diversity, or Investment experience, which allows users with more investment experience may be authorized to invest in more complex financial products with higher risks.</p><p>Each application may have application specific authorization rules that depend on the context of what the application allows its users to do. <br><br>An RBAC system won’t be able to support managing permissions for any of these services (Let alone all of them) ABAC, on the other hand, provides a more granular approach, being able to handle much more complex authorization policies, allowing your application to offer a much wider variety of services. </p><p><a title="https://www.permit.io/blog/rbac-vs-abac" href="https://www.permit.io/blog/rbac-vs-abac"><u>You can learn more about the decision between RBAC and ABAC here</u></a>. </p><h2>The journey from RBAC to ABAC</h2><p>Based on dozens of conversations with other developers who went through this exact scenario building their own application, the journey from homebrew RBAC to ABAC is usually described somewhere along the lines of ‘<em>terrible, time-consuming, meticulous, frustrating, and generally extremely unpleasant’</em>. </p><p><strong>The migration from a homebrew RBAC solution to ABAC can take from a few weeks to several months of RnD work</strong>, <strong>and often includes</strong> <strong>a complete overhaul of the existing RBAC-based permission management system</strong>. </p><p>The process of migrating from homebrew RBAC to ABAC involves several steps:</p><p>First, you need to analyze the existing RBAC system and identify its limitations and areas for improvement. Next, you need to define the attributes for the new ABAC system, such as user data, location, and time. </p><p>Then, the new ABAC system must be designed and implemented, ensuring full integration with the application. Finally, the system needs to be tested thoroughly to ensure it functions correctly and meets the organization&#39;s security and compliance requirements. This entire journey will require you to devote the entirety of your time to building your new authorization layer instead of developing the core unique features of the application. <br><br>A key problem that devs face here is <strong>performance</strong>: The data for ABAC queries often requires different database schemas, and expecting the application&#39;s default db schema to work efficiently for ABAC out of the box usually leads to db performance issues and application downtime.</p><p>The story doesn’t end there either - </p><p>Once you have ABAC set up, creating additional roles, attributes, and policies requires ongoing, complex R&amp;D work. This creates a situation where<strong> developers become bottlenecks in your app’s permission management</strong>, and other stakeholders are locked out of the conversation.</p><p>Not to mention the fact that as various requirements from customers, security, compliance, and 3rd party integrations come in, <strong>you might need to refactor your entire authorization system every 3-6 months</strong>.</p><h2>From RBAC to ABAC with Permit</h2><p>Permit makes the transition from RBAC to ABAC much easier by offering a simple no-code permissions management UI. Providing full stack authorization as a service, Permit allies you to define policies based on user attributes and context without needing to write any custom code or make significant changes to the application&#39;s architecture. </p><p>Permit provides a permission management solution that makes policy-as-code as easy as checking a checkbox - generating the needed code for you, and wrapping it nicely into Git, and API / UI interfaces.</p><p>This allows for both easy implementation and management of RBAC and ABAC, and a seamless transition between the two - all without writing a single line of code. </p><p><a title="https://www.permit.io/blog/what-is-abac#permit-a-ui-for-managing-abac" href="https://www.permit.io/blog/what-is-abac#permit-a-ui-for-managing-abac"><u>Learn how to setup ABAC policies with Permit’s UI here</u></a></p><img src="https://media.graphassets.com/8dmqmNLVRyaVDRiWScRL" alt="pasted image 0 (1).png" title="pasted image 0 (1).png" width="649" height="154" /><img src="https://media.graphassets.com/LGXMhn9QFGYxwSUhYWRd" alt="pasted image 0.png" title="pasted image 0.png" width="649" height="202" /><img src="https://media.graphassets.com/GuVrkR6tQeGdiETElLXp" alt="pasted image 0 (2).png" title="pasted image 0 (2).png" width="632" height="528" /><p><em>Permit’s No-Code ABAC UI</em></p><p>While RBAC has been a reliable authorization approach for many years, it is often insufficient for modern applications with complex authorization requirements. ABAC provides a more flexible and granular approach that can adapt to an organization&#39;s changing needs. However, migrating from RBAC to ABAC can be a challenging process. With the help of tools like Permit, you can make the transition much more manageable and enjoy the benefits of ABAC.</p><p>Want to learn more about Authorization? Join our <a title="https://io.permit.io/permitslack" href="https://io.permit.io/permitslack"><u>Slack community</u></a>, where there are hundreds of devs building and implementing authorization.</p>]]></content>
        <author>
            <name>Daniel Bass</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Policy as Code: OPA's Rego vs. Cedar]]></title>
        <id>opa-vs-cedar</id>
        <link href="https://www.permit.io/blog/opa-vs-cedar"/>
        <updated>2023-05-15T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[What are the benefits of policy as code, and how does OPA's Rego language differ from AWS' new Cedar policy language? ]]></summary>
        <content type="html"><![CDATA[<p><strong></strong><a title="https://www.permit.io/blog/what-is-policy-as-code" href="https://www.permit.io/blog/what-is-policy-as-code"><strong>Policy as code (PAC)</strong></a> is a software development approach that treats authorization policies as code. This means that policies are written in a programming language, such as Rego or Cedar, and are stored in a version control system alongside the rest of the code. </p><p>This blog discusses the benefits of PAC and dives deeper into the difference between two popular PAC languages: Rego, the language of <a target='_blank' title="https://www.permit.io/blog/introduction-to-opa" href="https://www.permit.io/blog/introduction-to-opa"><u>Open Policy Engine (OPA)</u></a>, a CNCF project, and <a target='_blank' title="https://www.cedarpolicy.com/" href="https://www.cedarpolicy.com/"><u>Cedar</u></a> - the language used by Amazon Verified Permissions (AVP), an AWS-hosted service that provides fine-grained authorization for application-level resources.</p><h2>The benefits of using PAC:</h2><ul><li><div><p><strong>Decoupling policy from code:</strong> PAC allows you to decouple policy from code, which makes it easier to manage and update policies.</p></div></li><li><div><p><strong>Increased flexibility:</strong> PAC gives you more flexibility in how you define policies, allowing you to use a variety of programming constructs to create complex policies.</p></div></li><li><div><p><strong>Improved performance:</strong> PAC can improve performance by offloading policy evaluation from the application to a dedicated policy engine.</p></div></li></ul><h2>What do Rego and Cedar have in common?</h2><ul><li><div><p>Both are open-source.</p></div></li><li><div><p>Both are policy as code.</p></div></li><li><div><p>Both focus on decoupling policy from code.</p></div></li><li><div><p>Both are general-purpose languages and decision engines.</p></div></li><li><div><p>Both are focused on performance and auditability.</p></div></li><li><div><p>Both support compilation to WASM.</p></div></li><li><div><p>Both enable low latency by running the policy engine at or close to the consuming service.</p></div></li><li><div><p>Both are logical-programming languages.</p></div></li><li><div><p>Both can be managed at scale with <a target='_blank' title="https://github.com/permitio/opal" href="https://github.com/permitio/opal"><u>OPAL</u></a>.</p></div></li></ul><h2>What are the key differences?</h2><ul><li><div><p><u><strong>Area of focus</strong></u>: OPA is a CNCF project, and is mostly used for infrastructure-level access control (service to service, admission control in K8s). Cedar is focused on application-level authorization.</p></div></li><li><div><p><u><strong>The language</strong></u>: <br>Rego is a Datalog / Prolog derivative. While also having logical programming aspects , Cedar is a functional programming language, which opts to be less generic in favor of a more domain-specific focus. Cedar is more strict and structured - with emphasis on safety by default (i.e. deny by default), and more assurances on correctness / security thanks to <a rel="noopener noreferrer" class="c-link" target='_blank' title="https://www.amazon.science/blog/how-we-built-cedar-with-automated-reasoning-and-differential-testing" href="https://www.amazon.science/blog/how-we-built-cedar-with-automated-reasoning-and-differential-testing">verification-guided development</a>.</p></div></li><li><div><p><u><strong>Readability and Analyzability</strong></u>: <br>Cedar is more readable than Rego. Cedar is more strictly typed, and has more focus on readability than Rego, with basic Cedar code more likely to be legible to a layman (Thanks to its clear opinionated structure), unlike Rego code, which can be extremely complex to read. Cedar&#39;s constructs are also designed to be amenable to automated reasoning.</p></div></li><li><div><p><u><strong>Tools and modules</strong></u>: <br>Rego has many built-in tools that can be used to do things like parsing GraphQL, JSON Web Tokens, searching a JSON graph, and more. Currently, Cedar doesn’t include such built-in tools, aiming for more of a pure language model.</p></div></li><li><div><p><u><strong>Underlying frameworks</strong></u>: <br>OPA and Rego are Go-based, while Cedar is Rust based. These are not dramatic differences, but they can be relevant if you’re looking to embed or extend the languages with other Go, or Rust code.</p></div></li><li><div><p><u><strong>Community and ecosystem</strong></u>: <br>OPA is a CNCF project, with a large community (though not very open - due to conflicts with Styra, the company behind OPA); Cedar has a <a target='_blank' title="http://cedar-policy.slack.com/" href="http://cedar-policy.slack.com/"><u>small blooming community</u></a> and the backing of AWS - known for its power to create cloud-native standards single-handedly.</p></div></li><li><div><p><u><strong>Running and testing</strong></u>: <br>Rego can be run as part of a Go SDK, CLI, as a daemon agent with OPA, and can be found embedded as a plugin in many common tools (e.g. Gatekeeper, Conftest, Envoy, Kong), Cedar can be run as a Rust SDK, CLI, and via <a target='_blank' title="https://github.com/permitio/cedar-agent" href="https://github.com/permitio/cedar-agent">Cedar-agent</a> as a standalone daemon.</p></div></li><li><div><p><u><strong>Managing Data</strong></u>: <br>Baseline Policy data is mapped easily in both engines as part of the code and is somewhat more structured in Cedar. Both engines also support loading dynamic data. Rego works with generic JSON documents mapped under top-level arguments `input` (for incoming requests) and `data`(in memory store). Cedar also uses JSON-like documents, which are referred to as “entity slices”, for input. These are automatically mapped into entities (i.e. principals, resources, and groups) - as such Cedar, unlike Rego, expects a specific format for the inputted JSON.<br><br>In-memory / mem-cached data in Cedar is only supported as part of the <a target='_blank' title="https://github.com/permitio/cedar-agent" href="https://github.com/permitio/cedar-agent">Cedar agent</a>.<br>Both engines are supported by <a target='_blank' title="https://github.com/permitio/opal" href="https://github.com/permitio/opal"><u>OPAL</u></a> which can manage both engines with policy and data in realtime (And even run them side by side)</p></div></li></ul><h2>Cedar / Rego Pros and Cons - A quick summary</h2><h3>Rego</h3><ul><li><div><p>Pros:</p></div><div><ul><li><div><p>Widely used and supported</p></div></li><li><div><p>A mature ecosystem of tools and modules</p></div></li><li><div><p>Flexible and expressive language</p></div></li></ul></div></li><li><div><p>Cons:</p></div><div><ul><li><div><p>Can be complex and difficult to learn</p></div></li><li><div><p>Not as readable as Cedar (especially for non-technical team members) </p></div></li></ul></div></li><li><div><p>General:</p></div><div><ul><li><div><p>More infrastructure and K8s oriented</p></div></li></ul></div></li></ul><h3>Cedar</h3><ul><li><div><p>Pros:</p></div><div><ul><li><div><p>More readable than Rego</p></div></li><li><div><p>More structured language </p></div></li><li><div><p>Backed by AWS</p></div></li></ul></div></li><li><div><p>Cons:</p></div><div><ul><li><div><p>Currently, not as widely used or supported as Rego</p></div></li><li><div><p>A smaller ecosystem of tools and modules</p></div></li></ul></div></li><li><div><p>General:</p></div><div><ul><li><div><p>More application permissions oriented </p></div></li></ul></div></li></ul><h2>Let’s look at some code</h2><p>Below is a simple RBAC+ownership (aka light ABAC)  in both languages.</p><h3><u>Rego⁠</u></h3><pre><code>package play

import future.keywords.if

default allow := false
allow if permit(input.principal, input.action, input.resource)

permit(&quot;alice&quot;, &quot;read&quot;, &quot;document&quot;) if input.resource_owner == input.principal


</code></pre><h3><u>Cedar</u></h3><pre><code>permit(
  principal == User::&quot;alice&quot;, 
  action    == Action::&quot;read&quot;, 
  resource  == Document::&quot;document&quot;
) when {
  resource.owner == principal
}</code></pre><p>As you can see, the two policies are very similar, and both languages can be considered declarative. The main difference is that the Rego policy uses a more loose and generic syntax, while the Cedar policy uses a more strict syntax - which adds clarity for even non-technical readers (with its “permit / when, unless” structure, and keywords (e.g. principal, action, resource))</p><h2>Bottomline: Which one to choose?</h2><p>In summary, Rego and Cedar are powerful policy-as-code languages and engines with distinct characteristics. While they share common features, such as being open-source, decoupling policy from code, and focusing on performance and auditability, they differ in their area of focus, language design, available tools and modules, and underlying infrastructure.</p><p>Both languages have a non-trivial learning curve and complexity associated with them (but as stated Ceder does have better readability) . To simplify the initial adoption process, tools like Permit.io can be useful. Permit.io offers a low-code UI solution to generate Rego or Cedar code, enabling developers (and nontechnical stakeholders) to get started more quickly and overcome the initial challenges of these languages.</p><p>Ultimately, the choice between Rego and Cedar depends on the specific use case and requirements, while using code generation tools can enable faster adoption and easier flexibility in switching or mixing the two. So perhaps you don’t have to choose.<br></p><h4>Further learning:⁠</h4><ul><li><div><a target='_blank' title="https://docs.cedarpolicy.com/" href="https://docs.cedarpolicy.com/">Cedar Docs</a> | <a target='_blank' title="https://www.openpolicyagent.org/docs/latest/" href="https://www.openpolicyagent.org/docs/latest/">OPA Docs</a></div></li><li><div><a target='_blank' title="https://www.cedarpolicy.com/en/playground" href="https://www.cedarpolicy.com/en/playground">Cedar Playground</a> | <a target='_blank' title="https://play.openpolicyagent.org/" href="https://play.openpolicyagent.org/">Rego Playground</a></div></li><li><div><a title="https://docs.opal.ac/tutorials/cedar" href="https://docs.opal.ac/tutorials/cedar">OPAL Cedar docs</a> | <a target='_blank' title="https://docs.opal.ac/getting-started/running-opal/run-opal-client/opa-runner-parameters" href="https://docs.opal.ac/getting-started/running-opal/run-opal-client/opa-runner-parameters">OPAL OPA docs</a></div></li><li><div><a target='_blank' title="https://www.youtube.com/watch?v=k6pPcnLuOXY" href="https://www.youtube.com/watch?v=k6pPcnLuOXY">Cedar talk</a> <a target='_blank' title="https://www.youtube.com/watch?v=k6pPcnLuOXY" href="https://www.youtube.com/watch?v=k6pPcnLuOXY">(AWS re:Invent)</a> [<a target='_blank' title="https://d1.awsstatic.com/events/Summits/reinvent2022/SEC335_NEW-LAUNCH!-Using-policies-to-manage-permissions-with-Amazon-Verified-Permissions.pdf" href="https://d1.awsstatic.com/events/Summits/reinvent2022/SEC335_NEW-LAUNCH!-Using-policies-to-manage-permissions-with-Amazon-Verified-Permissions.pdf">slides</a>] | <a target='_blank' title="https://www.youtube.com/watch?v=MhyQxIp1H58" href="https://www.youtube.com/watch?v=MhyQxIp1H58">OPA talk (CNCF)</a></div></li></ul><p></p>]]></content>
        <author>
            <name>Or Weis</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Open-Sourcing AWS Cedar is a Gamechanger for IAM]]></title>
        <id>oss-aws-cedar-is-a-gamechanger-for-iam</id>
        <link href="https://www.permit.io/blog/oss-aws-cedar-is-a-gamechanger-for-iam"/>
        <updated>2023-05-10T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[The launch of AWS' OSS - Cedar is a tectonic shift in the IAM space. Permit.io supports with OPAL and Cedar-Agent.]]></summary>
        <content type="html"><![CDATA[<p>In today&#39;s cloud-native world, managing permissions and access control has become a critical challenge for many organizations. As applications and microservices become more distributed, it&#39;s essential to ensure that only the right people and systems have access to the right resources. However, managing this complexity can be difficult, especially as teams and organizations grow. That&#39;s why the launch of <a class="sc-cSHVUG ldzkQ" title="https://www.cedarpolicy.com/en" href="https://www.cedarpolicy.com/en">Cedar</a>, a new open-source project from AWS, is a tectonic shift in the IAM space, making it clear that the problem of in-app permissions has grown too big to ignore.</p><h2>The problem of in-app permissions</h2><p>Traditionally, organizations have relied on access control lists (ACLs) and <a title="https://www.permit.io/blog/rbac-with-permit" href="https://www.permit.io/blog/rbac-with-permit">role-based access control (RBAC)</a> to manage permissions. However, as the number of resources and users grows, it becomes difficult to manage and scale these policies. This is where policy as code emerges as a de-facto standard. It enables developers to write policies as code, which can be versioned, tested, and deployed like any other code. This approach is more scalable, flexible, and auditable than traditional approaches.</p><h2>The Advantages of Cedar</h2><p>Aside from impressive performance, one of the most significant advantages of Cedar is its readability. The language is designed to be extremely readable, empowering even non-technical stakeholders to read it (if not write it) for auditing purposes. This is critical in today&#39;s world, where security and compliance are top priorities. Cedar policies are written in a declarative language, which means they can be easily understood and audited. Cedar also offers features like policy testing and simulation, which make it easier to ensure that policies are enforced correctly. ⁠</p><h2>Polyglot Policy as Code</h2><p>As developers, being polyglot is first nature, and as critical as using the right tool and language for each task. This is why Permit.io supports <strong>low-code / no-code</strong> interfaces that generate RBAC and <a title="https://www.permit.io/blog/what-is-abac" href="https://www.permit.io/blog/what-is-abac">attribute-based access control </a>(ABAC) policy as code for you. Permit.io started by <a title="https://www.permit.io/blog/introduction-to-opa" href="https://www.permit.io/blog/introduction-to-opa">supporting Open Policy Agent (OPA)&#39;s Rego</a>, and now takes this a huge leap forward by supporting AWS&#39; Cedar as well. Cedar is a wonderful language to learn, but with Permit&#39;s policy-editor you don&#39;t have to in order to get started, or to enjoy the benefits of the engine and framework itself.</p><h2>Announcing Permit.io&#39;s new OSS: Cedar-Agent</h2><p>Permit.io is proud to be the first to support AWS&#39; Cedar, providing access to it as a SaaS service even before AWS itself, as well as via OPAL its open-source project. A key enabler for this, is a companion open-source project to Cedar:  <a class="sc-cSHVUG ldzkQ" title="https://github.com/permitio/cedar-agent" href="https://github.com/permitio/cedar-agent">Cedar agent</a>. Cedar-agent, an OSS project from Permit.io - provides the ability to run Cedar as a standalone agent (Similar to how one would use OPA) which can then be powered by <a class="sc-cSHVUG ldzkQ" title="https://github.com/permitio/opal" href="https://github.com/permitio/opal">OPAL</a>. Cedar agent is the easiest way to deploy and run Cedar</p><h2>OPAL - bridging the IAM permissions space</h2><p>Permit.io&#39;s open-source project <a class="sc-cSHVUG ldzkQ" title="https://github.com/permitio/opal" href="https://github.com/permitio/opal">OPAL</a>, the Open Policy Administration Layer, is a bridging component that creates a standard across the IAM space to consume and use policy as code. OPAL makes sure that agents like OPA, AVP (Amazon Verified Permissions), and Cedar-Agent are loaded with the policy and data they need in real-time. This ensures that policies are enforced consistently across different tools and systems.</p><h2>The expanding OPAL ecosystem</h2><p>As the <a class="sc-cSHVUG ldzkQ" title="https://github.com/permitio/opal" href="https://github.com/permitio/opal">OPAL</a> ecosystem expands to support more and more use cases, it produces standards and best practices for everyone to use. This means that developers can use OPAL to write policies once and deploy them across different tools and systems. This reduces the cognitive load on developers and makes it easier to manage permissions at scale.</p><h2>Conclusion:</h2><p>The launch of AWS&#39; Cedar is a tectonic shift in the IAM space. It&#39;s clear that the problem of in-app permissions has grown too big to ignore. Policy as code has emerged as a de-facto standard, and tools like OPAL and Permit.io are making it easier for developers to write and manage policies at scale. Cedar&#39;s readability and testing features make it an attractive choice for many organizations looking to manage permissions in a scalable, auditable, and flexible way. And Cedar-agent becomes the easiest way to utilize Cedar, as well as connecting it to OPAL. As the OPAL ecosystem continues to expand, it&#39;s likely that we&#39;ll see more tools and systems adopting policy as code as the preferred approach to manage permissions and access control.</p><p></p><p><em>⁠This article was </em><a target='_blank' title="https://thenewstack.io/open-sourcing-aws-cedar-is-a-game-changer-for-iam/" href="https://thenewstack.io/open-sourcing-aws-cedar-is-a-game-changer-for-iam/"><em>originally published on TheNewStack </em></a><br></p>]]></content>
        <author>
            <name>Or Weis</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Planning App Role-Based Access Control (RBAC) Implementation]]></title>
        <id>planning-app-rbac</id>
        <link href="https://www.permit.io/blog/planning-app-rbac"/>
        <updated>2023-04-27T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[When building an app, good authorization is a must, and planning it ahead is critical. How do you plan effective, secure, and scalable AuthZ? Learn here -]]></summary>
        <content type="html"><![CDATA[<h1>Planning your App’s Role-Based Access Control (RBAC) Implementation</h1><p>When building an application, managing access to resources is critical to ensuring data security and privacy. Once you have <a title="https://www.permit.io/blog/authn-vs-authz" href="https://www.permit.io/blog/authn-vs-authz">authentication </a>(verifying the user identity) covered, the next step is to think about how your authorization layer (who can do what) should function. </p><p>The importance of planning user roles for your app can&#39;t be stressed enough. Well-planned user authorization can not only help prevent security breaches but also improve scalability and can reduce development time. Taking the time to plan user roles and authorizations is undoubtedly worth it in the long run.</p><p>In this post, we&#39;ll explore the importance of mapping your authorization layer in advance, scaling it for the future, when it might be necessary to <a title="https://www.permit.io/blog/rbac-to-abac" href="https://www.permit.io/blog/rbac-to-abac">upgrade to attribute-based access control (ABAC)</a>, and how all these steps can be achieved as painlessly as possible - allowing you to focus on the thing you care about most: building cool, unique features. </p><h2>Planning User Roles</h2><p>When designing an application, it&#39;s essential to consider the roles that users will play within the system. It’s important to know that organization-level roles are not always clearly translated into application-level roles. Understanding how this translation is made, which roles should exist on the application level, and which actions should be able to perform on which resources is the first step of understanding how your authorization layer should look like.    <br><br>Each role may have access to different resources and data within the application, and it&#39;s critical to ensure that the right people have the right level of access. By defining user roles and their associated permissions, you can ensure that access to data is granted only to those who need it, reducing the risk of unauthorized access and data breaches. <br><br>The approach of defining Role-based access control (RBAC) is a widely-used mechanism for granting or denying access to specific resources based on a user&#39;s role. </p><h2>Mapping Your Authorization Layer in Advance</h2><p>To ensure that user roles and permissions are properly defined, it&#39;s important to map out the authorization layer in advance. This includes defining the resources that need to be protected and identifying the roles that will have access to them. By mapping out the authorization layer in advance, you can ensure that the necessary security controls are in place and that access to resources is properly restricted. Additionally, this can help to reduce development time and prevent bottlenecks in the development process.</p><p>Here&#39;s an example of what that might look like: </p><ol><li><div><p><strong>Resource:</strong> Customer Information<br><br><strong>Role:</strong> Admin<br><strong>Allowed actions:</strong> View, Edit, Delete<br><br><strong>Role:</strong> Customer Support<br><strong>Allowed actions:</strong> View, Edit</p></div></li><li><div><p><strong>Resource:</strong> Order Information<br><br><strong>Role:</strong> Admin<br><strong>Allowed actions:</strong> View, Edit, Delete<br><br><strong>Role:</strong> Manager<br><strong>Allowed actions:</strong> View, Edit<br><br><strong>Role:</strong> Salesperson<br><strong>Allowed actions:</strong> View</p></div></li></ol><p>In this example, <strong>two resources </strong>are identified: Customer Information and Order Information. </p><p>The roles that have access to each resource are then defined, along with the specific permissions that each role has. For instance, the Admin role has full access to both Customer Information and Order Information, including the ability to view, edit, and delete. However, the Salesperson role only has access to view Order Information.</p><p>By mapping out the authorization layer in advance, developers can ensure that the necessary security controls are in place and that access to resources is properly restricted. Additionally, this can help to reduce development time and prevent bottlenecks in the development process.</p><h2>Be ready to scale</h2><p>As your application grows, it&#39;s important to ensure that your authorization layer can scale with it. This means ensuring that your RBAC model can handle an increasing number of roles and permissions without creating bottlenecks in the development process. This can be achieved by structuring your authorization layer in a way that allows for easy modification and expansion. By doing so, you can ensure that your application remains secure and that users have access to the resources they need, even as your user base and application functionality grows.<br><br>The solution is implementing and managing your RBAC and ABAC policies using an authorization service that allows for <strong>flexible transition between authorization models</strong>.</p><h2>Upgrading to Attribute-Based Access Control (ABAC)</h2><p>While RBAC is a widely-used mechanism for managing access to resources, it may not be enough in some cases. <a title="https://www.permit.io/blog/what-is-abac" href="https://www.permit.io/blog/what-is-abac"><u>Attribute-based access control (ABAC)</u></a> is a more granular approach to access control that allows for more detailed and context-specific permissions. ABAC uses attributes such as time, location, and user behavior to determine access to resources, providing a higher level of security than traditional RBAC models.</p><p>Here&#39;s a practical example: Imagine a company that develops software for the healthcare industry. The application has multiple user roles, including doctors, nurses, and administrators. In the RBAC model, each role is granted access to specific resources based on their job function. However, with ABAC, access to resources can be more granularly defined based on the specific patient the user is accessing records for, the time of day, and even the location of the user.</p><p><a title="https://www.permit.io/blog/rbac-vs-abac" href="https://www.permit.io/blog/rbac-vs-abac"><u>Learn more about the choice between RBAC and ABAC</u></a></p><p>As your application will grow, its authorization requirements will grow along with it. If you don’t plan ahead and implement a scalable authorization solution that allows for easy migration between policy models, <strong>you might end up refactoring your entire authorization system every 3-6 months</strong>.</p><h2>I mapped it out - now what? </h2><p>Once you planned the permission model needed in your application, it’s time to implement it!<br><br>Building, implementing, and maintaining your own authorization solution can take months of complex R&amp;D work and steep learning curves.</p><p>Also, if only your developers know how to operate this system, they will become bottlenecks in your app’s permission management, other stakeholders will be locked out of the conversation, and your customers will be left without the flexibility they require. </p><p>That’s where Permit comes in - <br><br>Permit provides developers with a permission management solution that allows you to implement your planned-out model within minutes using an intuitive no-code UI for both RBAC and ABAC. Permit’s UI generates policy code for you (In the <strong>Rego </strong>language used by Open Policy Agent), and wraps it nicely into Git and API/UI interfaces that you can edit, add to, and manage however you like.</p><p>This means you can not only implement RBAC quickly but also transition from RBAC to ABAC without writing a single line of code. </p><p>By implementing authorization with Permit, you can ensure that your planned authorization model is seamlessly integrated into your application, without creating bottlenecks in the development process.</p><h2>Implementing RBAC with Permit</h2><p>Here’s the same RBAC example we mapped before, expressed within Permit’s UI: <br><br>An <strong>Admin </strong>can perform any action on both resources -</p><img src="https://media.graphassets.com/resize=width:432,height:246/tqDLXODxQgKFjDTLHWSB" alt="Admin RBAC" title="unnamed.png" width="432" height="246" /><p>A <strong>Customer Support</strong> representative can only view and edit customer information -</p><img src="https://media.graphassets.com/resize=width:431,height:238/luGaVWsTHSG55G4PACgn" alt="Customer RBAC" title="unnamed.png" width="431" height="238" /><p>A <strong>Manager </strong>can only view and edit order information -</p><img src="https://media.graphassets.com/resize=width:431,height:237/3wIsOXfSfi0oTvz6MCyB" alt="Manager RBAC" title="unnamed.png" width="431" height="237" /><p>A <strong>Salesperson </strong>can only view order information</p><img src="https://media.graphassets.com/resize=width:430,height:234/WzFBVt3SLy4iIS4VfQ8I" alt="Salesperson RBAC" title="unnamed.png" width="430" height="234" /><p><br>Changing any type of permissions, adding new resources or roles, or adding attributes (Thus switching to ABAC) can be done with nothing but a few clicks -</p><h2>Migrating to ABAC With Permit</h2><p>Let’s say we need to add an attribute-based policy into the mix. A policy that only allows for <strong>EU-based Managers</strong> to view <strong>Information of EU-based Customers</strong>. </p><p>With Permit’s UI, this can be achieved as simply as:</p><p>1. Edit the <strong>‘Customer Information</strong>’ resource to include a “<strong>Location</strong>” string attribute.<br></p><img src="https://media.graphassets.com/bBJIw3HERFq213YNxdvk" alt="unnamed.png" title="unnamed.png" width="599" height="713" /><p>2. Add a new “Resource Set” for<strong> EU-based Customer Information</strong>. This allows managing policies specifically to Costumer information with location=EU</p><img src="https://media.graphassets.com/resize=width:595,height:733/9CRnlzsxQHOt4AV1odjV" alt="location=eu" title="unnamed.png" width="595" height="733" /><p><br>3. Now that we have the resource set up let’s deal with the “<strong>Manager</strong>” role:<br>Add a new <strong>‘Location’ </strong>attribute in the “User Attributes” screen -</p><img src="https://media.graphassets.com/NAZ0OKgQbi5iWWUc0CfL" alt="unnamed.png" title="unnamed.png" width="747" height="440" /><p>This will allow us to create user sets with a <strong>‘Location’ </strong>attribute. <br><br>4. Create a new “User Set” of <strong>‘EU Managers’</strong>. This allows managing policies specifically to role=Manager and location=EU.<br></p><img src="https://media.graphassets.com/ZlYLdavQXWEpdjz8mQgB" alt="unnamed.png" title="unnamed.png" width="596" height="809" /><p><br>5. Just click the checkboxes!</p><img src="https://media.graphassets.com/Z7hSZ8xSOmEX520Nf8mW" alt="unnamed.png" title="unnamed.png" width="634" height="239" /><p>Now <strong>EU-based Managers</strong> can view <strong>Information on EU-based Customers</strong>. It’s as simple as that. The greatest thing about all this is that you can essentially migrate from RBAC to ABAC without changing a single line of code in your application!</p><h2>What did we learn? </h2><p>In conclusion, planning user roles and authorizations is a critical aspect of application development. By mapping out your authorization layer in advance and ensuring that it can scale with your application, you can reduce development time and prevent security breaches. While RBAC is a widely-used mechanism for managing access to resources, upgrading to ABAC may be necessary in some cases to achieve more granular access control. By following these best practices, you can ensure that your application remains secure and accessible to the right people. </p><p>Planning your authorization layer? Not sure how this fits into the specific needs of your application? Join our <a title="https://io.permit.io/permitslack" href="https://io.permit.io/permitslack"><u>Slack community</u></a>, where hundreds of devs, including top authorization professionals, are building and implementing authorization.</p>]]></content>
        <author>
            <name>Daniel Bass</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[How to Add RBAC Authorization to Auth0]]></title>
        <id>add-rbac-authorization-to-auth0</id>
        <link href="https://www.permit.io/blog/add-rbac-authorization-to-auth0"/>
        <updated>2023-04-26T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Learn how to add RBAC Authorization to your Auth0 application with Permit.io. Implement authz with low code and ensure only the right users have access. ]]></summary>
        <content type="html"><![CDATA[<h2>Authentication SaaS is everywhere</h2><p>The authentication and identity management world has changed dramatically over the last decade. As applications migrate to authentication-as-a-service providers such as <a title="https://auth0.com/" href="https://auth0.com/"><u>Auth0</u></a>, internal databases, and password hashes become a thing of the past. With these solutions, you can <strong>easily implement authentication into your app</strong> while taking advantage of great features such as federated identity, social logins, MFA, identity verification, and more. For a modern web application that needs to verify who its users are, you don’t need anything but to open an Auth0 account. After a short configuration setup, you can integrate a rich authentication feature set into your application with single lines of code.</p><h2>Authentication alone is not enough</h2><p>One of the access control challenges with Auth0 is the authorization phase. While Auth0 excels in<strong> verifying who the users are</strong>, they are limited in telling you <strong>what they can do</strong>. Having any authenticated user be able to perform any action poses great risks, as we recently saw in the <a title="https://www.permit.io/blog/bingbang" href="https://www.permit.io/blog/bingbang"><u>Bing hack incident</u></a>.</p><p><strong>Authorization is a critical phase</strong> in monitoring user access and making sure only <strong>the right people</strong> have <strong>the right access</strong> to <strong>the right resources</strong> within your application.</p><h2>The solution? Authentication SaaS + Authorization SaaS </h2><p><a title="https://www.permit.io/" href="https://www.permit.io/"><u>Permit.io</u></a> is a cloud service that provides a low-code tool for implementing and managing authorization. By configuring identities, resources, and actions, you can create policies and enforce them in your application. Basically the same concept as Auth0, but for authorization.</p><p><strong>Combining the two services</strong> gives your application<strong> a complete cycle of access control</strong> and helps you ensure your authenticated users can do only what they should be allowed to.</p><p>In this article, we will review the steps of implementing Auth0 together with Permit.io.</p><p>Using the <a title="https://auth0.com/docs/quickstart/webapp/nextjs/interactive" href="https://auth0.com/docs/quickstart/webapp/nextjs/interactive"><u>Auth0 getting started guide for Next.JS</u></a>, we will demonstrate how you can completely redefine the permission model of our application with nothing but a few lines of code - Limiting your Auth0 authenticated users to only perform the actions they are allowed within your app.</p><p>By the end of this article, you should have a solid understanding of how Permit.io can be implemented into your app in your favorite coding language using <a title="https://docs.permit.io/tutorials/quickstart/#integrate-sdk" href="https://docs.permit.io/tutorials/quickstart/#integrate-sdk"><u>any of our SDKs</u></a>.</p><p>Before we begin, let’s dive a little deeper into how these two solutions work together.</p><h2>Authentication vs. Authorization - Auth0 vs. Permit.io</h2><p>In an application that uses Auth0 for authentication, the authentication process is typically handled client side. This means that when a user attempts to access a protected resource, such as a restricted page or API endpoint, the client-side code sends a request to Auth0 to authenticate the user. Auth0 then returns a token that the client-side code can use to authenticate subsequent requests to the server.<br><br></p><img src="https://media.graphassets.com/4XaTPWUnTEeN9llJNzgl" alt="pasted image 0.png" title="pasted image 0.png" width="1600" height="871" /><p>Authorization, on the other hand, is typically performed server-side. This is because authorization involves enforcing access policies specific to the application and its resources. In order to enforce these policies, the server-side code needs access to the user&#39;s identity, which is typically included in the authentication token.</p><p>When using Permit.io, the authentication process remains unchanged. However, when a user attempts to access a protected resource, the server-side code sends a request to Permit.io, which checks whether the user is authorized to perform the requested action.</p><p></p><img src="https://media.graphassets.com/s4Pquf2lSwauzTrHJSx6" alt="pasted image 0.png" title="pasted image 0.png" width="1135" height="672" /><p>Permit.io uses the identity information provided by Auth0 to determine the user&#39;s permissions and enforce access policies. This means that the application can easily define fine-grained access controls based on user roles, permissions, and other attributes and enforce those controls in a central location.</p><h2>Demo Application</h2><p>To demonstrate the relationship between authentication and authorization, we created a simple  to-do application, with authentication already implemented into it based on the <a title="https://auth0.com/docs/quickstart/webapp/nextjs/interactive" href="https://auth0.com/docs/quickstart/webapp/nextjs/interactive"><u>Auth0 Next.JS getting started guide</u></a>. Let’s clone it and run it on your local environment.</p><p><strong>Note:</strong> while this article does not require you to have <a title="http://nextjs.org" href="http://nextjs.org"><u>Next.JS knowledge</u></a>, it requires an Auth0 account with a basic configuration, and Node.JS installed in your <a title="https://nodejs.org/en/download" href="https://nodejs.org/en/download"><u>local</u></a> or <a title="https://codesandbox.io/dashboard?import_repo=true" href="https://codesandbox.io/dashboard?import_repo=true"><u>remote</u></a> environment.</p><ol><li><div><p>Open the terminal and type the following command in your desired development folder</p><pre><code>npx create-next-app@latest permit-auth0-todo --use-npm --example https://github.com/permitio/permit-next-todo-starter auth0-tutorial &amp;&amp; cd permit-auth0-todo</code></pre></div></li><li><div><p>Paste your Auth0 keys in the .env.local file as listed below. To get your own keys in the desired format, <a title="https://auth0.com/docs/quickstart/webapp/nextjs/interactive#configure-the-sdk" href="https://auth0.com/docs/quickstart/webapp/nextjs/interactive#configure-the-sdk"><u>use this link</u></a> while logged in to your Auth0 account</p><pre><code>AUTH0_SECRET=&#39;&lt;auth0_secret&gt;&#39;
AUTH0_BASE_URL=&#39;http://localhost:3000&#39;
AUTH0_ISSUER_BASE_URL=&#39;&lt;auth0_issuer_base_url&gt;&#39;
AUTH0_CLIENT_ID=&lt;auth0_client_id&gt;
AUTH0_CLIENT_SECRET=&#39;&lt;auth0_client_secret&gt;&#39;</code></pre></div></li><li><div><p>Run the following command from the application folder</p><pre><code>npm run dev</code></pre></div></li><li><div><p>In your browser, go to localhost:3000, log in with one of your Auth0 users, and see the tasks list on the screen.</p><video controls width="undefined" height="undefined">
          <source src="https://media.graphassets.com/QKhyXZhXT3SOOntgd7Do" type="video/mp4" title="no_rbac.m4v" />
          Sorry, your browser doesn't support embedded videos.
        </video></div></li></ol><p>We now have an app with basic authentication rules set up and running. Now, let’s see how we can add a granular authorization layer into this app using Permit. </p><h2>Building Permissions - Roles and Attributes</h2><p>The first step when building authorization is designing your permission model. </p><p>The basic building blocks of every permission model are <strong>Identity</strong>, <strong>Resource</strong>, and <strong>Action</strong>. The relationship between these three elements defines <strong>access control policies</strong> (<strong>Identity</strong> can perform <strong>Action </strong>on a <strong>Resource</strong>).</p><h3>Identity</h3><p>The basic identities in our application are those provided by the Auth0 Authentication process. To create a permission model, we would need to translate those identities into roles (which will allow us to implement Role Based access control) or add attributes onto them (for <a title="https://www.permit.io/blog/what-is-abac" href="https://www.permit.io/blog/what-is-abac"><u>Attribute Based access control</u></a>).</p><h3>Resource</h3><p>As our application is quite simple, we have only one resource we want to manage access to - the tasks. Similar to identities, resources also have attributes that identify them. For example, tasks have an isCompleted attribute that identifies it as a completed task or an owner attribute that belongs to a particular user who created it.</p><h3>Action</h3><p>This part of the policy is the glue between the Identity and the resource. By understanding what actions identities can perform on resources, we can enforce our access control policies and decide who can do what on which resource within the app. </p><h3>The full picture </h3><p>We can describe the relationships between our identities, resources, and actions by putting them all on a table. By creating a separate table for each role, we can see exactly which actions this role can perform on our resource. </p><p>Here is an example of the permission model where Editor that can create tasks but not delete them while Moderator is not able to create tasks but can update them:<br></p><table><thead><tr><th><p>Admin</p></th></tr><tr><th><p>Action 👉</p><p>Resource 👇</p></th><th><p>Post</p></th><th><p>Put</p></th><th><p>Patch</p></th><th><p>Delete</p></th><th><p>Get</p></th></tr></thead><tbody><tr><td><p>Task</p></td><td><p>V</p></td><td><p>V</p></td><td><p>V</p></td><td><p>V</p></td><td><p>V</p></td></tr><tr><td><p>Editor</p></td></tr><tr><td><p>Task</p></td><td><p>V</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>V</p></td></tr><tr><td><p>Moderator</p></td></tr><tr><td><p>Task</p></td><td><p></p></td><td><p>V</p></td><td><p></p></td><td><p></p></td><td><p>V</p></td></tr><tr><td><p>Roles…</p></td></tr></tbody></table><h2>Building Permissions</h2><p>Now that we clearly know how our permissions should look, it’s time to log in to <a title="https://app.permit.io" href="https://app.permit.io">app.permit.io</a> and create it.</p><ol><li><div><p>Go to the <strong>Policy </strong>page and click  Create &gt; Resource</p></div></li><li><div><p>Create a <strong>Resource</strong>, and assign it with <strong>Actions</strong>:</p><img src="https://media.graphassets.com/Afs0IeB5SjCriKsyXD53" alt="Frame 68089.png" title="Frame 68089.png" width="1437" height="778" /></div></li></ol><p>Next, we will create our <strong>Roles</strong>:</p><ol><li><div><p>Go to the <strong>Policy </strong>page and click Create &gt; Role</p></div></li><li><div><p>Add the following roles</p><img src="https://media.graphassets.com/Xvfs8lbyT626o2nhYG0Q" alt="Frame 68088 (1).png" title="Frame 68088 (1).png" width="1437" height="778" /></div></li></ol><p>To make things easier, make sure to mirror the roles you have set up in Auth0. In your production application, you can think of the right way of maintaining one source of truth for roles in the application. </p><p>In the Auth0 admin application, go to User Management &gt; Roles and add the following.</p><img src="https://media.graphassets.com/Mq0jStRjSdSDRdMJRnnW" alt="pasted image 0.png" title="pasted image 0.png" width="1600" height="715" /><p>For each role, we would like to add a user assigned to this role. In Auth0, go to User Management &gt; Users and add the following. Pay attention that you assigned the relevant role to each user.</p><img src="https://media.graphassets.com/AAP9PQg5QC0xVG0Sk0xm" alt="pasted image 0.png" title="pasted image 0.png" width="1538" height="748" /><p>With the roles, resources, and actions you just created, we have an outline of the policy table configuration. Let’s go back to Permit.io policy editor screen and check the following boxes to adopt the policy for our needs.</p><img src="https://media.graphassets.com/pkXWMQrQsW1a1HGOLxQn" alt="Auth0 Policy Editor Screenshot.png" title="Auth0 Policy Editor Screenshot.png" width="1836" height="1000" /><h2>Manage Identities - Sync Users</h2><p>Having defined permissions in Permit.io, it is time to connect the dots between our authentication and authorization services and make Permit.io aware of our application users and roles managed by Auth0.</p><p>Auth0 provides the option to write actions that run as a result of user actions. We will use the <code>post-login</code> action to sync the users to Permit.io. This way, we can ensure every user login to our applications is updated with their roles in Permit.io. You can read more about actions <a title="https://auth0.com/docs/customize/actions/actions-overview" href="https://auth0.com/docs/customize/actions/actions-overview"><u>here</u></a>.</p><p>Follow the following steps to enable sync users action in your Auth0 account:</p><ol><li><div><p>In the Permit.io application, go to Project and copy the API key.</p><img src="https://media.graphassets.com/0aCsTw4YSmWvEa1p5vZG" alt="saveAPI.png" title="saveAPI.png" width="1600" height="898" /></div></li><li><div><p>In your Auth0 account, go to <code>Actions &gt; Library</code>, click the <code>+ Build Action</code> button, and create the following action.</p><img src="https://media.graphassets.com/MnrPFONURiKIti7PBSq6" alt="pasted image 0.png" title="pasted image 0.png" width="922" height="1024" /></div></li><li><div><p>In the online IDE opened, click the key icon on the left side, and paste your copied Permit SDK key.</p><img src="https://media.graphassets.com/ya93QzlJSEmQ1Bqjv56R" alt="pasted image 0.png" title="pasted image 0.png" width="928" height="804" /></div></li><li><div><p>In the same left bar, click the package icon to install permitio sdk in Auth0</p><img src="https://media.graphassets.com/2JfpPd4JTq6ZojlxJEJo" alt="pasted image 0.png" title="pasted image 0.png" width="722" height="588" /></div></li><li><div><p>Paste the following code that will sync users while they are login to the application.</p><pre><code>const { Permit } = require(&#39;permitio&#39;);

exports.onExecutePostLogin = async (event, api) =&gt; {
    const permit = new Permit({
        pdp: &#39;https://cloudpdp.api.permit.io&#39;,
        token: event.secrets.permit,
    });
    const { email, given_name: first_name, family_name: last_name } = event.user;
    const user = await permit.api.syncUser({
        key: email,
        email,
        first_name,
        last_name,
        attributes: {},
    });

    for (let role of event.authorization.roles) {
        await permit.api.assignRole({ role, tenant: &quot;default&quot;, user: email });
    }
};</code></pre></div></li><li><div><p>Click on the Deploy button, and we&#39;re done. All the users will sync to Permit.io after they log in.</p></div></li></ol><p>To test the user synchronization to Permit.io, go back to the browser and log out/log in with one of your users. Then, go to the Permit.io <code>Users</code> screen and see the new user appear at the table with the relevant role.</p><h3>Sync Troubleshooting</h3><p>If your users are not syncing between Auth0 and <a rel="noopener noreferrer" class="c-link c-link--focus-visible" target='_blank' title="http://permit.io/" href="http://permit.io/">Permit.io</a> at this point, no worries this can be tricky 😉, here are some suggestions to help you debug the sync functionality:</p><ol><li><div>Test the sync <a target='_blank' title="https://auth0.com/docs/customize/actions/test-actions" href="https://auth0.com/docs/customize/actions/test-actions">action in the Auth0 UI</a> and verify that it successfully syncs users to <a rel="noopener noreferrer" class="c-link c-link--focus-visible" target='_blank' title="http://permit.io/" href="http://permit.io/">Permit.io</a>. Ensure that all the attributes in the API call exists and valid in <a rel="noopener noreferrer" class="c-link c-link--focus-visible" target='_blank' title="http://permit.io/" href="http://permit.io/">Permit.io</a>.</div></li><li><div>Confirm that the <code>Login/Post Login</code> action is being called as a callback after login. You can check this by auditing the API logs in <a rel="noopener noreferrer" class="c-link c-link--focus-visible" target='_blank' title="http://permit.io/" href="http://permit.io/">Permit.io</a> under <code>Settings &gt; API Logs</code>.</div></li><li><div>If the previous steps do not resolve the issue, you can explore <a target='_blank' title="https://docs.permit.io/integrations/authentication/auth0/permit-integration/#31-sync-auth0-with-permit" href="https://docs.permit.io/integrations/authentication/auth0/permit-integration/#31-sync-auth0-with-permit">additional methods to synchronize users</a> to <a rel="noopener noreferrer" class="c-link c-link--focus-visible" target='_blank' title="http://permit.io/" href="http://permit.io/">Permit.io</a> for more advanced use cases.</div></li></ol><h2>Enforce Permissions in the Application</h2><p>At this point, we have everything configured in both Auth0 and Permit.io. The only thing left is adding enforcement points to our APIs. As we explained before, the enforcement will occur at the API route where we want to allow or deny a particular user to perform an action.</p><ol><li><div><p>Grab the SDK key again and paste it into the .env.local file in the following format.</p><pre><code>PERMIT_SDK_TOKEN=&lt;permit_sdk_token&gt;</code></pre></div></li><li><div><p>Run the following command from the terminal to install the Permit.io SDK into the project.</p><pre><code>⁠npm i permitio –save</code></pre></div></li><li><div><p>In the tasks.ts file, paste the following code just below the import.</p><pre><code>import { Permit } from &#39;permitio&#39;;

const permit = new Permit({
  pdp: &#39;https://cloudpdp.api.permit.io&#39;,
  token: process.env.PERMIT_SDK_TOKEN,
});</code></pre></div></li><li><div><p>Find the beginning of the handler and paste the following code. This code takes the identity that Auth0 provides and sends it to Permit.io to verify if the user is allowed to perform the operation.</p><pre><code>const isAllowedForOperation = await permit.check(
    session?.user?.email as string || &#39;&#39;,
    req.method?.toLowerCase() as string,
    &#39;Task&#39;
);</code></pre></div></li><li><div><p>At this point, we are only left to return an error if the user is not allowed.</p><pre><code>if (!isAllowedForOperation) {
    res.status(403).json({ message: &#39;forbidden&#39; });
    return;
}</code></pre></div></li></ol><p>After implementation, let’s go back to your application in the browser and see it in action. Go to the browser, log out with the current user, and log in with a different role user to see how the application responds differently to operations by user roles.</p><video controls width="undefined" height="undefined">
          <source src="https://media.graphassets.com/HGhJephQdaAqzNAMCt1g" type="video/mp4" title="with_rbac.m4v" />
          Sorry, your browser doesn't support embedded videos.
        </video><h2>What Next?</h2><p>Congratulations, you successfully implemented a fully functional permission model to an application and created fine-grained access control that enforces policies on what users can do. <br><br>As you saw in this post, Permit.io gives you a full-stack authorization management solution, so you don’t have to build one yourself. Permit.io provides SDKs for many programming languages, so you can investigate them and find the relevant solution for your particular application.</p><p>Permissions and authorization are essential to success in access control. Still, the model we created here is just the beginning of a good permissions model you can implement in the application. For example, what if you want to differentiate the same resource types by their attributes? What if you want a more granular level of control than user roles but user-detailed identity? For that and more, we recommend you to continue reading our learning materials, such as <a title="https://www.permit.io/blog/rbac-vs-abac" href="https://www.permit.io/blog/rbac-vs-abac"><u>the difference between RBAC and ABAC</u></a>, <a title="https://www.permit.io/abac" href="https://www.permit.io/abac"><u>adding ABAC to your application with Permit</u></a>, and more.</p>]]></content>
        <author>
            <name>Gabriel L. Manor</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Adopt Gitops Today - Here’s Why and How.]]></title>
        <id>gitops-today-why-and-how</id>
        <link href="https://www.permit.io/blog/gitops-today-why-and-how"/>
        <updated>2023-04-24T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Learn the best practices for implementing GitOps in your software development cycle. Read our article and adopt GitOps today to streamline your workflow.]]></summary>
        <content type="html"><![CDATA[<p>Although GitOps is a relatively new trend, developers have been using Git to automate processes for a long time, and so Gitops is becoming not just popular but a de facto standard very quickly. Case in point - At Permit.io, we use Gitops as a critical feature as part of our product- empowering our customers to manage policy as code across environments and setups. Git&#39;s branching mechanism, conflict resolution, native file versioning support, and advanced features make it a fantastic tool for our users while fulfilling the single-source-of-truth promise of <a title="https://www.permit.io/blog/what-is-policy-as-code" href="https://www.permit.io/blog/what-is-policy-as-code"><u>Policy-As-Code</u></a>.</p><p>As more organizations adopt GitOps as a DevOps practice, we believe it&#39;s an opportune time to share our experience building a GitOps-enabled tool. In this article, we&#39;ll discuss our experience developing GitOps as a feature for our users, providing best practices for you to excel in implementing it for your DevOps needs. Whether planning to use an existing GitOps tool or build your own, learning from our homegrown experience is invaluable. We hope you find our experience worthwhile.</p><h2>Why GitOps?</h2><p>Over the past few years, two trends have emerged that enable developers to expedite software development: low code and Infrastructure as Code. Low-code tools empower developers to incorporate a wide range of functionalities into their applications with minimal coding. On the other hand, Infrastructure as Code allows developers to declare and manage their infrastructure through coding and automated tools.</p><p>Initially, managing infrastructure and applications was relatively straightforward, and developers only needed a few lines of code. However, as the tools and requirements advanced, the amount of code necessary to manage infrastructure and applications increased. Furthermore, the need for a continuous deployment process complicated matters further by creating multiple code states.</p><p>As developers began using Git to manage their code manually, they started utilizing it as an operations automation tool. GitOps emerged as a result of this. While various tools can assist in GitOps implementation, we believe that the fundamental concept behind GitOps is a mindset. In the same manner that DevOps automated all operations, GitOps automates operations in a Git manner. This entails using Git&#39;s versioning and branching mechanisms to manage infrastructure and applications.</p><p>Since the primary principle of GitOps is to use a specific Git state as the sole source of truth for infrastructure and applications, we suggest adopting the mindset of pulling changes to environments instead of the traditional approach of pushing changes to environments. With a firm grasp of GitOps&#39; core principles, let&#39;s delve into the best practices we&#39;ve discovered while implementing GitOps.</p><h2>GitOps Best Practices</h2><h3>Enforce Automated Tests and Checks</h3><p>Automated tests and checks are essential in GitOps to ensure code changes are thoroughly tested before deployment. This approach shifts control of code versioning to the environment, eliminating the need for human intervention. However, reliable and effective automated tests and checks are critical to prevent potential disasters. Enforcing a 100% automated test pass rate is recommended to avoid unexpected malfunctions and downtime. It&#39;s important to perform automated testing at every stage of the process, including different environments, to avoid manual errors. A continuous integration and deployment pipeline that automates testing on code changes is highly recommended for thorough testing before production deployment.</p><p></p><img src="https://media.graphassets.com/w3himr96ThuNpzYx5Ak0" alt="Pass rate instead availability (1).png" title="Pass rate instead availability (1).png" width="4244" height="1486" /><h3>Use Preview Environments</h3><p>Using GitOps and automated deployments can come with the risk of downtime in production due to the discovery of bugs. This not only entails the time required to fix the issue but also the disruption to workflows beyond developer control. Preview environments offer a solution to this challenge by providing an environment that mimics production to test code changes before deploying. When making changes that require infrastructure modifications, submitting a pull request will automatically create a preview environment. This environment is identical to production, providing confidence that code will function as expected during deployment. This approach helps to identify and resolve issues or conflicts that arise during automated deployment quickly.</p><p></p><img src="https://media.graphassets.com/wOC89JSTW1jIV7irnLlA" alt="Preview environments.png" title="Preview environments.png" width="2605" height="1791" /><h3>Encourage Frequent Merges</h3><p>To achieve rapid software development through GitOps, frequent merges from the main branch are crucial. This reduces the risk of merge conflicts and allows for real-time feedback. Frequent merges also establish a feedback loop between developers, making error detection and course correction easier. One way to encourage frequent merges is by implementing local hooks, which can be customized to trigger based on specific actions and provide automated feedback. By making frequent merges a routine, development teams can streamline their GitOps process for faster and more efficient software development.</p><h3>Deploy Quickly, Deploy Often</h3><p>To ensure efficient deployment and avoid bottlenecks in our GitOps tool, we prioritized the independence of applications and services, allowing for seamless integration and continuous updates. We implemented a strategy of deploying small changes and updating configurations regularly to simplify the process and achieve real-time deployment. By prioritizing speed and collaboration, we were able to deliver high-quality services quickly and maintain a steady pipeline.</p><img src="https://media.graphassets.com/Xx7nUfhfRu6ITjcTcFVu" alt="pitstop.png" title="pitstop.png" width="1536" height="768" /><h3>Define and Document a Conflict Strategy</h3><p>In GitOps, defining a conflict strategy is a crucial best practice, especially as teams and infrastructure scale. A documented conflict resolution process enables efficient and effective conflict management. This process should be tailored to the organization&#39;s specific needs and may specify the order of preference between changes or the role of stakeholders. It&#39;s important to ensure that all team members understand and follow the documented process. Automated conflict resolution tools can help address conflicts, but their outputs should be reviewed and tested regularly to ensure they meet the organization&#39;s requirements.</p><h3>Use &quot;Pull&quot; Hooks for State Management</h3><p>When implementing GitOps, it&#39;s crucial to have manual hook endpoints for state management to prevent any potential issues. These hooks allow the DevOps team to manually manage the state of the application or infrastructure in case of any problems. The GitOps way of hooks is to use &quot;pull&quot; hook endpoints to maintain consistency and avoid conflicts, as this method lets the team update the state of the application or infrastructure from a specific Git state. This approach ensures that the Git state is the only source of truth, and changes made are consistent with it. Manual hook endpoints for state management should be created in a read-only flavor to minimize the risk of conflicts or mistakes when managing the state of the application or infrastructure. This ultimately ensures that the GitOps process remains consistent and reliable, enabling teams to efficiently deliver high-quality applications and infrastructure.</p><h3>Define Naming Conventions for Branches</h3><p>When implementing GitOps, it&#39;s crucial to establish clear naming conventions for branches. This practice enables quick identification of branch types and purposes and simplifies management. Consistent naming also reduces the likelihood of errors and inconsistencies among developers. Standardizing branch naming for environments, features, hotfixes, and releases is essential. For example, &quot;env/&quot; can denote environments, and &quot;feat/&quot; can denote features. Following these conventions streamlines development and improves versioning.</p><h3>Every Developer Works on Separate Branches for Every Feature</h3><p>Developers should work on separate branches for each feature to maintain a clean codebase and enable independent work without affecting the main branch. A single collaborator should be assigned to each branch to prevent conflicts and ensure isolated feature development. Collaboration branches open only to pull requests and not for commits. This practice is a best practice for GitOps developers to minimize conflicts and ensure feature testing and development are isolated before merging into the main branch. All this enforcement is easy to configure with your source control manager such as GitHub or GitLab.</p><p></p><img src="https://media.graphassets.com/nKurKBznQP2BTSyhOFen" alt="GitOps branching strategy.png" title="GitOps branching strategy.png" width="1979" height="1151" /><h3>Link Logical Environments</h3><p>In GitOps, it&#39;s crucial to link logical environments to deployment environments for a seamless code flow from development to production. To achieve this, representing logical environments as branches in the Git repository is ideal. This approach enables the use of Git&#39;s branching and versioning capabilities to track changes consistently across environments.</p><p>Branches help manage different versions of code, configuration, and infrastructure in multiple environments, such as development, testing, staging, and production. You can create separate branches for each environment, track changes, and easily roll back changes if necessary. This approach also avoids confusion and minimizes errors when working with different environments, providing a clear view of which branch represents each environment.</p><h3>Separate Repos in Complex Environments</h3><p>To manage complex environments effectively, it&#39;s best to create separate repositories for different types of code, such as Infrastructure as Code (IaC), Policy as Code (PaC), application code, and framework code. This allows for a clear separation of responsibilities and reduces the likelihood of conflicts. Having distinct repositories ensures changes made in one don&#39;t negatively affect others, making it easier to manage changes across environments. For GitOps, where code is managed with code, it&#39;s crucial to have a clear separation of concerns. While a complete multi-repo setup isn&#39;t necessary, having a logical separation of repositories is crucial for effective GitOps workflows.</p><h3>Use Policy as Code to Control Pipelines</h3><p>GitOps simplifies infrastructure and application deployments by using a single Git repository as a source of truth. However, as the system&#39;s complexity increases, it&#39;s important to separate code and pipeline concerns. This is where Policy as Code (PaC) comes in. PaC allows developers to manage policies and permissions in one place, ensuring pipelines follow organizational guidelines. By treating policies as code, developers can use version control practices, like pull requests and code reviews, to maintain transparency and consistency in pipeline operations. This ensures pipeline configurations are correctly and effectively maintained.</p><pre><code>package main

default allow = false

# The input is the request object that contains all the necessary information
# about the delivery request
allow {
    input.branch == &quot;main&quot;
    input.hasTestsPassed
    input.hasOneCollaboratorPerBranch
    input.hasRunDevSecOpsTools
}

# Define a rule to check if there is only one collaborator per branch
hasOneCollaboratorPerBranch {
    # Count the number of collaborators for each branch
    count(collaborator) == 1
    # For each branch
    input.branches[branch] == collaborator
}

# Define a rule to check if all DevSecOps tools have been run
hasRunDevSecOpsTools {
    # Check if all the required DevSecOps tools have been run
    input.DevSecOpsTools.runAllTools
}

# Define a rule to check if all tests have passed across the whole pipeline
hasTestsPassed {
    # Check if all the tests have passed in each stage of the pipeline
    input.pipeline.allTestsPassed
}</code></pre><h2>What Next?</h2><p>One of the most effective ways to learn new fields is to be involved in open-source projects and communities. <a title="https://www.permit.io/blog/introduction-to-opal" href="https://www.permit.io/blog/introduction-to-opal">OPAL</a>, the GitOps-enabled policy-as-code management tool we built, is open source and available on GitHub. We encourage you to check it out and see how you could contribute.</p><p>Contribution to open source is not must be complex feature writing, and you can always start with small things like fixing typos, adding documentation, and more. You can refer to our issues page and<a title="https://github.com/permitio/opal/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22" href="https://github.com/permitio/opal/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22"><u> look for issues tagged</u></a> with good first issue tag, which is suitable for starting to contribute to OPAL. You can join our <a title="https://io.permit.io/permitslack" href="https://io.permit.io/permitslack"><u>slack community</u></a>, as we are always happy to help new contributors. Another option to contribute to open-source projects is to star them on GitHub. Star repositories make them more visible and encourage other developers to contribute.</p><p>If you have any questions or comments, feel free to reach out to us on our community channels. We will happily help with any GitOps design questions, even if you are not using OPAL.</p>]]></content>
        <author>
            <name>Gabriel L. Manor</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Using OAuth2 Scopes for Authorization? You might regret it]]></title>
        <id>oauth2-scopes-for-authz</id>
        <link href="https://www.permit.io/blog/oauth2-scopes-for-authz"/>
        <updated>2023-04-18T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Using OAuth2 scopes for authorization might seem tempting. The thing is, OAuth2 scopes were never meant for this, and you might regret it later. Here's why -]]></summary>
        <content type="html"><![CDATA[<h2>TL;DR: </h2><p>When building a new application, using OAuth2 scopes to meet your authorization needs might seem tempting. The thing is, OAuth2 scopes were never really meant for this purpose - and using them may cause you more harm than good as your application evolves. It’s important to keep in mind the differences between OAuth2 scopes and application-level permissions and adopt the right authorization mechanism. This will help ensure you have the necessary level of granularity and control over protected resources.</p><h2>What’s the deal with OAuth2? </h2><p>OAuth2 is a widely used protocol for authorization and authentication of web applications. One of its primary features is the use of scopes, which are used to define the level of access that a client application has to a protected resource. It allows users to grant third-party applications access to their resources without exposing their credentials. OAuth2 provides several mechanisms to help developers define scopes, which represent a set of permissions that a client application can request access to. </p><p><strong>OAuth2 scopes were never, however, intended to be used as an in-app authorization mechanism. </strong>Yet some developers often fall into the trap of using scopes in every authorization scenario. </p><h2>The root of the problem</h2><p>Developers often begin building their applications by implementing an authentication layer. This can be easily achieved by implementing any of the dozens of AuthN SaaS solutions out there. </p><p>The second step is often implementing a simple differentiation between two types of users - “Admin” and “Not-Admin”. Creating an OAuth2 scope to represent the “admin” permission is very simple. When an Admin user logs in, the authentication layer adds the admin scope into the JSON Web Token (JWT), and every call to a protected resource checks the JWT for this “admin” scope. </p><h2>Why is this an issue? </h2><p>In short, OAuth2 scopes are not a substitute for application-level permissions - Scopes define the level of access that a client has to a protected resource, but they do not provide the granularity necessary to define what the client can do with that resource. Here, the crucial difference between OAuth2 scopes and application-level permissions comes in. </p><h3>“I’ll just add more scopes”!</h3><p>As your application develops, simple concepts such as “Admin” and “Not-Admin” become insufficient, as they quickly lead to over-permissioning, which can result in data breaches or unauthorized access to resources. Spoiler alert: Adding a “Super Admin” into the mix is like putting a bandaid on a broken leg. </p><p>The amount of different roles, resources, and actions is likely to grow exponentially along with your application. JTWs have a size limit. If we need to give a user <a title="https://jwt.io/#debugger-io?token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwicm9sZXMiOlsiYWRtaW4iXSwicmVsYXRlZF9pbWFnZXMiOlsiaW1hZ2UwLnBuZyIsImltYWdlMS5wbmciLCJpbWFnZTIucG5nIiwiaW1hZ2UzLnBuZyIsImltYWdlNC5wbmciLCJpbWFnZTUucG5nIiwiaW1hZ2U2LnBuZyIsImltYWdlNy5wbmciLCJpbWFnZTgucG5nIiwiaW1hZ2U5LnBuZyIsImltYWdlMTAucG5nIiwiaW1hZ2UxMS5wbmciLCJpbWFnZTEyLnBuZyIsImltYWdlMTMucG5nIiwiaW1hZ2UxNC5wbmciLCJpbWFnZTE1LnBuZyIsImltYWdlMTYucG5nIiwiaW1hZ2UxNy5wbmciLCJpbWFnZTE4LnBuZyIsImltYWdlMTkucG5nIiwiaW1hZ2UyMC5wbmciLCJpbWFnZTIxLnBuZyIsImltYWdlMjIucG5nIiwiaW1hZ2UyMy5wbmciLCJpbWFnZTI0LnBuZyIsImltYWdlMjUucG5nIiwiaW1hZ2UyNi5wbmciLCJpbWFnZTI3LnBuZyIsImltYWdlMjgucG5nIiwiaW1hZ2UyOS5wbmciLCJpbWFnZTMwLnBuZyIsImltYWdlMzEucG5nIiwiaW1hZ2UzMi5wbmciLCJpbWFnZTMzLnBuZyIsImltYWdlMzQucG5nIiwiaW1hZ2UzNS5wbmciLCJpbWFnZTM2LnBuZyIsImltYWdlMzcucG5nIiwiaW1hZ2UzOC5wbmciLCJpbWFnZTM5LnBuZyIsImltYWdlNDAucG5nIiwiaW1hZ2U0MS5wbmciLCJpbWFnZTQyLnBuZyIsImltYWdlNDMucG5nIiwiaW1hZ2U0NC5wbmciLCJpbWFnZTQ1LnBuZyIsImltYWdlNDYucG5nIiwiaW1hZ2U0Ny5wbmciLCJpbWFnZTQ4LnBuZyIsImltYWdlNDkucG5nIiwiaW1hZ2U1MC5wbmciLCJpbWFnZTUxLnBuZyIsImltYWdlNTIucG5nIiwiaW1hZ2U1My5wbmciLCJpbWFnZTU0LnBuZyIsImltYWdlNTUucG5nIiwiaW1hZ2U1Ni5wbmciLCJpbWFnZTU3LnBuZyIsImltYWdlNTgucG5nIiwiaW1hZ2U1OS5wbmciLCJpbWFnZTYwLnBuZyIsImltYWdlNjEucG5nIiwiaW1hZ2U2Mi5wbmciLCJpbWFnZTYzLnBuZyIsImltYWdlNjQucG5nIiwiaW1hZ2U2NS5wbmciLCJpbWFnZTY2LnBuZyIsImltYWdlNjcucG5nIiwiaW1hZ2U2OC5wbmciLCJpbWFnZTY5LnBuZyIsImltYWdlNzAucG5nIiwiaW1hZ2U3MS5wbmciLCJpbWFnZTcyLnBuZyIsImltYWdlNzMucG5nIiwiaW1hZ2U3NC5wbmciLCJpbWFnZTc1LnBuZyIsImltYWdlNzYucG5nIiwiaW1hZ2U3Ny5wbmciLCJpbWFnZTc4LnBuZyIsImltYWdlNzkucG5nIiwiaW1hZ2U4MC5wbmciLCJpbWFnZTgxLnBuZyIsImltYWdlODIucG5nIiwiaW1hZ2U4My5wbmciLCJpbWFnZTg0LnBuZyIsImltYWdlODUucG5nIiwiaW1hZ2U4Ni5wbmciLCJpbWFnZTg3LnBuZyIsImltYWdlODgucG5nIiwiaW1hZ2U4OS5wbmciLCJpbWFnZTkwLnBuZyIsImltYWdlOTEucG5nIiwiaW1hZ2U5Mi5wbmciLCJpbWFnZTkzLnBuZyIsImltYWdlOTQucG5nIiwiaW1hZ2U5NS5wbmciLCJpbWFnZTk2LnBuZyIsImltYWdlOTcucG5nIiwiaW1hZ2U5OC5wbmciLCJpbWFnZTk5LnBuZyIsImltYWdlMTAwLnBuZyIsImltYWdlMTAxLnBuZyIsImltYWdlMTAyLnBuZyIsImltYWdlMTAzLnBuZyIsImltYWdlMTA0LnBuZyIsImltYWdlMTA1LnBuZyIsImltYWdlMTA2LnBuZyIsImltYWdlMTA3LnBuZyIsImltYWdlMTA4LnBuZyIsImltYWdlMTA5LnBuZyIsImltYWdlMTEwLnBuZyIsImltYWdlMTExLnBuZyIsImltYWdlMTEyLnBuZyIsImltYWdlMTEzLnBuZyIsImltYWdlMTE0LnBuZyIsImltYWdlMTE1LnBuZyIsImltYWdlMTE2LnBuZyIsImltYWdlMTE3LnBuZyIsImltYWdlMTE4LnBuZyIsImltYWdlMTE5LnBuZyIsImltYWdlMTIwLnBuZyIsImltYWdlMTIxLnBuZyIsImltYWdlMTIyLnBuZyIsImltYWdlMTIzLnBuZyIsImltYWdlMTI0LnBuZyIsImltYWdlMTI1LnBuZyIsImltYWdlMTI2LnBuZyIsImltYWdlMTI3LnBuZyIsImltYWdlMTI4LnBuZyIsImltYWdlMTI5LnBuZyIsImltYWdlMTMwLnBuZyIsImltYWdlMTMxLnBuZyIsImltYWdlMTMyLnBuZyIsImltYWdlMTMzLnBuZyIsImltYWdlMTM0LnBuZyIsImltYWdlMTM1LnBuZyIsImltYWdlMTM2LnBuZyIsImltYWdlMTM3LnBuZyIsImltYWdlMTM4LnBuZyIsImltYWdlMTM5LnBuZyIsImltYWdlMTQwLnBuZyIsImltYWdlMTQxLnBuZyIsImltYWdlMTQyLnBuZyIsImltYWdlMTQzLnBuZyIsImltYWdlMTQ0LnBuZyIsImltYWdlMTQ1LnBuZyIsImltYWdlMTQ2LnBuZyIsImltYWdlMTQ3LnBuZyIsImltYWdlMTQ4LnBuZyIsImltYWdlMTQ5LnBuZyIsImltYWdlMTUwLnBuZyIsImltYWdlMTUxLnBuZyIsImltYWdlMTUyLnBuZyIsImltYWdlMTUzLnBuZyIsImltYWdlMTU0LnBuZyIsImltYWdlMTU1LnBuZyIsImltYWdlMTU2LnBuZyIsImltYWdlMTU3LnBuZyIsImltYWdlMTU4LnBuZyIsImltYWdlMTU5LnBuZyIsImltYWdlMTYwLnBuZyIsImltYWdlMTYxLnBuZyIsImltYWdlMTYyLnBuZyIsImltYWdlMTYzLnBuZyIsImltYWdlMTY0LnBuZyIsImltYWdlMTY1LnBuZyIsImltYWdlMTY2LnBuZyIsImltYWdlMTY3LnBuZyIsImltYWdlMTY4LnBuZyIsImltYWdlMTY5LnBuZyIsImltYWdlMTcwLnBuZyIsImltYWdlMTcxLnBuZyIsImltYWdlMTcyLnBuZyIsImltYWdlMTczLnBuZyIsImltYWdlMTc0LnBuZyIsImltYWdlMTc1LnBuZyIsImltYWdlMTc2LnBuZyIsImltYWdlMTc3LnBuZyIsImltYWdlMTc4LnBuZyIsImltYWdlMTc5LnBuZyIsImltYWdlMTgwLnBuZyIsImltYWdlMTgxLnBuZyIsImltYWdlMTgyLnBuZyIsImltYWdlMTgzLnBuZyIsImltYWdlMTg0LnBuZyIsImltYWdlMTg1LnBuZyIsImltYWdlMTg2LnBuZyIsImltYWdlMTg3LnBuZyIsImltYWdlMTg4LnBuZyIsImltYWdlMTg5LnBuZyIsImltYWdlMTkwLnBuZyIsImltYWdlMTkxLnBuZyIsImltYWdlMTkyLnBuZyIsImltYWdlMTkzLnBuZyIsImltYWdlMTk0LnBuZyIsImltYWdlMTk1LnBuZyIsImltYWdlMTk2LnBuZyIsImltYWdlMTk3LnBuZyIsImltYWdlMTk4LnBuZyIsImltYWdlMTk5LnBuZyIsImltYWdlMjAwLnBuZyIsImltYWdlMjAxLnBuZyIsImltYWdlMjAyLnBuZyIsImltYWdlMjAzLnBuZyIsImltYWdlMjA0LnBuZyIsImltYWdlMjA1LnBuZyIsImltYWdlMjA2LnBuZyIsImltYWdlMjA3LnBuZyIsImltYWdlMjA4LnBuZyIsImltYWdlMjA5LnBuZyIsImltYWdlMjEwLnBuZyIsImltYWdlMjExLnBuZyIsImltYWdlMjEyLnBuZyIsImltYWdlMjEzLnBuZyIsImltYWdlMjE0LnBuZyIsImltYWdlMjE1LnBuZyIsImltYWdlMjE2LnBuZyIsImltYWdlMjE3LnBuZyIsImltYWdlMjE4LnBuZyIsImltYWdlMjE5LnBuZyIsImltYWdlMjIwLnBuZyIsImltYWdlMjIxLnBuZyIsImltYWdlMjIyLnBuZyIsImltYWdlMjIzLnBuZyIsImltYWdlMjI0LnBuZyIsImltYWdlMjI1LnBuZyIsImltYWdlMjI2LnBuZyIsImltYWdlMjI3LnBuZyIsImltYWdlMjI4LnBuZyIsImltYWdlMjI5LnBuZyIsImltYWdlMjMwLnBuZyIsImltYWdlMjMxLnBuZyIsImltYWdlMjMyLnBuZyIsImltYWdlMjMzLnBuZyIsImltYWdlMjM0LnBuZyIsImltYWdlMjM1LnBuZyIsImltYWdlMjM2LnBuZyIsImltYWdlMjM3LnBuZyIsImltYWdlMjM4LnBuZyIsImltYWdlMjM5LnBuZyIsImltYWdlMjQwLnBuZyIsImltYWdlMjQxLnBuZyIsImltYWdlMjQyLnBuZyIsImltYWdlMjQzLnBuZyIsImltYWdlMjQ0LnBuZyIsImltYWdlMjQ1LnBuZyIsImltYWdlMjQ2LnBuZyIsImltYWdlMjQ3LnBuZyIsImltYWdlMjQ4LnBuZyIsImltYWdlMjQ5LnBuZyIsImltYWdlMjUwLnBuZyIsImltYWdlMjUxLnBuZyIsImltYWdlMjUyLnBuZyIsImltYWdlMjUzLnBuZyIsImltYWdlMjU0LnBuZyIsImltYWdlMjU1LnBuZyIsImltYWdlMjU2LnBuZyIsImltYWdlMjU3LnBuZyIsImltYWdlMjU4LnBuZyIsImltYWdlMjU5LnBuZyIsImltYWdlMjYwLnBuZyIsImltYWdlMjYxLnBuZyIsImltYWdlMjYyLnBuZyIsImltYWdlMjYzLnBuZyIsImltYWdlMjY0LnBuZyIsImltYWdlMjY1LnBuZyIsImltYWdlMjY2LnBuZyIsImltYWdlMjY3LnBuZyIsImltYWdlMjY4LnBuZyIsImltYWdlMjY5LnBuZyIsImltYWdlMjcwLnBuZyIsImltYWdlMjcxLnBuZyIsImltYWdlMjcyLnBuZyIsImltYWdlMjczLnBuZyIsImltYWdlMjc0LnBuZyIsImltYWdlMjc1LnBuZyIsImltYWdlMjc2LnBuZyIsImltYWdlMjc3LnBuZyIsImltYWdlMjc4LnBuZyIsImltYWdlMjc5LnBuZyIsImltYWdlMjgwLnBuZyIsImltYWdlMjgxLnBuZyIsImltYWdlMjgyLnBuZyIsImltYWdlMjgzLnBuZyIsImltYWdlMjg0LnBuZyIsImltYWdlMjg1LnBuZyIsImltYWdlMjg2LnBuZyIsImltYWdlMjg3LnBuZyIsImltYWdlMjg4LnBuZyIsImltYWdlMjg5LnBuZyIsImltYWdlMjkwLnBuZyIsImltYWdlMjkxLnBuZyIsImltYWdlMjkyLnBuZyIsImltYWdlMjkzLnBuZyIsImltYWdlMjk0LnBuZyIsImltYWdlMjk1LnBuZyIsImltYWdlMjk2LnBuZyIsImltYWdlMjk3LnBuZyIsImltYWdlMjk4LnBuZyIsImltYWdlMjk5LnBuZyIsImltYWdlMzAwLnBuZyIsImltYWdlMzAxLnBuZyIsImltYWdlMzAyLnBuZyIsImltYWdlMzAzLnBuZyIsImltYWdlMzA0LnBuZyIsImltYWdlMzA1LnBuZyIsImltYWdlMzA2LnBuZyIsImltYWdlMzA3LnBuZyIsImltYWdlMzA4LnBuZyIsImltYWdlMzA5LnBuZyIsImltYWdlMzEwLnBuZyIsImltYWdlMzExLnBuZyIsImltYWdlMzEyLnBuZyIsImltYWdlMzEzLnBuZyIsImltYWdlMzE0LnBuZyIsImltYWdlMzE1LnBuZyIsImltYWdlMzE2LnBuZyIsImltYWdlMzE3LnBuZyIsImltYWdlMzE4LnBuZyIsImltYWdlMzE5LnBuZyIsImltYWdlMzIwLnBuZyIsImltYWdlMzIxLnBuZyIsImltYWdlMzIyLnBuZyIsImltYWdlMzIzLnBuZyIsImltYWdlMzI0LnBuZyIsImltYWdlMzI1LnBuZyIsImltYWdlMzI2LnBuZyIsImltYWdlMzI3LnBuZyIsImltYWdlMzI4LnBuZyIsImltYWdlMzI5LnBuZyIsImltYWdlMzMwLnBuZyIsImltYWdlMzMxLnBuZyIsImltYWdlMzMyLnBuZyIsImltYWdlMzMzLnBuZyIsImltYWdlMzM0LnBuZyIsImltYWdlMzM1LnBuZyIsImltYWdlMzM2LnBuZyIsImltYWdlMzM3LnBuZyIsImltYWdlMzM4LnBuZyIsImltYWdlMzM5LnBuZyIsImltYWdlMzQwLnBuZyIsImltYWdlMzQxLnBuZyIsImltYWdlMzQyLnBuZyIsImltYWdlMzQzLnBuZyIsImltYWdlMzQ0LnBuZyIsImltYWdlMzQ1LnBuZyIsImltYWdlMzQ2LnBuZyIsImltYWdlMzQ3LnBuZyIsImltYWdlMzQ4LnBuZyIsImltYWdlMzQ5LnBuZyIsImltYWdlMzUwLnBuZyIsImltYWdlMzUxLnBuZyIsImltYWdlMzUyLnBuZyIsImltYWdlMzUzLnBuZyIsImltYWdlMzU0LnBuZyIsImltYWdlMzU1LnBuZyIsImltYWdlMzU2LnBuZyIsImltYWdlMzU3LnBuZyIsImltYWdlMzU4LnBuZyIsImltYWdlMzU5LnBuZyIsImltYWdlMzYwLnBuZyIsImltYWdlMzYxLnBuZyIsImltYWdlMzYyLnBuZyIsImltYWdlMzYzLnBuZyIsImltYWdlMzY0LnBuZyIsImltYWdlMzY1LnBuZyIsImltYWdlMzY2LnBuZyIsImltYWdlMzY3LnBuZyIsImltYWdlMzY4LnBuZyIsImltYWdlMzY5LnBuZyIsImltYWdlMzcwLnBuZyIsImltYWdlMzcxLnBuZyIsImltYWdlMzcyLnBuZyIsImltYWdlMzczLnBuZyIsImltYWdlMzc0LnBuZyIsImltYWdlMzc1LnBuZyIsImltYWdlMzc2LnBuZyIsImltYWdlMzc3LnBuZyIsImltYWdlMzc4LnBuZyIsImltYWdlMzc5LnBuZyIsImltYWdlMzgwLnBuZyIsImltYWdlMzgxLnBuZyIsImltYWdlMzgyLnBuZyIsImltYWdlMzgzLnBuZyIsImltYWdlMzg0LnBuZyIsImltYWdlMzg1LnBuZyIsImltYWdlMzg2LnBuZyIsImltYWdlMzg3LnBuZyIsImltYWdlMzg4LnBuZyIsImltYWdlMzg5LnBuZyIsImltYWdlMzkwLnBuZyIsImltYWdlMzkxLnBuZyIsImltYWdlMzkyLnBuZyIsImltYWdlMzkzLnBuZyIsImltYWdlMzk0LnBuZyIsImltYWdlMzk1LnBuZyIsImltYWdlMzk2LnBuZyIsImltYWdlMzk3LnBuZyIsImltYWdlMzk4LnBuZyIsImltYWdlMzk5LnBuZyIsImltYWdlNDAwLnBuZyIsImltYWdlNDAxLnBuZyIsImltYWdlNDAyLnBuZyIsImltYWdlNDAzLnBuZyIsImltYWdlNDA0LnBuZyIsImltYWdlNDA1LnBuZyIsImltYWdlNDA2LnBuZyIsImltYWdlNDA3LnBuZyIsImltYWdlNDA4LnBuZyIsImltYWdlNDA5LnBuZyIsImltYWdlNDEwLnBuZyIsImltYWdlNDExLnBuZyIsImltYWdlNDEyLnBuZyIsImltYWdlNDEzLnBuZyIsImltYWdlNDE0LnBuZyIsImltYWdlNDE1LnBuZyIsImltYWdlNDE2LnBuZyIsImltYWdlNDE3LnBuZyIsImltYWdlNDE4LnBuZyIsImltYWdlNDE5LnBuZyIsImltYWdlNDIwLnBuZyIsImltYWdlNDIxLnBuZyIsImltYWdlNDIyLnBuZyIsImltYWdlNDIzLnBuZyIsImltYWdlNDI0LnBuZyIsImltYWdlNDI1LnBuZyIsImltYWdlNDI2LnBuZyIsImltYWdlNDI3LnBuZyIsImltYWdlNDI4LnBuZyIsImltYWdlNDI5LnBuZyIsImltYWdlNDMwLnBuZyIsImltYWdlNDMxLnBuZyIsImltYWdlNDMyLnBuZyIsImltYWdlNDMzLnBuZyIsImltYWdlNDM0LnBuZyIsImltYWdlNDM1LnBuZyIsImltYWdlNDM2LnBuZyIsImltYWdlNDM3LnBuZyIsImltYWdlNDM4LnBuZyIsImltYWdlNDM5LnBuZyIsImltYWdlNDQwLnBuZyIsImltYWdlNDQxLnBuZyIsImltYWdlNDQyLnBuZyIsImltYWdlNDQzLnBuZyIsImltYWdlNDQ0LnBuZyIsImltYWdlNDQ1LnBuZyIsImltYWdlNDQ2LnBuZyIsImltYWdlNDQ3LnBuZyIsImltYWdlNDQ4LnBuZyIsImltYWdlNDQ5LnBuZyIsImltYWdlNDUwLnBuZyIsImltYWdlNDUxLnBuZyIsImltYWdlNDUyLnBuZyIsImltYWdlNDUzLnBuZyIsImltYWdlNDU0LnBuZyIsImltYWdlNDU1LnBuZyIsImltYWdlNDU2LnBuZyIsImltYWdlNDU3LnBuZyIsImltYWdlNDU4LnBuZyIsImltYWdlNDU5LnBuZyIsImltYWdlNDYwLnBuZyIsImltYWdlNDYxLnBuZyIsImltYWdlNDYyLnBuZyIsImltYWdlNDYzLnBuZyIsImltYWdlNDY0LnBuZyIsImltYWdlNDY1LnBuZyIsImltYWdlNDY2LnBuZyIsImltYWdlNDY3LnBuZyIsImltYWdlNDY4LnBuZyIsImltYWdlNDY5LnBuZyIsImltYWdlNDcwLnBuZyIsImltYWdlNDcxLnBuZyIsImltYWdlNDcyLnBuZyIsImltYWdlNDczLnBuZyIsImltYWdlNDc0LnBuZyIsImltYWdlNDc1LnBuZyIsImltYWdlNDc2LnBuZyIsImltYWdlNDc3LnBuZyIsImltYWdlNDc4LnBuZyIsImltYWdlNDc5LnBuZyIsImltYWdlNDgwLnBuZyIsImltYWdlNDgxLnBuZyIsImltYWdlNDgyLnBuZyIsImltYWdlNDgzLnBuZyIsImltYWdlNDg0LnBuZyIsImltYWdlNDg1LnBuZyIsImltYWdlNDg2LnBuZyIsImltYWdlNDg3LnBuZyIsImltYWdlNDg4LnBuZyIsImltYWdlNDg5LnBuZyIsImltYWdlNDkwLnBuZyIsImltYWdlNDkxLnBuZyIsImltYWdlNDkyLnBuZyIsImltYWdlNDkzLnBuZyIsImltYWdlNDk0LnBuZyIsImltYWdlNDk1LnBuZyIsImltYWdlNDk2LnBuZyIsImltYWdlNDk3LnBuZyIsImltYWdlNDk4LnBuZyIsImltYWdlNDk5LnBuZyIsImltYWdlNTAwLnBuZyIsImltYWdlNTAxLnBuZyIsImltYWdlNTAyLnBuZyIsImltYWdlNTAzLnBuZyIsImltYWdlNTA0LnBuZyIsImltYWdlNTA1LnBuZyIsImltYWdlNTA2LnBuZyIsImltYWdlNTA3LnBuZyIsImltYWdlNTA4LnBuZyIsImltYWdlNTA5LnBuZyIsImltYWdlNTEwLnBuZyIsImltYWdlNTExLnBuZyIsImltYWdlNTEyLnBuZyIsImltYWdlNTEzLnBuZyIsImltYWdlNTE0LnBuZyIsImltYWdlNTE1LnBuZyIsImltYWdlNTE2LnBuZyIsImltYWdlNTE3LnBuZyIsImltYWdlNTE4LnBuZyIsImltYWdlNTE5LnBuZyIsImltYWdlNTIwLnBuZyIsImltYWdlNTIxLnBuZyIsImltYWdlNTIyLnBuZyIsImltYWdlNTIzLnBuZyIsImltYWdlNTI0LnBuZyIsImltYWdlNTI1LnBuZyIsImltYWdlNTI2LnBuZyIsImltYWdlNTI3LnBuZyIsImltYWdlNTI4LnBuZyIsImltYWdlNTI5LnBuZyIsImltYWdlNTMwLnBuZyIsImltYWdlNTMxLnBuZyIsImltYWdlNTMyLnBuZyIsImltYWdlNTMzLnBuZyIsImltYWdlNTM0LnBuZyIsImltYWdlNTM1LnBuZyIsImltYWdlNTM2LnBuZyIsImltYWdlNTM3LnBuZyIsImltYWdlNTM4LnBuZyIsImltYWdlNTM5LnBuZyIsImltYWdlNTQwLnBuZyIsImltYWdlNTQxLnBuZyIsImltYWdlNTQyLnBuZyIsImltYWdlNTQzLnBuZyIsImltYWdlNTQ0LnBuZyIsImltYWdlNTQ1LnBuZyIsImltYWdlNTQ2LnBuZyIsImltYWdlNTQ3LnBuZyIsImltYWdlNTQ4LnBuZyIsImltYWdlNTQ5LnBuZyIsImltYWdlNTUwLnBuZyIsImltYWdlNTUxLnBuZyIsImltYWdlNTUyLnBuZyIsImltYWdlNTUzLnBuZyIsImltYWdlNTU0LnBuZyIsImltYWdlNTU1LnBuZyIsImltYWdlNTU2LnBuZyIsImltYWdlNTU3LnBuZyIsImltYWdlNTU4LnBuZyIsImltYWdlNTU5LnBuZyIsImltYWdlNTYwLnBuZyIsImltYWdlNTYxLnBuZyIsImltYWdlNTYyLnBuZyIsImltYWdlNTYzLnBuZyIsImltYWdlNTY0LnBuZyIsImltYWdlNTY1LnBuZyIsImltYWdlNTY2LnBuZyIsImltYWdlNTY3LnBuZyIsImltYWdlNTY4LnBuZyIsImltYWdlNTY5LnBuZyIsImltYWdlNTcwLnBuZyIsImltYWdlNTcxLnBuZyIsImltYWdlNTcyLnBuZyIsImltYWdlNTczLnBuZyIsImltYWdlNTc0LnBuZyIsImltYWdlNTc1LnBuZyIsImltYWdlNTc2LnBuZyIsImltYWdlNTc3LnBuZyIsImltYWdlNTc4LnBuZyIsImltYWdlNTc5LnBuZyIsImltYWdlNTgwLnBuZyIsImltYWdlNTgxLnBuZyIsImltYWdlNTgyLnBuZyIsImltYWdlNTgzLnBuZyIsImltYWdlNTg0LnBuZyIsImltYWdlNTg1LnBuZyIsImltYWdlNTg2LnBuZyIsImltYWdlNTg3LnBuZyIsImltYWdlNTg4LnBuZyIsImltYWdlNTg5LnBuZyIsImltYWdlNTkwLnBuZyIsImltYWdlNTkxLnBuZyIsImltYWdlNTkyLnBuZyIsImltYWdlNTkzLnBuZyIsImltYWdlNTk0LnBuZyIsImltYWdlNTk1LnBuZyIsImltYWdlNTk2LnBuZyIsImltYWdlNTk3LnBuZyIsImltYWdlNTk4LnBuZyIsImltYWdlNTk5LnBuZyIsImltYWdlNjAwLnBuZyIsImltYWdlNjAxLnBuZyIsImltYWdlNjAyLnBuZyIsImltYWdlNjAzLnBuZyIsImltYWdlNjA0LnBuZyIsImltYWdlNjA1LnBuZyIsImltYWdlNjA2LnBuZyIsImltYWdlNjA3LnBuZyIsImltYWdlNjA4LnBuZyIsImltYWdlNjA5LnBuZyIsImltYWdlNjEwLnBuZyIsImltYWdlNjExLnBuZyIsImltYWdlNjEyLnBuZyIsImltYWdlNjEzLnBuZyIsImltYWdlNjE0LnBuZyIsImltYWdlNjE1LnBuZyIsImltYWdlNjE2LnBuZyIsImltYWdlNjE3LnBuZyIsImltYWdlNjE4LnBuZyIsImltYWdlNjE5LnBuZyIsImltYWdlNjIwLnBuZyIsImltYWdlNjIxLnBuZyIsImltYWdlNjIyLnBuZyIsImltYWdlNjIzLnBuZyIsImltYWdlNjI0LnBuZyIsImltYWdlNjI1LnBuZyIsImltYWdlNjI2LnBuZyIsImltYWdlNjI3LnBuZyIsImltYWdlNjI4LnBuZyIsImltYWdlNjI5LnBuZyIsImltYWdlNjMwLnBuZyIsImltYWdlNjMxLnBuZyIsImltYWdlNjMyLnBuZyIsImltYWdlNjMzLnBuZyIsImltYWdlNjM0LnBuZyIsImltYWdlNjM1LnBuZyIsImltYWdlNjM2LnBuZyIsImltYWdlNjM3LnBuZyIsImltYWdlNjM4LnBuZyIsImltYWdlNjM5LnBuZyIsImltYWdlNjQwLnBuZyIsImltYWdlNjQxLnBuZyIsImltYWdlNjQyLnBuZyIsImltYWdlNjQzLnBuZyIsImltYWdlNjQ0LnBuZyIsImltYWdlNjQ1LnBuZyIsImltYWdlNjQ2LnBuZyIsImltYWdlNjQ3LnBuZyIsImltYWdlNjQ4LnBuZyIsImltYWdlNjQ5LnBuZyIsImltYWdlNjUwLnBuZyIsImltYWdlNjUxLnBuZyIsImltYWdlNjUyLnBuZyIsImltYWdlNjUzLnBuZyIsImltYWdlNjU0LnBuZyIsImltYWdlNjU1LnBuZyIsImltYWdlNjU2LnBuZyIsImltYWdlNjU3LnBuZyIsImltYWdlNjU4LnBuZyIsImltYWdlNjU5LnBuZyIsImltYWdlNjYwLnBuZyIsImltYWdlNjYxLnBuZyIsImltYWdlNjYyLnBuZyIsImltYWdlNjYzLnBuZyIsImltYWdlNjY0LnBuZyIsImltYWdlNjY1LnBuZyIsImltYWdlNjY2LnBuZyIsImltYWdlNjY3LnBuZyIsImltYWdlNjY4LnBuZyIsImltYWdlNjY5LnBuZyIsImltYWdlNjcwLnBuZyIsImltYWdlNjcxLnBuZyIsImltYWdlNjcyLnBuZyIsImltYWdlNjczLnBuZyIsImltYWdlNjc0LnBuZyIsImltYWdlNjc1LnBuZyIsImltYWdlNjc2LnBuZyIsImltYWdlNjc3LnBuZyIsImltYWdlNjc4LnBuZyIsImltYWdlNjc5LnBuZyIsImltYWdlNjgwLnBuZyIsImltYWdlNjgxLnBuZyIsImltYWdlNjgyLnBuZyIsImltYWdlNjgzLnBuZyIsImltYWdlNjg0LnBuZyIsImltYWdlNjg1LnBuZyIsImltYWdlNjg2LnBuZyIsImltYWdlNjg3LnBuZyIsImltYWdlNjg4LnBuZyIsImltYWdlNjg5LnBuZyIsImltYWdlNjkwLnBuZyIsImltYWdlNjkxLnBuZyIsImltYWdlNjkyLnBuZyIsImltYWdlNjkzLnBuZyIsImltYWdlNjk0LnBuZyIsImltYWdlNjk1LnBuZyIsImltYWdlNjk2LnBuZyIsImltYWdlNjk3LnBuZyIsImltYWdlNjk4LnBuZyIsImltYWdlNjk5LnBuZyIsImltYWdlNzAwLnBuZyIsImltYWdlNzAxLnBuZyIsImltYWdlNzAyLnBuZyIsImltYWdlNzAzLnBuZyIsImltYWdlNzA0LnBuZyIsImltYWdlNzA1LnBuZyIsImltYWdlNzA2LnBuZyIsImltYWdlNzA3LnBuZyIsImltYWdlNzA4LnBuZyIsImltYWdlNzA5LnBuZyIsImltYWdlNzEwLnBuZyIsImltYWdlNzExLnBuZyIsImltYWdlNzEyLnBuZyIsImltYWdlNzEzLnBuZyIsImltYWdlNzE0LnBuZyIsImltYWdlNzE1LnBuZyIsImltYWdlNzE2LnBuZyIsImltYWdlNzE3LnBuZyIsImltYWdlNzE4LnBuZyIsImltYWdlNzE5LnBuZyIsImltYWdlNzIwLnBuZyIsImltYWdlNzIxLnBuZyIsImltYWdlNzIyLnBuZyIsImltYWdlNzIzLnBuZyIsImltYWdlNzI0LnBuZyIsImltYWdlNzI1LnBuZyIsImltYWdlNzI2LnBuZyIsImltYWdlNzI3LnBuZyIsImltYWdlNzI4LnBuZyIsImltYWdlNzI5LnBuZyIsImltYWdlNzMwLnBuZyIsImltYWdlNzMxLnBuZyIsImltYWdlNzMyLnBuZyIsImltYWdlNzMzLnBuZyIsImltYWdlNzM0LnBuZyIsImltYWdlNzM1LnBuZyIsImltYWdlNzM2LnBuZyIsImltYWdlNzM3LnBuZyIsImltYWdlNzM4LnBuZyIsImltYWdlNzM5LnBuZyIsImltYWdlNzQwLnBuZyIsImltYWdlNzQxLnBuZyIsImltYWdlNzQyLnBuZyIsImltYWdlNzQzLnBuZyIsImltYWdlNzQ0LnBuZyIsImltYWdlNzQ1LnBuZyIsImltYWdlNzQ2LnBuZyIsImltYWdlNzQ3LnBuZyIsImltYWdlNzQ4LnBuZyIsImltYWdlNzQ5LnBuZyIsImltYWdlNzUwLnBuZyIsImltYWdlNzUxLnBuZyIsImltYWdlNzUyLnBuZyIsImltYWdlNzUzLnBuZyIsImltYWdlNzU0LnBuZyIsImltYWdlNzU1LnBuZyIsImltYWdlNzU2LnBuZyIsImltYWdlNzU3LnBuZyIsImltYWdlNzU4LnBuZyIsImltYWdlNzU5LnBuZyIsImltYWdlNzYwLnBuZyIsImltYWdlNzYxLnBuZyIsImltYWdlNzYyLnBuZyIsImltYWdlNzYzLnBuZyIsImltYWdlNzY0LnBuZyIsImltYWdlNzY1LnBuZyIsImltYWdlNzY2LnBuZyIsImltYWdlNzY3LnBuZyIsImltYWdlNzY4LnBuZyIsImltYWdlNzY5LnBuZyIsImltYWdlNzcwLnBuZyIsImltYWdlNzcxLnBuZyIsImltYWdlNzcyLnBuZyIsImltYWdlNzczLnBuZyIsImltYWdlNzc0LnBuZyIsImltYWdlNzc1LnBuZyIsImltYWdlNzc2LnBuZyIsImltYWdlNzc3LnBuZyIsImltYWdlNzc4LnBuZyIsImltYWdlNzc5LnBuZyIsImltYWdlNzgwLnBuZyIsImltYWdlNzgxLnBuZyIsImltYWdlNzgyLnBuZyIsImltYWdlNzgzLnBuZyIsImltYWdlNzg0LnBuZyIsImltYWdlNzg1LnBuZyIsImltYWdlNzg2LnBuZyIsImltYWdlNzg3LnBuZyIsImltYWdlNzg4LnBuZyIsImltYWdlNzg5LnBuZyIsImltYWdlNzkwLnBuZyIsImltYWdlNzkxLnBuZyIsImltYWdlNzkyLnBuZyIsImltYWdlNzkzLnBuZyIsImltYWdlNzk0LnBuZyIsImltYWdlNzk1LnBuZyIsImltYWdlNzk2LnBuZyIsImltYWdlNzk3LnBuZyIsImltYWdlNzk4LnBuZyIsImltYWdlNzk5LnBuZyIsImltYWdlODAwLnBuZyIsImltYWdlODAxLnBuZyIsImltYWdlODAyLnBuZyIsImltYWdlODAzLnBuZyIsImltYWdlODA0LnBuZyIsImltYWdlODA1LnBuZyIsImltYWdlODA2LnBuZyIsImltYWdlODA3LnBuZyIsImltYWdlODA4LnBuZyIsImltYWdlODA5LnBuZyIsImltYWdlODEwLnBuZyIsImltYWdlODExLnBuZyIsImltYWdlODEyLnBuZyIsImltYWdlODEzLnBuZyIsImltYWdlODE0LnBuZyIsImltYWdlODE1LnBuZyIsImltYWdlODE2LnBuZyIsImltYWdlODE3LnBuZyIsImltYWdlODE4LnBuZyIsImltYWdlODE5LnBuZyIsImltYWdlODIwLnBuZyIsImltYWdlODIxLnBuZyIsImltYWdlODIyLnBuZyIsImltYWdlODIzLnBuZyIsImltYWdlODI0LnBuZyIsImltYWdlODI1LnBuZyIsImltYWdlODI2LnBuZyIsImltYWdlODI3LnBuZyIsImltYWdlODI4LnBuZyIsImltYWdlODI5LnBuZyIsImltYWdlODMwLnBuZyIsImltYWdlODMxLnBuZyIsImltYWdlODMyLnBuZyIsImltYWdlODMzLnBuZyIsImltYWdlODM0LnBuZyIsImltYWdlODM1LnBuZyIsImltYWdlODM2LnBuZyIsImltYWdlODM3LnBuZyIsImltYWdlODM4LnBuZyIsImltYWdlODM5LnBuZyIsImltYWdlODQwLnBuZyIsImltYWdlODQxLnBuZyIsImltYWdlODQyLnBuZyIsImltYWdlODQzLnBuZyIsImltYWdlODQ0LnBuZyIsImltYWdlODQ1LnBuZyIsImltYWdlODQ2LnBuZyIsImltYWdlODQ3LnBuZyIsImltYWdlODQ4LnBuZyIsImltYWdlODQ5LnBuZyIsImltYWdlODUwLnBuZyIsImltYWdlODUxLnBuZyIsImltYWdlODUyLnBuZyIsImltYWdlODUzLnBuZyIsImltYWdlODU0LnBuZyIsImltYWdlODU1LnBuZyIsImltYWdlODU2LnBuZyIsImltYWdlODU3LnBuZyIsImltYWdlODU4LnBuZyIsImltYWdlODU5LnBuZyIsImltYWdlODYwLnBuZyIsImltYWdlODYxLnBuZyIsImltYWdlODYyLnBuZyIsImltYWdlODYzLnBuZyIsImltYWdlODY0LnBuZyIsImltYWdlODY1LnBuZyIsImltYWdlODY2LnBuZyIsImltYWdlODY3LnBuZyIsImltYWdlODY4LnBuZyIsImltYWdlODY5LnBuZyIsImltYWdlODcwLnBuZyIsImltYWdlODcxLnBuZyIsImltYWdlODcyLnBuZyIsImltYWdlODczLnBuZyIsImltYWdlODc0LnBuZyIsImltYWdlODc1LnBuZyIsImltYWdlODc2LnBuZyIsImltYWdlODc3LnBuZyIsImltYWdlODc4LnBuZyIsImltYWdlODc5LnBuZyIsImltYWdlODgwLnBuZyIsImltYWdlODgxLnBuZyIsImltYWdlODgyLnBuZyIsImltYWdlODgzLnBuZyIsImltYWdlODg0LnBuZyIsImltYWdlODg1LnBuZyIsImltYWdlODg2LnBuZyIsImltYWdlODg3LnBuZyIsImltYWdlODg4LnBuZyIsImltYWdlODg5LnBuZyIsImltYWdlODkwLnBuZyIsImltYWdlODkxLnBuZyIsImltYWdlODkyLnBuZyIsImltYWdlODkzLnBuZyIsImltYWdlODk0LnBuZyIsImltYWdlODk1LnBuZyIsImltYWdlODk2LnBuZyIsImltYWdlODk3LnBuZyIsImltYWdlODk4LnBuZyIsImltYWdlODk5LnBuZyIsImltYWdlOTAwLnBuZyIsImltYWdlOTAxLnBuZyIsImltYWdlOTAyLnBuZyIsImltYWdlOTAzLnBuZyIsImltYWdlOTA0LnBuZyIsImltYWdlOTA1LnBuZyIsImltYWdlOTA2LnBuZyIsImltYWdlOTA3LnBuZyIsImltYWdlOTA4LnBuZyIsImltYWdlOTA5LnBuZyIsImltYWdlOTEwLnBuZyIsImltYWdlOTExLnBuZyIsImltYWdlOTEyLnBuZyIsImltYWdlOTEzLnBuZyIsImltYWdlOTE0LnBuZyIsImltYWdlOTE1LnBuZyIsImltYWdlOTE2LnBuZyIsImltYWdlOTE3LnBuZyIsImltYWdlOTE4LnBuZyIsImltYWdlOTE5LnBuZyIsImltYWdlOTIwLnBuZyIsImltYWdlOTIxLnBuZyIsImltYWdlOTIyLnBuZyIsImltYWdlOTIzLnBuZyIsImltYWdlOTI0LnBuZyIsImltYWdlOTI1LnBuZyIsImltYWdlOTI2LnBuZyIsImltYWdlOTI3LnBuZyIsImltYWdlOTI4LnBuZyIsImltYWdlOTI5LnBuZyIsImltYWdlOTMwLnBuZyIsImltYWdlOTMxLnBuZyIsImltYWdlOTMyLnBuZyIsImltYWdlOTMzLnBuZyIsImltYWdlOTM0LnBuZyIsImltYWdlOTM1LnBuZyIsImltYWdlOTM2LnBuZyIsImltYWdlOTM3LnBuZyIsImltYWdlOTM4LnBuZyIsImltYWdlOTM5LnBuZyIsImltYWdlOTQwLnBuZyIsImltYWdlOTQxLnBuZyIsImltYWdlOTQyLnBuZyIsImltYWdlOTQzLnBuZyIsImltYWdlOTQ0LnBuZyIsImltYWdlOTQ1LnBuZyIsImltYWdlOTQ2LnBuZyIsImltYWdlOTQ3LnBuZyIsImltYWdlOTQ4LnBuZyIsImltYWdlOTQ5LnBuZyIsImltYWdlOTUwLnBuZyIsImltYWdlOTUxLnBuZyIsImltYWdlOTUyLnBuZyIsImltYWdlOTUzLnBuZyIsImltYWdlOTU0LnBuZyIsImltYWdlOTU1LnBuZyIsImltYWdlOTU2LnBuZyIsImltYWdlOTU3LnBuZyIsImltYWdlOTU4LnBuZyIsImltYWdlOTU5LnBuZyIsImltYWdlOTYwLnBuZyIsImltYWdlOTYxLnBuZyIsImltYWdlOTYyLnBuZyIsImltYWdlOTYzLnBuZyIsImltYWdlOTY0LnBuZyIsImltYWdlOTY1LnBuZyIsImltYWdlOTY2LnBuZyIsImltYWdlOTY3LnBuZyIsImltYWdlOTY4LnBuZyIsImltYWdlOTY5LnBuZyIsImltYWdlOTcwLnBuZyIsImltYWdlOTcxLnBuZyIsImltYWdlOTcyLnBuZyIsImltYWdlOTczLnBuZyIsImltYWdlOTc0LnBuZyIsImltYWdlOTc1LnBuZyIsImltYWdlOTc2LnBuZyIsImltYWdlOTc3LnBuZyIsImltYWdlOTc4LnBuZyIsImltYWdlOTc5LnBuZyIsImltYWdlOTgwLnBuZyIsImltYWdlOTgxLnBuZyIsImltYWdlOTgyLnBuZyIsImltYWdlOTgzLnBuZyIsImltYWdlOTg0LnBuZyIsImltYWdlOTg1LnBuZyIsImltYWdlOTg2LnBuZyIsImltYWdlOTg3LnBuZyIsImltYWdlOTg4LnBuZyIsImltYWdlOTg5LnBuZyIsImltYWdlOTkwLnBuZyIsImltYWdlOTkxLnBuZyIsImltYWdlOTkyLnBuZyIsImltYWdlOTkzLnBuZyIsImltYWdlOTk0LnBuZyIsImltYWdlOTk1LnBuZyIsImltYWdlOTk2LnBuZyIsImltYWdlOTk3LnBuZyIsImltYWdlOTk4LnBuZyIsImltYWdlOTk5LnBuZyJdLCJpYXQiOjE1MTYyMzkwMjJ9.KGrocKdxHn_ZCkgfl5SAbKxCm8tbqVOBslU_x3SrYAg" href="https://jwt.io/#debugger-io?token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwicm9sZXMiOlsiYWRtaW4iXSwicmVsYXRlZF9pbWFnZXMiOlsiaW1hZ2UwLnBuZyIsImltYWdlMS5wbmciLCJpbWFnZTIucG5nIiwiaW1hZ2UzLnBuZyIsImltYWdlNC5wbmciLCJpbWFnZTUucG5nIiwiaW1hZ2U2LnBuZyIsImltYWdlNy5wbmciLCJpbWFnZTgucG5nIiwiaW1hZ2U5LnBuZyIsImltYWdlMTAucG5nIiwiaW1hZ2UxMS5wbmciLCJpbWFnZTEyLnBuZyIsImltYWdlMTMucG5nIiwiaW1hZ2UxNC5wbmciLCJpbWFnZTE1LnBuZyIsImltYWdlMTYucG5nIiwiaW1hZ2UxNy5wbmciLCJpbWFnZTE4LnBuZyIsImltYWdlMTkucG5nIiwiaW1hZ2UyMC5wbmciLCJpbWFnZTIxLnBuZyIsImltYWdlMjIucG5nIiwiaW1hZ2UyMy5wbmciLCJpbWFnZTI0LnBuZyIsImltYWdlMjUucG5nIiwiaW1hZ2UyNi5wbmciLCJpbWFnZTI3LnBuZyIsImltYWdlMjgucG5nIiwiaW1hZ2UyOS5wbmciLCJpbWFnZTMwLnBuZyIsImltYWdlMzEucG5nIiwiaW1hZ2UzMi5wbmciLCJpbWFnZTMzLnBuZyIsImltYWdlMzQucG5nIiwiaW1hZ2UzNS5wbmciLCJpbWFnZTM2LnBuZyIsImltYWdlMzcucG5nIiwiaW1hZ2UzOC5wbmciLCJpbWFnZTM5LnBuZyIsImltYWdlNDAucG5nIiwiaW1hZ2U0MS5wbmciLCJpbWFnZTQyLnBuZyIsImltYWdlNDMucG5nIiwiaW1hZ2U0NC5wbmciLCJpbWFnZTQ1LnBuZyIsImltYWdlNDYucG5nIiwiaW1hZ2U0Ny5wbmciLCJpbWFnZTQ4LnBuZyIsImltYWdlNDkucG5nIiwiaW1hZ2U1MC5wbmciLCJpbWFnZTUxLnBuZyIsImltYWdlNTIucG5nIiwiaW1hZ2U1My5wbmciLCJpbWFnZTU0LnBuZyIsImltYWdlNTUucG5nIiwiaW1hZ2U1Ni5wbmciLCJpbWFnZTU3LnBuZyIsImltYWdlNTgucG5nIiwiaW1hZ2U1OS5wbmciLCJpbWFnZTYwLnBuZyIsImltYWdlNjEucG5nIiwiaW1hZ2U2Mi5wbmciLCJpbWFnZTYzLnBuZyIsImltYWdlNjQucG5nIiwiaW1hZ2U2NS5wbmciLCJpbWFnZTY2LnBuZyIsImltYWdlNjcucG5nIiwiaW1hZ2U2OC5wbmciLCJpbWFnZTY5LnBuZyIsImltYWdlNzAucG5nIiwiaW1hZ2U3MS5wbmciLCJpbWFnZTcyLnBuZyIsImltYWdlNzMucG5nIiwiaW1hZ2U3NC5wbmciLCJpbWFnZTc1LnBuZyIsImltYWdlNzYucG5nIiwiaW1hZ2U3Ny5wbmciLCJpbWFnZTc4LnBuZyIsImltYWdlNzkucG5nIiwiaW1hZ2U4MC5wbmciLCJpbWFnZTgxLnBuZyIsImltYWdlODIucG5nIiwiaW1hZ2U4My5wbmciLCJpbWFnZTg0LnBuZyIsImltYWdlODUucG5nIiwiaW1hZ2U4Ni5wbmciLCJpbWFnZTg3LnBuZyIsImltYWdlODgucG5nIiwiaW1hZ2U4OS5wbmciLCJpbWFnZTkwLnBuZyIsImltYWdlOTEucG5nIiwiaW1hZ2U5Mi5wbmciLCJpbWFnZTkzLnBuZyIsImltYWdlOTQucG5nIiwiaW1hZ2U5NS5wbmciLCJpbWFnZTk2LnBuZyIsImltYWdlOTcucG5nIiwiaW1hZ2U5OC5wbmciLCJpbWFnZTk5LnBuZyIsImltYWdlMTAwLnBuZyIsImltYWdlMTAxLnBuZyIsImltYWdlMTAyLnBuZyIsImltYWdlMTAzLnBuZyIsImltYWdlMTA0LnBuZyIsImltYWdlMTA1LnBuZyIsImltYWdlMTA2LnBuZyIsImltYWdlMTA3LnBuZyIsImltYWdlMTA4LnBuZyIsImltYWdlMTA5LnBuZyIsImltYWdlMTEwLnBuZyIsImltYWdlMTExLnBuZyIsImltYWdlMTEyLnBuZyIsImltYWdlMTEzLnBuZyIsImltYWdlMTE0LnBuZyIsImltYWdlMTE1LnBuZyIsImltYWdlMTE2LnBuZyIsImltYWdlMTE3LnBuZyIsImltYWdlMTE4LnBuZyIsImltYWdlMTE5LnBuZyIsImltYWdlMTIwLnBuZyIsImltYWdlMTIxLnBuZyIsImltYWdlMTIyLnBuZyIsImltYWdlMTIzLnBuZyIsImltYWdlMTI0LnBuZyIsImltYWdlMTI1LnBuZyIsImltYWdlMTI2LnBuZyIsImltYWdlMTI3LnBuZyIsImltYWdlMTI4LnBuZyIsImltYWdlMTI5LnBuZyIsImltYWdlMTMwLnBuZyIsImltYWdlMTMxLnBuZyIsImltYWdlMTMyLnBuZyIsImltYWdlMTMzLnBuZyIsImltYWdlMTM0LnBuZyIsImltYWdlMTM1LnBuZyIsImltYWdlMTM2LnBuZyIsImltYWdlMTM3LnBuZyIsImltYWdlMTM4LnBuZyIsImltYWdlMTM5LnBuZyIsImltYWdlMTQwLnBuZyIsImltYWdlMTQxLnBuZyIsImltYWdlMTQyLnBuZyIsImltYWdlMTQzLnBuZyIsImltYWdlMTQ0LnBuZyIsImltYWdlMTQ1LnBuZyIsImltYWdlMTQ2LnBuZyIsImltYWdlMTQ3LnBuZyIsImltYWdlMTQ4LnBuZyIsImltYWdlMTQ5LnBuZyIsImltYWdlMTUwLnBuZyIsImltYWdlMTUxLnBuZyIsImltYWdlMTUyLnBuZyIsImltYWdlMTUzLnBuZyIsImltYWdlMTU0LnBuZyIsImltYWdlMTU1LnBuZyIsImltYWdlMTU2LnBuZyIsImltYWdlMTU3LnBuZyIsImltYWdlMTU4LnBuZyIsImltYWdlMTU5LnBuZyIsImltYWdlMTYwLnBuZyIsImltYWdlMTYxLnBuZyIsImltYWdlMTYyLnBuZyIsImltYWdlMTYzLnBuZyIsImltYWdlMTY0LnBuZyIsImltYWdlMTY1LnBuZyIsImltYWdlMTY2LnBuZyIsImltYWdlMTY3LnBuZyIsImltYWdlMTY4LnBuZyIsImltYWdlMTY5LnBuZyIsImltYWdlMTcwLnBuZyIsImltYWdlMTcxLnBuZyIsImltYWdlMTcyLnBuZyIsImltYWdlMTczLnBuZyIsImltYWdlMTc0LnBuZyIsImltYWdlMTc1LnBuZyIsImltYWdlMTc2LnBuZyIsImltYWdlMTc3LnBuZyIsImltYWdlMTc4LnBuZyIsImltYWdlMTc5LnBuZyIsImltYWdlMTgwLnBuZyIsImltYWdlMTgxLnBuZyIsImltYWdlMTgyLnBuZyIsImltYWdlMTgzLnBuZyIsImltYWdlMTg0LnBuZyIsImltYWdlMTg1LnBuZyIsImltYWdlMTg2LnBuZyIsImltYWdlMTg3LnBuZyIsImltYWdlMTg4LnBuZyIsImltYWdlMTg5LnBuZyIsImltYWdlMTkwLnBuZyIsImltYWdlMTkxLnBuZyIsImltYWdlMTkyLnBuZyIsImltYWdlMTkzLnBuZyIsImltYWdlMTk0LnBuZyIsImltYWdlMTk1LnBuZyIsImltYWdlMTk2LnBuZyIsImltYWdlMTk3LnBuZyIsImltYWdlMTk4LnBuZyIsImltYWdlMTk5LnBuZyIsImltYWdlMjAwLnBuZyIsImltYWdlMjAxLnBuZyIsImltYWdlMjAyLnBuZyIsImltYWdlMjAzLnBuZyIsImltYWdlMjA0LnBuZyIsImltYWdlMjA1LnBuZyIsImltYWdlMjA2LnBuZyIsImltYWdlMjA3LnBuZyIsImltYWdlMjA4LnBuZyIsImltYWdlMjA5LnBuZyIsImltYWdlMjEwLnBuZyIsImltYWdlMjExLnBuZyIsImltYWdlMjEyLnBuZyIsImltYWdlMjEzLnBuZyIsImltYWdlMjE0LnBuZyIsImltYWdlMjE1LnBuZyIsImltYWdlMjE2LnBuZyIsImltYWdlMjE3LnBuZyIsImltYWdlMjE4LnBuZyIsImltYWdlMjE5LnBuZyIsImltYWdlMjIwLnBuZyIsImltYWdlMjIxLnBuZyIsImltYWdlMjIyLnBuZyIsImltYWdlMjIzLnBuZyIsImltYWdlMjI0LnBuZyIsImltYWdlMjI1LnBuZyIsImltYWdlMjI2LnBuZyIsImltYWdlMjI3LnBuZyIsImltYWdlMjI4LnBuZyIsImltYWdlMjI5LnBuZyIsImltYWdlMjMwLnBuZyIsImltYWdlMjMxLnBuZyIsImltYWdlMjMyLnBuZyIsImltYWdlMjMzLnBuZyIsImltYWdlMjM0LnBuZyIsImltYWdlMjM1LnBuZyIsImltYWdlMjM2LnBuZyIsImltYWdlMjM3LnBuZyIsImltYWdlMjM4LnBuZyIsImltYWdlMjM5LnBuZyIsImltYWdlMjQwLnBuZyIsImltYWdlMjQxLnBuZyIsImltYWdlMjQyLnBuZyIsImltYWdlMjQzLnBuZyIsImltYWdlMjQ0LnBuZyIsImltYWdlMjQ1LnBuZyIsImltYWdlMjQ2LnBuZyIsImltYWdlMjQ3LnBuZyIsImltYWdlMjQ4LnBuZyIsImltYWdlMjQ5LnBuZyIsImltYWdlMjUwLnBuZyIsImltYWdlMjUxLnBuZyIsImltYWdlMjUyLnBuZyIsImltYWdlMjUzLnBuZyIsImltYWdlMjU0LnBuZyIsImltYWdlMjU1LnBuZyIsImltYWdlMjU2LnBuZyIsImltYWdlMjU3LnBuZyIsImltYWdlMjU4LnBuZyIsImltYWdlMjU5LnBuZyIsImltYWdlMjYwLnBuZyIsImltYWdlMjYxLnBuZyIsImltYWdlMjYyLnBuZyIsImltYWdlMjYzLnBuZyIsImltYWdlMjY0LnBuZyIsImltYWdlMjY1LnBuZyIsImltYWdlMjY2LnBuZyIsImltYWdlMjY3LnBuZyIsImltYWdlMjY4LnBuZyIsImltYWdlMjY5LnBuZyIsImltYWdlMjcwLnBuZyIsImltYWdlMjcxLnBuZyIsImltYWdlMjcyLnBuZyIsImltYWdlMjczLnBuZyIsImltYWdlMjc0LnBuZyIsImltYWdlMjc1LnBuZyIsImltYWdlMjc2LnBuZyIsImltYWdlMjc3LnBuZyIsImltYWdlMjc4LnBuZyIsImltYWdlMjc5LnBuZyIsImltYWdlMjgwLnBuZyIsImltYWdlMjgxLnBuZyIsImltYWdlMjgyLnBuZyIsImltYWdlMjgzLnBuZyIsImltYWdlMjg0LnBuZyIsImltYWdlMjg1LnBuZyIsImltYWdlMjg2LnBuZyIsImltYWdlMjg3LnBuZyIsImltYWdlMjg4LnBuZyIsImltYWdlMjg5LnBuZyIsImltYWdlMjkwLnBuZyIsImltYWdlMjkxLnBuZyIsImltYWdlMjkyLnBuZyIsImltYWdlMjkzLnBuZyIsImltYWdlMjk0LnBuZyIsImltYWdlMjk1LnBuZyIsImltYWdlMjk2LnBuZyIsImltYWdlMjk3LnBuZyIsImltYWdlMjk4LnBuZyIsImltYWdlMjk5LnBuZyIsImltYWdlMzAwLnBuZyIsImltYWdlMzAxLnBuZyIsImltYWdlMzAyLnBuZyIsImltYWdlMzAzLnBuZyIsImltYWdlMzA0LnBuZyIsImltYWdlMzA1LnBuZyIsImltYWdlMzA2LnBuZyIsImltYWdlMzA3LnBuZyIsImltYWdlMzA4LnBuZyIsImltYWdlMzA5LnBuZyIsImltYWdlMzEwLnBuZyIsImltYWdlMzExLnBuZyIsImltYWdlMzEyLnBuZyIsImltYWdlMzEzLnBuZyIsImltYWdlMzE0LnBuZyIsImltYWdlMzE1LnBuZyIsImltYWdlMzE2LnBuZyIsImltYWdlMzE3LnBuZyIsImltYWdlMzE4LnBuZyIsImltYWdlMzE5LnBuZyIsImltYWdlMzIwLnBuZyIsImltYWdlMzIxLnBuZyIsImltYWdlMzIyLnBuZyIsImltYWdlMzIzLnBuZyIsImltYWdlMzI0LnBuZyIsImltYWdlMzI1LnBuZyIsImltYWdlMzI2LnBuZyIsImltYWdlMzI3LnBuZyIsImltYWdlMzI4LnBuZyIsImltYWdlMzI5LnBuZyIsImltYWdlMzMwLnBuZyIsImltYWdlMzMxLnBuZyIsImltYWdlMzMyLnBuZyIsImltYWdlMzMzLnBuZyIsImltYWdlMzM0LnBuZyIsImltYWdlMzM1LnBuZyIsImltYWdlMzM2LnBuZyIsImltYWdlMzM3LnBuZyIsImltYWdlMzM4LnBuZyIsImltYWdlMzM5LnBuZyIsImltYWdlMzQwLnBuZyIsImltYWdlMzQxLnBuZyIsImltYWdlMzQyLnBuZyIsImltYWdlMzQzLnBuZyIsImltYWdlMzQ0LnBuZyIsImltYWdlMzQ1LnBuZyIsImltYWdlMzQ2LnBuZyIsImltYWdlMzQ3LnBuZyIsImltYWdlMzQ4LnBuZyIsImltYWdlMzQ5LnBuZyIsImltYWdlMzUwLnBuZyIsImltYWdlMzUxLnBuZyIsImltYWdlMzUyLnBuZyIsImltYWdlMzUzLnBuZyIsImltYWdlMzU0LnBuZyIsImltYWdlMzU1LnBuZyIsImltYWdlMzU2LnBuZyIsImltYWdlMzU3LnBuZyIsImltYWdlMzU4LnBuZyIsImltYWdlMzU5LnBuZyIsImltYWdlMzYwLnBuZyIsImltYWdlMzYxLnBuZyIsImltYWdlMzYyLnBuZyIsImltYWdlMzYzLnBuZyIsImltYWdlMzY0LnBuZyIsImltYWdlMzY1LnBuZyIsImltYWdlMzY2LnBuZyIsImltYWdlMzY3LnBuZyIsImltYWdlMzY4LnBuZyIsImltYWdlMzY5LnBuZyIsImltYWdlMzcwLnBuZyIsImltYWdlMzcxLnBuZyIsImltYWdlMzcyLnBuZyIsImltYWdlMzczLnBuZyIsImltYWdlMzc0LnBuZyIsImltYWdlMzc1LnBuZyIsImltYWdlMzc2LnBuZyIsImltYWdlMzc3LnBuZyIsImltYWdlMzc4LnBuZyIsImltYWdlMzc5LnBuZyIsImltYWdlMzgwLnBuZyIsImltYWdlMzgxLnBuZyIsImltYWdlMzgyLnBuZyIsImltYWdlMzgzLnBuZyIsImltYWdlMzg0LnBuZyIsImltYWdlMzg1LnBuZyIsImltYWdlMzg2LnBuZyIsImltYWdlMzg3LnBuZyIsImltYWdlMzg4LnBuZyIsImltYWdlMzg5LnBuZyIsImltYWdlMzkwLnBuZyIsImltYWdlMzkxLnBuZyIsImltYWdlMzkyLnBuZyIsImltYWdlMzkzLnBuZyIsImltYWdlMzk0LnBuZyIsImltYWdlMzk1LnBuZyIsImltYWdlMzk2LnBuZyIsImltYWdlMzk3LnBuZyIsImltYWdlMzk4LnBuZyIsImltYWdlMzk5LnBuZyIsImltYWdlNDAwLnBuZyIsImltYWdlNDAxLnBuZyIsImltYWdlNDAyLnBuZyIsImltYWdlNDAzLnBuZyIsImltYWdlNDA0LnBuZyIsImltYWdlNDA1LnBuZyIsImltYWdlNDA2LnBuZyIsImltYWdlNDA3LnBuZyIsImltYWdlNDA4LnBuZyIsImltYWdlNDA5LnBuZyIsImltYWdlNDEwLnBuZyIsImltYWdlNDExLnBuZyIsImltYWdlNDEyLnBuZyIsImltYWdlNDEzLnBuZyIsImltYWdlNDE0LnBuZyIsImltYWdlNDE1LnBuZyIsImltYWdlNDE2LnBuZyIsImltYWdlNDE3LnBuZyIsImltYWdlNDE4LnBuZyIsImltYWdlNDE5LnBuZyIsImltYWdlNDIwLnBuZyIsImltYWdlNDIxLnBuZyIsImltYWdlNDIyLnBuZyIsImltYWdlNDIzLnBuZyIsImltYWdlNDI0LnBuZyIsImltYWdlNDI1LnBuZyIsImltYWdlNDI2LnBuZyIsImltYWdlNDI3LnBuZyIsImltYWdlNDI4LnBuZyIsImltYWdlNDI5LnBuZyIsImltYWdlNDMwLnBuZyIsImltYWdlNDMxLnBuZyIsImltYWdlNDMyLnBuZyIsImltYWdlNDMzLnBuZyIsImltYWdlNDM0LnBuZyIsImltYWdlNDM1LnBuZyIsImltYWdlNDM2LnBuZyIsImltYWdlNDM3LnBuZyIsImltYWdlNDM4LnBuZyIsImltYWdlNDM5LnBuZyIsImltYWdlNDQwLnBuZyIsImltYWdlNDQxLnBuZyIsImltYWdlNDQyLnBuZyIsImltYWdlNDQzLnBuZyIsImltYWdlNDQ0LnBuZyIsImltYWdlNDQ1LnBuZyIsImltYWdlNDQ2LnBuZyIsImltYWdlNDQ3LnBuZyIsImltYWdlNDQ4LnBuZyIsImltYWdlNDQ5LnBuZyIsImltYWdlNDUwLnBuZyIsImltYWdlNDUxLnBuZyIsImltYWdlNDUyLnBuZyIsImltYWdlNDUzLnBuZyIsImltYWdlNDU0LnBuZyIsImltYWdlNDU1LnBuZyIsImltYWdlNDU2LnBuZyIsImltYWdlNDU3LnBuZyIsImltYWdlNDU4LnBuZyIsImltYWdlNDU5LnBuZyIsImltYWdlNDYwLnBuZyIsImltYWdlNDYxLnBuZyIsImltYWdlNDYyLnBuZyIsImltYWdlNDYzLnBuZyIsImltYWdlNDY0LnBuZyIsImltYWdlNDY1LnBuZyIsImltYWdlNDY2LnBuZyIsImltYWdlNDY3LnBuZyIsImltYWdlNDY4LnBuZyIsImltYWdlNDY5LnBuZyIsImltYWdlNDcwLnBuZyIsImltYWdlNDcxLnBuZyIsImltYWdlNDcyLnBuZyIsImltYWdlNDczLnBuZyIsImltYWdlNDc0LnBuZyIsImltYWdlNDc1LnBuZyIsImltYWdlNDc2LnBuZyIsImltYWdlNDc3LnBuZyIsImltYWdlNDc4LnBuZyIsImltYWdlNDc5LnBuZyIsImltYWdlNDgwLnBuZyIsImltYWdlNDgxLnBuZyIsImltYWdlNDgyLnBuZyIsImltYWdlNDgzLnBuZyIsImltYWdlNDg0LnBuZyIsImltYWdlNDg1LnBuZyIsImltYWdlNDg2LnBuZyIsImltYWdlNDg3LnBuZyIsImltYWdlNDg4LnBuZyIsImltYWdlNDg5LnBuZyIsImltYWdlNDkwLnBuZyIsImltYWdlNDkxLnBuZyIsImltYWdlNDkyLnBuZyIsImltYWdlNDkzLnBuZyIsImltYWdlNDk0LnBuZyIsImltYWdlNDk1LnBuZyIsImltYWdlNDk2LnBuZyIsImltYWdlNDk3LnBuZyIsImltYWdlNDk4LnBuZyIsImltYWdlNDk5LnBuZyIsImltYWdlNTAwLnBuZyIsImltYWdlNTAxLnBuZyIsImltYWdlNTAyLnBuZyIsImltYWdlNTAzLnBuZyIsImltYWdlNTA0LnBuZyIsImltYWdlNTA1LnBuZyIsImltYWdlNTA2LnBuZyIsImltYWdlNTA3LnBuZyIsImltYWdlNTA4LnBuZyIsImltYWdlNTA5LnBuZyIsImltYWdlNTEwLnBuZyIsImltYWdlNTExLnBuZyIsImltYWdlNTEyLnBuZyIsImltYWdlNTEzLnBuZyIsImltYWdlNTE0LnBuZyIsImltYWdlNTE1LnBuZyIsImltYWdlNTE2LnBuZyIsImltYWdlNTE3LnBuZyIsImltYWdlNTE4LnBuZyIsImltYWdlNTE5LnBuZyIsImltYWdlNTIwLnBuZyIsImltYWdlNTIxLnBuZyIsImltYWdlNTIyLnBuZyIsImltYWdlNTIzLnBuZyIsImltYWdlNTI0LnBuZyIsImltYWdlNTI1LnBuZyIsImltYWdlNTI2LnBuZyIsImltYWdlNTI3LnBuZyIsImltYWdlNTI4LnBuZyIsImltYWdlNTI5LnBuZyIsImltYWdlNTMwLnBuZyIsImltYWdlNTMxLnBuZyIsImltYWdlNTMyLnBuZyIsImltYWdlNTMzLnBuZyIsImltYWdlNTM0LnBuZyIsImltYWdlNTM1LnBuZyIsImltYWdlNTM2LnBuZyIsImltYWdlNTM3LnBuZyIsImltYWdlNTM4LnBuZyIsImltYWdlNTM5LnBuZyIsImltYWdlNTQwLnBuZyIsImltYWdlNTQxLnBuZyIsImltYWdlNTQyLnBuZyIsImltYWdlNTQzLnBuZyIsImltYWdlNTQ0LnBuZyIsImltYWdlNTQ1LnBuZyIsImltYWdlNTQ2LnBuZyIsImltYWdlNTQ3LnBuZyIsImltYWdlNTQ4LnBuZyIsImltYWdlNTQ5LnBuZyIsImltYWdlNTUwLnBuZyIsImltYWdlNTUxLnBuZyIsImltYWdlNTUyLnBuZyIsImltYWdlNTUzLnBuZyIsImltYWdlNTU0LnBuZyIsImltYWdlNTU1LnBuZyIsImltYWdlNTU2LnBuZyIsImltYWdlNTU3LnBuZyIsImltYWdlNTU4LnBuZyIsImltYWdlNTU5LnBuZyIsImltYWdlNTYwLnBuZyIsImltYWdlNTYxLnBuZyIsImltYWdlNTYyLnBuZyIsImltYWdlNTYzLnBuZyIsImltYWdlNTY0LnBuZyIsImltYWdlNTY1LnBuZyIsImltYWdlNTY2LnBuZyIsImltYWdlNTY3LnBuZyIsImltYWdlNTY4LnBuZyIsImltYWdlNTY5LnBuZyIsImltYWdlNTcwLnBuZyIsImltYWdlNTcxLnBuZyIsImltYWdlNTcyLnBuZyIsImltYWdlNTczLnBuZyIsImltYWdlNTc0LnBuZyIsImltYWdlNTc1LnBuZyIsImltYWdlNTc2LnBuZyIsImltYWdlNTc3LnBuZyIsImltYWdlNTc4LnBuZyIsImltYWdlNTc5LnBuZyIsImltYWdlNTgwLnBuZyIsImltYWdlNTgxLnBuZyIsImltYWdlNTgyLnBuZyIsImltYWdlNTgzLnBuZyIsImltYWdlNTg0LnBuZyIsImltYWdlNTg1LnBuZyIsImltYWdlNTg2LnBuZyIsImltYWdlNTg3LnBuZyIsImltYWdlNTg4LnBuZyIsImltYWdlNTg5LnBuZyIsImltYWdlNTkwLnBuZyIsImltYWdlNTkxLnBuZyIsImltYWdlNTkyLnBuZyIsImltYWdlNTkzLnBuZyIsImltYWdlNTk0LnBuZyIsImltYWdlNTk1LnBuZyIsImltYWdlNTk2LnBuZyIsImltYWdlNTk3LnBuZyIsImltYWdlNTk4LnBuZyIsImltYWdlNTk5LnBuZyIsImltYWdlNjAwLnBuZyIsImltYWdlNjAxLnBuZyIsImltYWdlNjAyLnBuZyIsImltYWdlNjAzLnBuZyIsImltYWdlNjA0LnBuZyIsImltYWdlNjA1LnBuZyIsImltYWdlNjA2LnBuZyIsImltYWdlNjA3LnBuZyIsImltYWdlNjA4LnBuZyIsImltYWdlNjA5LnBuZyIsImltYWdlNjEwLnBuZyIsImltYWdlNjExLnBuZyIsImltYWdlNjEyLnBuZyIsImltYWdlNjEzLnBuZyIsImltYWdlNjE0LnBuZyIsImltYWdlNjE1LnBuZyIsImltYWdlNjE2LnBuZyIsImltYWdlNjE3LnBuZyIsImltYWdlNjE4LnBuZyIsImltYWdlNjE5LnBuZyIsImltYWdlNjIwLnBuZyIsImltYWdlNjIxLnBuZyIsImltYWdlNjIyLnBuZyIsImltYWdlNjIzLnBuZyIsImltYWdlNjI0LnBuZyIsImltYWdlNjI1LnBuZyIsImltYWdlNjI2LnBuZyIsImltYWdlNjI3LnBuZyIsImltYWdlNjI4LnBuZyIsImltYWdlNjI5LnBuZyIsImltYWdlNjMwLnBuZyIsImltYWdlNjMxLnBuZyIsImltYWdlNjMyLnBuZyIsImltYWdlNjMzLnBuZyIsImltYWdlNjM0LnBuZyIsImltYWdlNjM1LnBuZyIsImltYWdlNjM2LnBuZyIsImltYWdlNjM3LnBuZyIsImltYWdlNjM4LnBuZyIsImltYWdlNjM5LnBuZyIsImltYWdlNjQwLnBuZyIsImltYWdlNjQxLnBuZyIsImltYWdlNjQyLnBuZyIsImltYWdlNjQzLnBuZyIsImltYWdlNjQ0LnBuZyIsImltYWdlNjQ1LnBuZyIsImltYWdlNjQ2LnBuZyIsImltYWdlNjQ3LnBuZyIsImltYWdlNjQ4LnBuZyIsImltYWdlNjQ5LnBuZyIsImltYWdlNjUwLnBuZyIsImltYWdlNjUxLnBuZyIsImltYWdlNjUyLnBuZyIsImltYWdlNjUzLnBuZyIsImltYWdlNjU0LnBuZyIsImltYWdlNjU1LnBuZyIsImltYWdlNjU2LnBuZyIsImltYWdlNjU3LnBuZyIsImltYWdlNjU4LnBuZyIsImltYWdlNjU5LnBuZyIsImltYWdlNjYwLnBuZyIsImltYWdlNjYxLnBuZyIsImltYWdlNjYyLnBuZyIsImltYWdlNjYzLnBuZyIsImltYWdlNjY0LnBuZyIsImltYWdlNjY1LnBuZyIsImltYWdlNjY2LnBuZyIsImltYWdlNjY3LnBuZyIsImltYWdlNjY4LnBuZyIsImltYWdlNjY5LnBuZyIsImltYWdlNjcwLnBuZyIsImltYWdlNjcxLnBuZyIsImltYWdlNjcyLnBuZyIsImltYWdlNjczLnBuZyIsImltYWdlNjc0LnBuZyIsImltYWdlNjc1LnBuZyIsImltYWdlNjc2LnBuZyIsImltYWdlNjc3LnBuZyIsImltYWdlNjc4LnBuZyIsImltYWdlNjc5LnBuZyIsImltYWdlNjgwLnBuZyIsImltYWdlNjgxLnBuZyIsImltYWdlNjgyLnBuZyIsImltYWdlNjgzLnBuZyIsImltYWdlNjg0LnBuZyIsImltYWdlNjg1LnBuZyIsImltYWdlNjg2LnBuZyIsImltYWdlNjg3LnBuZyIsImltYWdlNjg4LnBuZyIsImltYWdlNjg5LnBuZyIsImltYWdlNjkwLnBuZyIsImltYWdlNjkxLnBuZyIsImltYWdlNjkyLnBuZyIsImltYWdlNjkzLnBuZyIsImltYWdlNjk0LnBuZyIsImltYWdlNjk1LnBuZyIsImltYWdlNjk2LnBuZyIsImltYWdlNjk3LnBuZyIsImltYWdlNjk4LnBuZyIsImltYWdlNjk5LnBuZyIsImltYWdlNzAwLnBuZyIsImltYWdlNzAxLnBuZyIsImltYWdlNzAyLnBuZyIsImltYWdlNzAzLnBuZyIsImltYWdlNzA0LnBuZyIsImltYWdlNzA1LnBuZyIsImltYWdlNzA2LnBuZyIsImltYWdlNzA3LnBuZyIsImltYWdlNzA4LnBuZyIsImltYWdlNzA5LnBuZyIsImltYWdlNzEwLnBuZyIsImltYWdlNzExLnBuZyIsImltYWdlNzEyLnBuZyIsImltYWdlNzEzLnBuZyIsImltYWdlNzE0LnBuZyIsImltYWdlNzE1LnBuZyIsImltYWdlNzE2LnBuZyIsImltYWdlNzE3LnBuZyIsImltYWdlNzE4LnBuZyIsImltYWdlNzE5LnBuZyIsImltYWdlNzIwLnBuZyIsImltYWdlNzIxLnBuZyIsImltYWdlNzIyLnBuZyIsImltYWdlNzIzLnBuZyIsImltYWdlNzI0LnBuZyIsImltYWdlNzI1LnBuZyIsImltYWdlNzI2LnBuZyIsImltYWdlNzI3LnBuZyIsImltYWdlNzI4LnBuZyIsImltYWdlNzI5LnBuZyIsImltYWdlNzMwLnBuZyIsImltYWdlNzMxLnBuZyIsImltYWdlNzMyLnBuZyIsImltYWdlNzMzLnBuZyIsImltYWdlNzM0LnBuZyIsImltYWdlNzM1LnBuZyIsImltYWdlNzM2LnBuZyIsImltYWdlNzM3LnBuZyIsImltYWdlNzM4LnBuZyIsImltYWdlNzM5LnBuZyIsImltYWdlNzQwLnBuZyIsImltYWdlNzQxLnBuZyIsImltYWdlNzQyLnBuZyIsImltYWdlNzQzLnBuZyIsImltYWdlNzQ0LnBuZyIsImltYWdlNzQ1LnBuZyIsImltYWdlNzQ2LnBuZyIsImltYWdlNzQ3LnBuZyIsImltYWdlNzQ4LnBuZyIsImltYWdlNzQ5LnBuZyIsImltYWdlNzUwLnBuZyIsImltYWdlNzUxLnBuZyIsImltYWdlNzUyLnBuZyIsImltYWdlNzUzLnBuZyIsImltYWdlNzU0LnBuZyIsImltYWdlNzU1LnBuZyIsImltYWdlNzU2LnBuZyIsImltYWdlNzU3LnBuZyIsImltYWdlNzU4LnBuZyIsImltYWdlNzU5LnBuZyIsImltYWdlNzYwLnBuZyIsImltYWdlNzYxLnBuZyIsImltYWdlNzYyLnBuZyIsImltYWdlNzYzLnBuZyIsImltYWdlNzY0LnBuZyIsImltYWdlNzY1LnBuZyIsImltYWdlNzY2LnBuZyIsImltYWdlNzY3LnBuZyIsImltYWdlNzY4LnBuZyIsImltYWdlNzY5LnBuZyIsImltYWdlNzcwLnBuZyIsImltYWdlNzcxLnBuZyIsImltYWdlNzcyLnBuZyIsImltYWdlNzczLnBuZyIsImltYWdlNzc0LnBuZyIsImltYWdlNzc1LnBuZyIsImltYWdlNzc2LnBuZyIsImltYWdlNzc3LnBuZyIsImltYWdlNzc4LnBuZyIsImltYWdlNzc5LnBuZyIsImltYWdlNzgwLnBuZyIsImltYWdlNzgxLnBuZyIsImltYWdlNzgyLnBuZyIsImltYWdlNzgzLnBuZyIsImltYWdlNzg0LnBuZyIsImltYWdlNzg1LnBuZyIsImltYWdlNzg2LnBuZyIsImltYWdlNzg3LnBuZyIsImltYWdlNzg4LnBuZyIsImltYWdlNzg5LnBuZyIsImltYWdlNzkwLnBuZyIsImltYWdlNzkxLnBuZyIsImltYWdlNzkyLnBuZyIsImltYWdlNzkzLnBuZyIsImltYWdlNzk0LnBuZyIsImltYWdlNzk1LnBuZyIsImltYWdlNzk2LnBuZyIsImltYWdlNzk3LnBuZyIsImltYWdlNzk4LnBuZyIsImltYWdlNzk5LnBuZyIsImltYWdlODAwLnBuZyIsImltYWdlODAxLnBuZyIsImltYWdlODAyLnBuZyIsImltYWdlODAzLnBuZyIsImltYWdlODA0LnBuZyIsImltYWdlODA1LnBuZyIsImltYWdlODA2LnBuZyIsImltYWdlODA3LnBuZyIsImltYWdlODA4LnBuZyIsImltYWdlODA5LnBuZyIsImltYWdlODEwLnBuZyIsImltYWdlODExLnBuZyIsImltYWdlODEyLnBuZyIsImltYWdlODEzLnBuZyIsImltYWdlODE0LnBuZyIsImltYWdlODE1LnBuZyIsImltYWdlODE2LnBuZyIsImltYWdlODE3LnBuZyIsImltYWdlODE4LnBuZyIsImltYWdlODE5LnBuZyIsImltYWdlODIwLnBuZyIsImltYWdlODIxLnBuZyIsImltYWdlODIyLnBuZyIsImltYWdlODIzLnBuZyIsImltYWdlODI0LnBuZyIsImltYWdlODI1LnBuZyIsImltYWdlODI2LnBuZyIsImltYWdlODI3LnBuZyIsImltYWdlODI4LnBuZyIsImltYWdlODI5LnBuZyIsImltYWdlODMwLnBuZyIsImltYWdlODMxLnBuZyIsImltYWdlODMyLnBuZyIsImltYWdlODMzLnBuZyIsImltYWdlODM0LnBuZyIsImltYWdlODM1LnBuZyIsImltYWdlODM2LnBuZyIsImltYWdlODM3LnBuZyIsImltYWdlODM4LnBuZyIsImltYWdlODM5LnBuZyIsImltYWdlODQwLnBuZyIsImltYWdlODQxLnBuZyIsImltYWdlODQyLnBuZyIsImltYWdlODQzLnBuZyIsImltYWdlODQ0LnBuZyIsImltYWdlODQ1LnBuZyIsImltYWdlODQ2LnBuZyIsImltYWdlODQ3LnBuZyIsImltYWdlODQ4LnBuZyIsImltYWdlODQ5LnBuZyIsImltYWdlODUwLnBuZyIsImltYWdlODUxLnBuZyIsImltYWdlODUyLnBuZyIsImltYWdlODUzLnBuZyIsImltYWdlODU0LnBuZyIsImltYWdlODU1LnBuZyIsImltYWdlODU2LnBuZyIsImltYWdlODU3LnBuZyIsImltYWdlODU4LnBuZyIsImltYWdlODU5LnBuZyIsImltYWdlODYwLnBuZyIsImltYWdlODYxLnBuZyIsImltYWdlODYyLnBuZyIsImltYWdlODYzLnBuZyIsImltYWdlODY0LnBuZyIsImltYWdlODY1LnBuZyIsImltYWdlODY2LnBuZyIsImltYWdlODY3LnBuZyIsImltYWdlODY4LnBuZyIsImltYWdlODY5LnBuZyIsImltYWdlODcwLnBuZyIsImltYWdlODcxLnBuZyIsImltYWdlODcyLnBuZyIsImltYWdlODczLnBuZyIsImltYWdlODc0LnBuZyIsImltYWdlODc1LnBuZyIsImltYWdlODc2LnBuZyIsImltYWdlODc3LnBuZyIsImltYWdlODc4LnBuZyIsImltYWdlODc5LnBuZyIsImltYWdlODgwLnBuZyIsImltYWdlODgxLnBuZyIsImltYWdlODgyLnBuZyIsImltYWdlODgzLnBuZyIsImltYWdlODg0LnBuZyIsImltYWdlODg1LnBuZyIsImltYWdlODg2LnBuZyIsImltYWdlODg3LnBuZyIsImltYWdlODg4LnBuZyIsImltYWdlODg5LnBuZyIsImltYWdlODkwLnBuZyIsImltYWdlODkxLnBuZyIsImltYWdlODkyLnBuZyIsImltYWdlODkzLnBuZyIsImltYWdlODk0LnBuZyIsImltYWdlODk1LnBuZyIsImltYWdlODk2LnBuZyIsImltYWdlODk3LnBuZyIsImltYWdlODk4LnBuZyIsImltYWdlODk5LnBuZyIsImltYWdlOTAwLnBuZyIsImltYWdlOTAxLnBuZyIsImltYWdlOTAyLnBuZyIsImltYWdlOTAzLnBuZyIsImltYWdlOTA0LnBuZyIsImltYWdlOTA1LnBuZyIsImltYWdlOTA2LnBuZyIsImltYWdlOTA3LnBuZyIsImltYWdlOTA4LnBuZyIsImltYWdlOTA5LnBuZyIsImltYWdlOTEwLnBuZyIsImltYWdlOTExLnBuZyIsImltYWdlOTEyLnBuZyIsImltYWdlOTEzLnBuZyIsImltYWdlOTE0LnBuZyIsImltYWdlOTE1LnBuZyIsImltYWdlOTE2LnBuZyIsImltYWdlOTE3LnBuZyIsImltYWdlOTE4LnBuZyIsImltYWdlOTE5LnBuZyIsImltYWdlOTIwLnBuZyIsImltYWdlOTIxLnBuZyIsImltYWdlOTIyLnBuZyIsImltYWdlOTIzLnBuZyIsImltYWdlOTI0LnBuZyIsImltYWdlOTI1LnBuZyIsImltYWdlOTI2LnBuZyIsImltYWdlOTI3LnBuZyIsImltYWdlOTI4LnBuZyIsImltYWdlOTI5LnBuZyIsImltYWdlOTMwLnBuZyIsImltYWdlOTMxLnBuZyIsImltYWdlOTMyLnBuZyIsImltYWdlOTMzLnBuZyIsImltYWdlOTM0LnBuZyIsImltYWdlOTM1LnBuZyIsImltYWdlOTM2LnBuZyIsImltYWdlOTM3LnBuZyIsImltYWdlOTM4LnBuZyIsImltYWdlOTM5LnBuZyIsImltYWdlOTQwLnBuZyIsImltYWdlOTQxLnBuZyIsImltYWdlOTQyLnBuZyIsImltYWdlOTQzLnBuZyIsImltYWdlOTQ0LnBuZyIsImltYWdlOTQ1LnBuZyIsImltYWdlOTQ2LnBuZyIsImltYWdlOTQ3LnBuZyIsImltYWdlOTQ4LnBuZyIsImltYWdlOTQ5LnBuZyIsImltYWdlOTUwLnBuZyIsImltYWdlOTUxLnBuZyIsImltYWdlOTUyLnBuZyIsImltYWdlOTUzLnBuZyIsImltYWdlOTU0LnBuZyIsImltYWdlOTU1LnBuZyIsImltYWdlOTU2LnBuZyIsImltYWdlOTU3LnBuZyIsImltYWdlOTU4LnBuZyIsImltYWdlOTU5LnBuZyIsImltYWdlOTYwLnBuZyIsImltYWdlOTYxLnBuZyIsImltYWdlOTYyLnBuZyIsImltYWdlOTYzLnBuZyIsImltYWdlOTY0LnBuZyIsImltYWdlOTY1LnBuZyIsImltYWdlOTY2LnBuZyIsImltYWdlOTY3LnBuZyIsImltYWdlOTY4LnBuZyIsImltYWdlOTY5LnBuZyIsImltYWdlOTcwLnBuZyIsImltYWdlOTcxLnBuZyIsImltYWdlOTcyLnBuZyIsImltYWdlOTczLnBuZyIsImltYWdlOTc0LnBuZyIsImltYWdlOTc1LnBuZyIsImltYWdlOTc2LnBuZyIsImltYWdlOTc3LnBuZyIsImltYWdlOTc4LnBuZyIsImltYWdlOTc5LnBuZyIsImltYWdlOTgwLnBuZyIsImltYWdlOTgxLnBuZyIsImltYWdlOTgyLnBuZyIsImltYWdlOTgzLnBuZyIsImltYWdlOTg0LnBuZyIsImltYWdlOTg1LnBuZyIsImltYWdlOTg2LnBuZyIsImltYWdlOTg3LnBuZyIsImltYWdlOTg4LnBuZyIsImltYWdlOTg5LnBuZyIsImltYWdlOTkwLnBuZyIsImltYWdlOTkxLnBuZyIsImltYWdlOTkyLnBuZyIsImltYWdlOTkzLnBuZyIsImltYWdlOTk0LnBuZyIsImltYWdlOTk1LnBuZyIsImltYWdlOTk2LnBuZyIsImltYWdlOTk3LnBuZyIsImltYWdlOTk4LnBuZyIsImltYWdlOTk5LnBuZyJdLCJpYXQiOjE1MTYyMzkwMjJ9.KGrocKdxHn_ZCkgfl5SAbKxCm8tbqVOBslU_x3SrYAg"><u>access to 1000 files</u></a>, the JWT length changes from 239 characters to 20,057 (and that’s considering a simple file name). With the full path, it’s even longer.</p><h3>OAuth2 Scopes are Static</h3><p>OAuth2 does not account for changes in access requirements over time. Once a client application is granted a scope, it retains that scope until it is revoked. This can become a problem when access requirements change and the same scope is no longer sufficient. For example, if an application adds a new feature that requires more granular access control, it may be challenging to implement this change without breaking backward compatibility. In such cases, developers may need to create new scopes, which can be confusing for users and may lead to scope proliferation.</p><h3>OAuth2 Scopes Don’t Consider Context</h3><p>Different resources in an application may require different levels of access depending on the context. For instance, a user may have read-only access to some resources but require write access to others. Scopes do not account for such context-specific access requirements, which can lead to over-privileging or under-privileging users.</p><h3>OAuth2 Scopes Don’t Support Complex Policies</h3><p>Access control policies often involve complex logic, such as <a title="https://www.permit.io/blog/rbac-with-permit" href="https://www.permit.io/blog/rbac-with-permit"><u>role-based access control (RBAC) </u></a>or <a title="https://www.permit.io/blog/what-is-abac" href="https://www.permit.io/blog/what-is-abac"><u>attribute-based access control (ABAC)</u></a>. OAuth2 scopes are not designed to support such complex policies, which can lead to significant security vulnerabilities.</p><h2>The solution? Implement Dynamic Authorization</h2><p>In conclusion, OAuth2 scopes are a limited authorization mechanism that can pose security risks when used as the sole basis for making authorization decisions. Developers should consider more robust authorization mechanisms, such as RBAC or ABAC, to provide fine-grained control over access to resources and allow them to define complex access control policies. By adopting these mechanisms, developers can ensure that their applications are more secure and better suited to meet their users&#39; evolving access control requirements.</p><h2>Scalable Permission Management</h2><p>Authorization requirements tend to grow exponentially along with the application. As various requirements from customers, security, compliance, and 3rd party integrations come in, you might end up refactoring your entire authorization system every 3-6 months. </p><p>Setting up (Not to mention maintaining) a system as complex as ABAC could take months of complex R&amp;D work and steep learning curves.</p><p>For that exact purpose, Permit provides developers with a permission management solution that allows for easy implementation and can be managed using an accessible no-code UI. </p><p>Permit’s UI generates Rego code for both <a title="https://www.permit.io/blog/implement-rbac-using-opa" href="https://www.permit.io/blog/implement-rbac-using-opa"><u>RBAC</u></a> and <a title="https://www.permit.io/blog/implement-abac-using-opa" href="https://www.permit.io/blog/implement-abac-using-opa"><u>ABAC</u></a> (See links for code examples), wrapping it nicely into Git, and API / UI interfaces which you can edit, add to, and manage however you like.</p><p>This allows both developers and other stakeholders to set up RBAC policies and add complex attributes and conditions - all without having to write a single line of code. </p><p>Want to learn more about Authorization? Join our <a title="https://io.permit.io/permitslack" href="https://io.permit.io/permitslack"><u>Slack community</u></a>, where there are hundreds of devs building and implementing authorization.</p>]]></content>
        <author>
            <name>Daniel Bass</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Broken Access Control: The CISO Perspective]]></title>
        <id>broken-access-control-the-ciso-perspective</id>
        <link href="https://www.permit.io/blog/broken-access-control-the-ciso-perspective"/>
        <updated>2023-04-17T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Preventing broken access control vulnerabilities: a CISO's perspective on the components and importance of proper permission management for cloud-native apps.]]></summary>
        <content type="html"><![CDATA[<p>The <a title="https://owasp.org/www-project-top-ten/" href="https://owasp.org/www-project-top-ten/"><u>OWASP Top 10</u></a> is a formidable list of security threats that strikes fear into the hearts of CISOs and security professionals alike. Among these vulnerabilities, one, in particular, is a cause for serious concern: <strong>broken access control</strong>. This vulnerability sits at the number one spot of the OWASP Top 10 <a title="https://www.permit.io/blog/owasp-2023" href="https://www.permit.io/blog/owasp-2023">for good reason</a>. The potential consequences of a breach are dire and far-reaching, ranging from data exfiltration to the execution of a successful ransomware attack.</p><h2>A Strategic perspective</h2><p>When it comes to dealing with broken access control, CISOs take a strategic rather than a tactical approach. They rely on their security team to establish and enforce access control standards. To do this, the security team dissects the components of access control, assesses their interplay, and identifies potential failure points. This method enables the team to establish a solid baseline and concentrate their efforts effectively, in cooperation with other teams in the organization.</p><p>The components of access control that a CISO should be primarily focused on are <strong>authentication</strong>, <strong>permissions</strong>, and <strong>session management</strong>. The lack of control over any one of these can result in broken access control.</p><h2>The Backbone - Permissions</h2><p>Permissions are the backbone of access control. Permissions play a crucial role in securely handling application requests in cloud-native apps. They provide a mechanism to control access to sensitive data and functionality, ensuring that only authorized users or systems can perform certain actions. With cloud-native applications, there are often multiple services and resources that need to communicate with each other, making it important to have a clear understanding of permissions and authorization. Properly implementing and managing permissions can help prevent unauthorized access, data breaches, and other security incidents that can harm both the organization and its customers.</p><h2>Least privilege</h2><p>The principle of least privilege is one of the cornerstones of information security. All forms of access should be configured with the least possible access to accomplish the goals provided by that access. If you’re building an eCommerce site, visitors to the site shouldn’t be admins. If you’re provisioning a cloud environment, every developer should not have unfettered access to the entire environment.</p><h2>Implement an authorization model</h2><p>One way to accomplish permissions control is through an authorization model, such as <a title="https://www.permit.io/blog/rbac-with-permit" href="https://www.permit.io/blog/rbac-with-permit"><u>role-based access control</u></a>, <a title="https://www.permit.io/blog/what-is-abac" href="https://www.permit.io/blog/what-is-abac"><u>attribute-based access control</u></a>, or relationship-based access control. <a title="https://www.permit.io/blog/rbac-vs-abac" href="https://www.permit.io/blog/rbac-vs-abac"><u>Deciding which model to choose</u></a> depends on the prominence of attributes or roles for specific needs. Whichever is chosen should enforce both vertical and horizontal controls and ensure that movement outside of vertical and horizontal access permissions is respected. It also should <a title="https://www.permit.io/blog/four-mistakes-you-make-when-building-permissions#2-mixing-up-app-logic-and-authorization" href="https://www.permit.io/blog/four-mistakes-you-make-when-building-permissions#2-mixing-up-app-logic-and-authorization"><u>never result in hardcoding entitlement logic in applications</u></a>.</p><h2>Session management</h2><p>Session management is about enforcing and constraining desired behavior. If someone can navigate to a restricted webpage from a public page, traverse environment levels when they shouldn’t be able to, or delete or encrypt large swaths of data in an environment, then appropriate session management is lacking.</p><h2>A CISO&#39;s responsibility</h2><p>The responsibility of the CISO is to the organization and its customers’ information. They are tasked with developing conditions to nurture an environment conducive to maintaining the confidentiality, integrity, and availability of information. Broken access controls thwart that development. They provide an unknown and likely unmonitored avenue of threat ingress. Once in an environment, a threat actor can move laterally or vertically and wreak havoc. In a very real way, broken access controls fuel what is soon expected to be a multi-trillion-dollar-per-year ransomware threat industry.</p><p>Addressing broken access control vulnerabilities can be done in ways that fall short of enterprise-wide security-office defining projects. Blocking and tackling broken access control vulnerabilities is an option. However, if an organization has the appetite for taking on access control and identity governance projects, it can also benefit greatly from those. The security team can work with developers to ensure that permissions and authorization are properly implemented in applications. Developers play a crucial role in this process, and it&#39;s important to ensure that they have the necessary training and resources to implement a secure authorization layer. </p><h2>Build healthy CISO - Dev. Cooperation</h2><p>Creating a system that allows for healthy cooperation between developers and security can potentially be very challenging. At the end of the day, it&#39;s crucial to have an authorization management layer anyone in your organization can use in a secure way.</p><p>Normally, creating and managing your application’s authorization policies could only be done through complex R&amp;D work and steep learning curves. This creates a situation where developers become bottlenecks in your app’s permission management, other stakeholders are locked out of the conversation, and your customers are left without the flexibility they require. All of these manifest as an unending stream of feature requests.</p><p>The solution is implementing and managing your RBAC and ABAC policies with a simple no-code UI which makes permission management accessible to other stakeholders. </p><h2>That’s what Permit is here for</h2><p>Permit provides a permission management solution that makes policy-as-code as easy as checking a checkbox - generating the needed code for you, and wrapping it nicely into Git, and API / UI interfaces. This allows including all of the stakeholders in the permission management process, preventing developers from becoming bottlenecks.</p><p>Want to learn more about Authorization? Join our <a title="https://io.permit.io/permitslack" href="https://io.permit.io/permitslack"><u>Slack community</u></a>, where there are hundreds of devs building and implementing authorization.</p>]]></content>
        <author>
            <name>Daniel Bass</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Kubecon EU 2023 - Must Not Miss List]]></title>
        <id>kubecon-eu-2023</id>
        <link href="https://www.permit.io/blog/kubecon-eu-2023"/>
        <updated>2023-04-16T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Discover the top sessions at KubeCon EU, curated by Permit.io. Join the cloud-native community's brightest minds to learn about Kubernetes and Authorization.]]></summary>
        <content type="html"><![CDATA[<p>Welcome to the vibrant world of cloud-native computing! Permit.io is thrilled to be a sponsor of KubeCon EU, the flagship conference that brings together the brightest minds in the cloud-native community. We&#39;re excited to be a part of this amazing event and help attendees navigate the conference to get the most out of their experience.</p><p>At KubeCon EU, there&#39;s something for everyone, with a vast array of sessions covering different topics. We understand it can be overwhelming to choose which ones to attend. That&#39;s why we&#39;ve curated a list of must-see sessions for attendees interested in authorization and permissions. However, we guarantee that every session at KubeCon is worth attending, and this list is just our top picks we want to visit in real-time during the conference.</p><p>From developers to DevOps professionals and decision-makers, KubeCon EU has something for everyone. Let’s get ready to take our skills to the next level and make the most out of our KubeCon EU experience. Let&#39;s dive in!</p><h2>The First Day</h2><p>Welcome to the first day of KubeCon EU! As you make your way through the conference schedule, we have some must-attend sessions that will boost you up into a conference full of fun.</p><img src="https://media.graphassets.com/qfQTvFUmRGKZQaWR8f3A" alt="photo-1605101100278-5d1deb2b6498.jpg" title="photo-1605101100278-5d1deb2b6498.jpg" width="1000" height="667" /><p>First up, don&#39;t miss the Keynote “<a title="https://sched.co/1HyPW" href="https://sched.co/1HyPW"><u>Cappucci-Know</u></a>”, where leading end users across the European Union will share their insights and success stories with cloud native technologies. This session will dive into overcoming challenges, navigating regulations, and fostering collaboration within the EU’s cloud native ecosystem.</p><p>Next, join Jim Bugwadia and Frank Jogeleit for &quot;<a title="https://sched.co/1HzcK" href="https://sched.co/1HzcK"><u>Policy Matters!</u></a>&quot; as they provide an overview of the Policy Working Group&#39;s projects, deliverables, and activities. They will also deep dive into the Policy Report API, which is being proposed as a standard by the Policy WG to unify policy observability across different areas of Kubernetes security and automation. This is an opportunity to learn, contribute, and share in the areas of policy, governance, and compliance!</p><p>Feeling adventurous? Join Whitney Lee and Viktor Farcic on a &quot;<a title="https://sched.co/1HyWm" href="https://sched.co/1HyWm"><u>Treacherous Trek to Developmen</u></a>t&quot; in a Choose Your Own Adventure-style talk. Help guide our hero application as it makes cascading choices in container build strategy, image registries, application configuration, database management, and more. This interactive session will keep you on your toes and demonstrate Kubernetes-native development in action.</p><p>For those interested in security, join Cailyn Edwards for &quot;<a title="https://sched.co/1HyQ9" href="https://sched.co/1HyQ9"><u>Canals and Bridges</u></a>: Using Amsterdam&#39;s Transit System to Secure K8s Networks.&quot; This talk uses Amsterdam&#39;s intricate network of canals and bridges to visualize the benefits and challenges of securing a Kubernetes network. Edwards will share methods for planning and implementing a strong security strategy, useful network monitoring tools, and ways to make the most of NetworkPolicies.</p><p>Finally, join Jimmy Mesta for &quot;<a title="https://sched.co/1HyQC" href="https://sched.co/1HyQC"><u>RBAC to the Future: Untangling Authorization in Kubernetes.</u></a>&quot; This session will cover the essential pillars of designing an effective, least permissive RBAC strategy for the enterprise. Attendees will gain a better understanding of RBAC&#39;s inner workings, explore some lesser-known RBAC gotchas, and learn how to build and monitor least privilege RBAC configurations within Kubernetes.</p><p>With these sessions, you&#39;ll be well on your way to a productive and exciting first day at KubeCon EU. Don&#39;t forget to stop by <a title="https://www.permit.io/" href="https://www.permit.io/"><u>Permit.io</u></a>&#39;s booth at the KubeKrawl party to grab a drink and say hello!</p><h2>The Second Day</h2><p>Welcome back to the second day of the KubeCon EU! Today, we have an exciting lineup of sessions that are sure to blow your mind ;)</p><p>First up, we have &quot;<a title="https://sched.co/1HyWj" href="https://sched.co/1HyWj"><u>Back to the Future: Next-Generation Cloud Native Security</u></a>&quot; by Matt Jarvis from Snyk and Andrew Martin from Control Plane. Security is an ever-evolving challenge, and this talk promises to explore what security might look like in the cloud ecosystem of the future. We&#39;ll examine how emerging technologies like hardware, cryptography, architecture, and software development patterns will impact security. This talk is a great fit for those who value innovation and staying ahead of the curve.</p><p>Next, we have &quot;<a title="https://sched.co/1Hyb8" href="https://sched.co/1Hyb8"><u>Telepresence Case Studies: From First Experience to Fast Feedback at Scale</u></a>&quot; by Edidiong Asikpo from Ambassador Labs. If you&#39;re struggling with testing and debugging your microservice-based application in a remote Kubernetes environment, this session is for you. Edidiong will showcase how adopting the open-source CNCF tool Telepresence can improve your developer experience, accelerate your inner dev loop, and reduce staging environment compute costs. This session is perfect for those who value productivity and optimizing developer workflows.</p><p>Following that, we have &quot;<a title="https://sched.co/1JhXq" href="https://sched.co/1JhXq"><u>Building a Successful Business in Cloud Native</u></a>&quot; by a panel of practitioners and entrepreneurs: Liz Rice from Isovalent, Guillermo Rauch from Vercel, Kelsey Hightower from Google, Sheng Liang from Acorn Labs, and Tom Manville from Kasten by Veeam. This panel discussion will focus on how start-ups and smaller vendors can thrive within the cloud native ecosystem. We&#39;ll explore the role of open-source projects and how vendors can make their products appeal to a community centered around open source. If you&#39;re interested in the business side of cloud native technologies, this is a session you won&#39;t want to miss.</p><p>For those who are interested in security, we have &quot;<a title="https://sched.co/1HyQp" href="https://sched.co/1HyQp"><u>Guardians of the Runtime: Leveraging Behavioral Analysis and Policies</u></a>&quot; by Ben Hirschberg from ARMO. This talk will delve into an innovative approach to securing Kubernetes clusters using behavior analysis during continuous integration testing and generating native policies based on behavior. You&#39;ll learn how to integrate behavioral analysis into CI testing and how to use native policies to enforce security policies within Kubernetes. This session is perfect for those who value security and staying up to date with the latest threats.</p><p>Lastly, we have a special treat: the world premiere of &quot;<a title="https://sched.co/1JOba" href="https://sched.co/1JOba"><u>Inside Envoy - The Proxy for the Future</u></a>&quot; , a documentary film screening. Join us for a captivating behind-the-scenes look at the origins and rapid ascent of one of the most significant open-source projects in the community today: Envoy. You&#39;ll witness firsthand how the project emerged as an in-house solution within ride-share giant Lyft, before rapidly evolving into an innovation that has defined the careers of those who helped create a proxy that fundamentally transformed the industry. This session is perfect for those who value the history and evolution of open-source projects.</p><p></p><iframe
          width="560"
          height="315"
          frameBorder="0"
          allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
          allowFullScreen
          title="https://www.youtube.com/embed/sQVeuFYvzIk"
          src="https://www.youtube.com/embed/sQVeuFYvzIk"
        ></iframe><h2>The Third Day</h2><p>On the third day of KubeCon EU, we have some sessions that we highly recommend attending! <a title="https://sched.co/1HyRG" href="https://sched.co/1HyRG"><u>The keynote by Aparna Subramanian</u></a>, Director of Production Engineering at Shopify, will tackle the question that&#39;s been on everyone&#39;s minds: Is Kubernetes Delivering on its Promise? Get candid insights from end-users on the value they have derived from this ubiquitous technology and the strategies that they use to make the most out of it.</p><p>Another must-attend session is by Rich Burroughs, host of the Kube Cuddle Podcast, and Kaslin Fields, co-host of the Kubernetes Podcast from Google, where they will share their experiences and lessons learned from the cloud-native ecosystem&#39;s experts. In <a title="https://sched.co/1Hyc6" href="https://sched.co/1Hyc6"><u>Build Your Own Path in the Cloud Native Ecosystem</u></a>, you&#39;ll walk away with a foundation of knowledge to help you understand Kubernetes&#39; history, the contributor community, and the value of working with the Cloud Native Ecosystem.</p><p>Are you considering or already using GitOps? Join a <a title="https://sched.co/1HydD" href="https://sched.co/1HydD"><u>panel of GitOps project experts</u></a>, including Priyanka Ravi from Weaveworks, Christian Hernandez from Red Hat, and others, to learn more about GitOps in How GitOps Changed Our Lives &amp; Can Change Yours Too! You&#39;ll hear about the usability and complexity issues that come with different tools/solutions and the pain points, struggles, adoption barriers, lessons learned, first-hand benefits, and how it&#39;s changed the way they work.</p><p>In <a title="https://sched.co/1HyUS" href="https://sched.co/1HyUS"><u>Securing the Container Supply Chain with Notary</u></a>, Justin Cormack from Docker and Toddy Mladenov from Microsoft will give an overview of the Notary project tooling&#39;s new capabilities and its role in the broader software supply chain ecosystem. They will cover the core functionalities included in the Notary v2 release, typical scenarios that can be applied, and integrations with other ecosystem tools.</p><p>Lastly, join Keptn maintainers for an introduction to the Keptn project and how it set sail to be an incubating Kubernetes-native delivery tool. In <a title="https://sched.co/1HyTy" href="https://sched.co/1HyTy"><u>Navigating the Delivery Lifecycle with Keptn</u></a>, you&#39;ll learn about the Keptn Lifecycle Toolkit, a new sub-project that promises to support users with pipeline-less delivery integrated seamlessly into your GitOps toolchain while bringing observability into your application lifecycle. The session will also cover the latest and greatest features with a roadmap for what&#39;s next and provide information on how you can get involved as an end-user or contributor to help us with feedback on the project&#39;s future direction. Don&#39;t miss these exciting sessions and get ready to level up your knowledge and skills!</p><img src="https://media.graphassets.com/lR2dX5OQTOXUpYchuUJg" alt="gemanor_a_leader_of_a_navy_ship_ride_a_food_delivery_scooter_pi_86d6c245-3fd4-4bc6-aae3-8b23065afce0.png" title="gemanor_a_leader_of_a_navy_ship_ride_a_food_delivery_scooter_pi_86d6c245-3fd4-4bc6-aae3-8b23065afce0.png" width="1232" height="928" /><h2>TL;DR</h2><table><tbody><tr><td><p>Keynote: Cappucci-Know: Percolating EU End User Insights in the Cloud Native Café - Moderated by Taylor Dolezal</p><p>Hall 12 | First Floor | Holland Complex</p><p>Speakers: Yuichi Nakamura, Sergiu Petean, Kasper Borg Nissen, Taylor Dolezal, Sabine Wolz</p></td></tr><tr><td><p>Policy Matters! A Policy Working Group Introduction and Deep Dive - Jim Bugwadia, Nirmata &amp; Frank Jogeleit, LOVOO</p><p>G109 | First Floor | Congress Centre</p><p>Speakers: Jim Bugwadia, Frank Jogeleit</p></td></tr><tr><td><p>Choose Your Own Adventure: The Treacherous Trek to Development - Whitney Lee, VMware &amp; Viktor Farcic, Upbound</p><p>Hall 7, Room A | Ground Floor | Europe Complex</p><p>Speakers: Viktor Farcic, Whitney Lee</p></td></tr><tr><td><p>🦝 Canals and Bridges: Using Amsterdam’s Transit System To Secure K8s Networks - Cailyn Edwards, Shopify</p><p>Emerald Room | First Floor | Congress Centre</p><p>Speakers: Cailyn Edwards</p></td></tr><tr><td><p>🦝 RBAC to the Future: Untangling Authorization in Kubernetes - Jimmy Mesta, KSOC</p><p>Emerald Room | First Floor | Congress Centre</p><p>Speakers: Jimmy Mesta</p></td></tr><tr><td><p>Back to the Future: Next-Generation Cloud Native Security - Matt Jarvis, Snyk &amp; Andrew Martin, Control Plane</p><p>Emerald Room | First Floor | Congress Centre</p><p>Speakers: Matt Jarvis, Andrew Martin</p></td></tr><tr><td><p>Telepresence Case Studies: From First Experience to Fast Feedback at Scale - Edidiong Asikpo, Ambassador Labs</p><p>Hall 7, Room C | Ground Floor | Europe Complex</p><p>Speakers: Edidiong Asikpo</p></td></tr><tr><td><p>Building a Successful Business in Cloud Native - Liz Rice, Isovalent; Guillermo Rauch, Vercel; Kelsey Hightower, Google; Sheng Liang, Acorn Labs; Tom Manville, Kasten by Veeam</p><p>Hall 7, Room B | Ground Floor | Europe Complex</p><p>Speakers: Liz Rice, Kelsey Hightower, Sheng Liang, Tom Manville, Guillermo Rauch</p></td></tr><tr><td><p>🦝 Guardians of the Runtime: Leveraging Behavioral Analysis and Policies - Ben Hirschberg, ARMO</p><p>Emerald Room | First Floor | Congress Centre</p><p>Speakers: Ben Hirschberg</p></td></tr><tr><td><p>Documentary Film Screening: Inside Envoy - The Proxy for the Future</p><p>Forum | Ground Floor | Congress Centre</p><p>Speakers: Chad Torbin</p></td></tr><tr><td><p>Keynote: Is Kubernetes Delivering on its Promise? A Platform Engineering Perspective - Aparna Subramanian, Director of Production Engineering, Shopify</p><p>Hall 12 | First Floor | Holland Complex</p><p>Speakers: Aparna Subramanian</p></td></tr><tr><td><p>Navigating the Delivery Lifecycle with Keptn - Giovanni Liva, Dynatrace; Ana Margarita Medina, Lightstep; Brad McCoy, Basiq; Meha Bhalodiya, Red Hat</p><p>E103-104 | First Floor | Congress Centre</p><p>Speakers: Ana Medina, Brad McCoy, Meha Bhalodiya, Giovanni Liva</p></td></tr><tr><td><p>Build Your Own Path in the Cloud Native Ecosystem - Rich Burroughs, Loft Labs &amp; Kaslin Fields, Google</p><p>D201-202 | Second Floor | Congress Centre (Elicium Building)</p><p>Speakers: Rich Burroughs, Kaslin Fields</p></td></tr><tr><td><p>Securing the Container Supply Chain with Notary - Justin Cormack, Docker &amp; Toddy Mladenov, Microsoft</p><p>E107-108 | First Floor | Congress Centre</p><p>Speakers: Justin Cormack, Toddy Mladenov</p></td></tr><tr><td><p>How GitOps Changed Our Lives &amp; Can Change Yours Too! - Priyanka Ravi, Weaveworks; Christian Hernandez, Red Hat; Filip Jansson, Strålfors; Roberth Strand, Amesto Fortytwo; Leigh Capili, VMware</p><p>G104-105 | First Floor | Congress Centre</p><p>Speakers: Christian Hernandez, Priyanka Pinky Ravi, Leigh Capili, Roberth Strand, Filip Jansson</p></td></tr></tbody></table><h2>Join us at KubeCon EU!</h2><p>We hope you find these session recommendations valuable and that you enjoy the rest of the conference. At permit.io, we are committed to supporting the open source community and initiatives, and we believe that attending events like KubeCon Europe is crucial to staying up-to-date with the latest technologies and trends. If you want to learn more about our open source projects or how we can help you with your Kubernetes deployments, please visit our booth or contact us directly. Thank you for your participation and support, and we hope to see you again at future events!</p>]]></content>
        <author>
            <name>Gabriel L. Manor</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[5 steps to building NSA-level access control for your app]]></title>
        <id>nsa</id>
        <link href="https://www.permit.io/blog/nsa"/>
        <updated>2023-04-16T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Access Control is a main concern when developing web applications - and the NSA has a lot to say about it, especially the biggest pitfall developers make. ]]></summary>
        <content type="html"><![CDATA[<p>Access Control has become a main concern when it comes to developing secure web applications, and the NSA has a lot to say about it. Especially when it comes to<strong> the biggest access management pitfall</strong> developers make. </p><p>In 2021 OWASP <a title="https://owasp.org/Top10/A01_2021-Broken_Access_Control/" href="https://owasp.org/Top10/A01_2021-Broken_Access_Control/"><u>listed ‘Broken Access Control’ as their A01 item</u></a> on the list of Top 10 Web Application Security Risks. The <a title="https://www.verizon.com/business/resources/reports/dbir/" href="https://www.verizon.com/business/resources/reports/dbir/"><u>2020 Verizon Data Breach Investigations Report</u></a> states that “At least two-thirds of cyberattacks are now focused on impersonating trusted users and systems to access vital data or critical systems.”</p><p>To help address these concerns, the United States <strong>National Security Agency (NSA)</strong> has issued a cybersecurity information sheet (CSI) titled “<a title="https://media.defense.gov/2023/Mar/14/2003178390/-1/-1/0/CSI_ZERO%20TRUST%20USER%20PILLAR.PDF" href="https://media.defense.gov/2023/Mar/14/2003178390/-1/-1/0/CSI_ZERO%20TRUST%20USER%20PILLAR.PDF"><u>Advancing Zero Trust Maturity Throughout the User Pillar</u></a>”. </p><p>The goal of the CSI is to provide recommendations for strengthening <strong>Identity</strong>, <strong>Credential</strong>, and <strong>Access Management </strong>(ICAM) capabilities to mitigate such cyberattacks effectively. It further discusses how these capabilities can be integrated into a comprehensive Zero Trust framework. </p><p>These <strong>battle-tested best practices</strong> are a goldmine of knowledge for every developer. </p><p>Developing secure systems is a challenge for every developer, especially for those dealing with matters of national security. These developers handle the most sophisticated cyber threats on a daily basis. To truly excel as developers, we must learn from them, and strive to enhance our knowledge and skills. Only then can we ensure that the systems we build are robust, resilient, and reliable.</p><p>In this blog, we will focus and elaborate on the best practices offered by the NSA for building secure access management, and how they can be implemented <strong>at the application level</strong>. To boil it down, these are the five most important steps:</p><ol><li><div><p>Adopt a Zero-Trust mindset and design</p></div></li><li><div><p>The User Pillar focus</p></div></li><li><div><p>Access Management</p></div></li><li><div><p>Event Driven ABAC</p></div></li><li><div><p>Accessible Access Control</p></div></li></ol><h2>Introduction: Zero-Trust, the User Pillar, and Access Management</h2><p>Let’s start with some context - The CSI provides recommendations for strengthening the identity, credential, and access management capabilities of your organization, and how these can be integrated into a <strong>Zero</strong> <strong>Trust</strong> network. The CSI explains Zero Trust architecture as being made up of <strong>seven pillars</strong>, one of them being the <strong>User Pillar</strong>. We&#39;re not going to dive into the depth of each of those concepts, but we’ll do a quick overview of them.</p><h3>What is Zero Trust?</h3><p>The Zero Trust security model is an approach to cybersecurity that requires strict identity verification for every person and device trying to access a network, application, or data. The model <strong>assumes that all users, devices, and networks are potential security risks</strong> and, therefore, limits access to only the necessary resources and data for each user. </p><p>The NSA encourages the implementation of a Zero-Trust model to reduce the risk of data breaches, insider threats, and cyber attacks by limiting access to sensitive information and resources to only users who have the proper <a title="https://www.permit.io/blog/authn-vs-authz" href="https://www.permit.io/blog/authn-vs-authz"><u>authentication and authorization</u></a>, and constantly monitoring and verifying their identities and behavior. </p><p>Some common techniques used in zero-trust security models include <strong>multi-factor authentication</strong>, <strong>granular access controls</strong>, <strong>network segmentation</strong>, and continuous <strong>monitoring</strong> of user activity.</p><p>In a zero-trust model, <strong>access control</strong> decisions are based on a number of factors, including the user&#39;s identity, the device being used, the user&#39;s location, and the sensitivity of the data or resource being accessed. These factors are evaluated in real-time, and access is only granted if all of the criteria are met. We will dive deeper into this in a moment. </p><h3>The Seven Pillars of Zero Trust</h3><p>The<a title="https://media.defense.gov/2021/Feb/25/2002588479/-1/-1/-/CSI_EMBRACING_ZT_SECURITY_MODEL_UOO115131-21.pdf" href="https://media.defense.gov/2021/Feb/25/2002588479/-1/-1/-/CSI_EMBRACING_ZT_SECURITY_MODEL_UOO115131-21.pdf"><u> implementation of a zero-trust model</u></a> requires integrating every system with the controls defined for each of the <strong>Seven Pillars of Zero Trust:</strong></p><ul><li><div><p><strong>User:</strong> Continuously authenticate and authorize resource access.  </p></div></li><li><div><p><strong>Device:</strong> Be aware of device health and status, and maintain real-time inspection, assessment, and patching.</p></div></li><li><div><p><strong>Data:</strong> Data transparency and visibility are enabled and secured by enterprise infrastructure, applications, standards, robust end-to-end encryption, and data tagging.</p></div></li><li><div><p><strong>Application/Workload:</strong> Secure everything from applications to hypervisors, including containers and virtual machines.</p></div></li><li><div><p><strong>Network/Environment:</strong> Segment, isolate, and control (physically and logically) the network environment with granular policy and access controls.</p></div></li><li><div><p><strong>Visibility &amp; Analytics:</strong> Analyze events, activities, and behaviors to achieve a model that improves detection and reaction time when making access decisions.</p></div></li><li><div><p><strong>Automation &amp; Orchestration</strong> - Automate security responses based on defined processes and security policies.</p></div></li></ul><p>The CSI goes on to elaborate on each of the seven pillars of zero trust. In this blog, we will focus on the <strong>User Pillar</strong>, which deals with managing user access in a dynamic risk environment. </p><h3>Adopting a Zero Trust mindset</h3><p>Zero Trust isn’t a patch you can simply apply to an existing solution - it&#39;s a security-by-design principle. In <a title="https://www.permit.io/" href="https://www.permit.io/"><u>Permit</u></a>, for instance, we had to achieve a zero trust model to provide our SaaS authorization solution. </p><p>We designed our architecture to be <a title="https://docs.permit.io/concepts/control-plane-and-data-plane" href="https://docs.permit.io/concepts/control-plane-and-data-plane"><u>split into two parts</u></a> - the <strong>control plane</strong> and the <strong>data plane</strong>. The control plane through which our clients manage their authorization is hosted in our cloud solution, yet our client’s <strong>data is never exposed to us</strong> and<strong> remains hosted on their side</strong>. </p><p>This way, our clients can fully utilize our SaaS service <strong>without exposing any data, security, or performance factors</strong> to it.</p><h3>The User Pillar </h3><p>The user pillar is an expansion of the <a title="https://playbooks.idmanagement.gov/arch/" href="https://playbooks.idmanagement.gov/arch/"><u>FICAM framework</u></a>, which consists of several parts: </p><ul><li><div><p><strong>Identity Management: </strong>Creation, maintenance, and verification of digital identities.</p></div></li><li><div><p><strong>Credential management: </strong>Issuing, revoking, and managing digital credentials that verify an individual&#39;s identity, such as smart cards, tokens, and digital certificates.</p></div></li><li><div><p><strong>Access Management: </strong>Authorizing and controlling access to resources based on a user&#39;s identity and permissions, enforcing policies and controls to manage access to those resources.</p></div></li><li><div><p><strong>Federation: </strong>Sharing identity and access information between different organizations or systems to enable cross-organizational collaboration and resource sharing.</p></div></li><li><div><p><strong>Governance: </strong>Establishing policies, procedures, and controls to ensure compliance with laws, regulations, and industry standards.</p></div></li></ul><p>You can learn more about the seven pillars of zero trust and their aspects in the full CSI <a title="https://media.defense.gov/2023/Mar/14/2003178390/-1/-1/0/CSI_ZERO%20TRUST%20USER%20PILLAR.PDF" href="https://media.defense.gov/2023/Mar/14/2003178390/-1/-1/0/CSI_ZERO%20TRUST%20USER%20PILLAR.PDF"><u>available here</u></a>. In this blog, we’ll focus on<strong> Access Management</strong>.</p><h2>Access Management</h2><p>Access Management is all about making sure that only the right <strong>people </strong>(authenticated users or entities) can perform the right <strong>actions </strong>on the right <strong>resources</strong>. </p><p>Access control frameworks provide access decisions at various levels of granularity, with more advanced systems being able to support a higher level of granularity. </p><h3>The Biggest Access Management Pitfall</h3><p>There are many ways of implementing these access controls. Many implementations use single sign-on (SSO) solutions that validate a user’s credentials, assign them with specific properties (Like roles), and then manage access based on the privileges of those properties. </p><p>These solutions tend to use broad, static, role-based access (RBAC) rules governing access to all resources on a system. <a title="https://www.permit.io/blog/rbac-vs-abac" href="https://www.permit.io/blog/rbac-vs-abac"><u><strong>But that’s not enough</strong></u></a><strong>.</strong> </p><p>Access control mechanisms should consider granularity, reliability, availability, and potential risks to the resource. A solution based on authentication and simple RBAC (or even worse - an Admin / Non-Admin system) <strong>lacks crucial flexibility and granularity </strong>to properly handle<strong> not only sensitive data but also the requirements of almost any modern application.</strong> </p><p>In the context of the NSA, granting access to resources based on roles given to users (even if they are authenticated) is out of the question. Attributes such as classification, clearance, geolocation, time of access, and many others are crucial for their systems to remain secure. <strong>The need for attributes is not limited to highly sensitive government organizations:</strong></p><p>Consider this access policy example - </p><p>Only authenticated users who have an <strong>active paid subscription</strong> and are <strong>located in the EU</strong> can access a specific part of your application. </p><p>That’s a type of policy you probably encounter every day in almost every modern app. Not only it requires <strong>multiple attributes</strong> for both the users and resources, but also the ability to be <strong>updated instantaneously in real-time</strong>.</p><h2>The solution? Battle-tested Best Practices</h2><p>The NSA CSI offers a few best practices when it comes to creating a granular, reliable, and flexible access control layer. The best practices emphasize, first and foremost, the use of an <a title="https://www.permit.io/blog/what-is-abac" href="https://www.permit.io/blog/what-is-abac"><u>Attribute-based access control (ABAC) model</u></a>, which provides the required flexibility to meet our access management goals.</p><ul><li><div><strong>Implement an ABAC-based model</strong><br>ABAC is an authorization model that determines access based on <strong>conditional attributes</strong>. This model allows for highly granular policy creation, with the ability to factor in a great number of variables for deciding on a user’s range of access. According to the CSI, it is one of the most basic prerequisites to building secure access management. </div></li><li><div><strong>Where to start? Map your application&#39;s access control </strong><br>One of the first and most basic steps in enhancing your access control is mapping out your application’s requirements to determine what user and resource attributes it requires. A “Comprehensive inventory and characterization of users, resources, and the users’ ability to protect the data” is the first step required to know how exactly your application’s access control should be designed.</div></li><li><div><strong>Should I move to ABAC completely? </strong><br>Implementing ABAC doesn’t mean we have to shift from using RBAC completely - RBAC and ABAC can be used together hierarchically, with broad access enforced by RBAC protocols and more complex access managed by ABAC.</div></li><li><div><strong>Build a flexible system<br></strong>Implementing and maintaining authorization can in itself be quite challenging. Creating a structure that allows you to switch from one model to another or use them together is even more complicated. The best solution is to use an <a title="https://www.permit.io/blog/choose-an-authz-service" href="https://www.permit.io/blog/choose-an-authz-service"><u>authorization solution</u></a> that allows for this flexibility. </div></li><li><div><strong>Create a separate microservice for authorization</strong><br>It is highly recommended to create a “centralized management interface for assigning fine-grained privileges”. Each service in your application will have to be configured with its own set of policies manually. This can be quite a time-consuming, and, more importantly - unsafe process. As the number of policies, users, and services grows, updating the policies in each relevant service will become tedious, time-consuming, and a huge source of potential error. On the same topic - </div></li><li><div><strong>Don’t mix application code with authorization logic</strong><br>Mixing the code of the authorization layer into the application code is <a title="https://www.permit.io/blog/5-best-practices-for-building-cloud-native-permissions#the-5-best-practices" href="https://www.permit.io/blog/5-best-practices-for-building-cloud-native-permissions#the-5-best-practices"><u><strong>a bad idea for several reasons</strong></u></a>. Each upgrade or added capability would require us to refactor large areas of code that only drift further from one another. <br><br>A solution that allows you to both create a separate microservice for authorization and decouple policy and code is <a title="https://www.permit.io/blog/introduction-to-opa" href="https://www.permit.io/blog/introduction-to-opa"><u>Open Policy Agent (OPA)</u></a>, which you can use to manage authorization in a separate service.</div></li><li><div><strong>Utilize event-driven authorization</strong><br>In addition to granular access rules, keeping your authorization layer up to date in real-time is a must for every modern application. <a title="https://github.com/permitio/opal" href="https://github.com/permitio/opal"><u>OPAL (Open Policy Administration Layer)</u></a>, for example, is an open-source project that makes OPA event-driven. This allows you to respond to policy and data changes instantly as they happen, push live updates to your agents, and bring open policy up to the speed needed by live applications.</div></li></ul><h2>Don&#39;t stop there - Make access control accessible</h2><p>“Attribute-based models require an authoritative source for attributes and processes for users to be provisioned with attributes”. While tools like OPA and OPAL allow us to unify all policies in one server, take on the role of policy decision-making and enforcement from the service, and manage policy as code, they lack one major capability: </p><p>Creating, managing, and enforcing ABAC policies <strong>in a way anyone in your organization can use</strong>. </p><p>Normally, creating and managing your application’s authorization layer only be done through complex R&amp;D work and steep learning curves. This creates a situation where developers become bottlenecks in your app’s permission management, while other stakeholders are locked out of the conversation, and your customers are left without the flexibility they require. This results in an unending flow of feature requests. <br><br>The answer is to provide <strong>human-oriented low-code interfaces</strong> that all relevant stakeholders, including end users, can use. This empowers developers to delegate some of the work without them becoming bottlenecks.<br><br>At Permit.io, we took on the accessibility challenge head-on, while being adamant about keeping the full power of policy-as-code.</p><p>Permit’s policy editor implements and manages your RBAC and ABAC policies with<a title="https://www.permit.io/blog/what-is-abac#permit-a-ui-for-managing-abac" href="https://www.permit.io/blog/what-is-abac#permit-a-ui-for-managing-abac"><u> a simple no-code UI</u></a> which makes permission management accessible to other stakeholders. </p><p><a title="https://www.permit.io/" href="https://www.permit.io/"><u>Permit</u></a> provides developers with a permission management solution that makes policy-as-code as easy as checking a checkbox - generating the needed code for you, and wrapping it nicely into Git, and API / UI interfaces. </p><h2>Never stop learning</h2><p>“Adoption of ZT principles is not accomplished overnight. Implementation is achieved through careful and deliberate planning and continuous incremental improvements”. <br><br>Want to learn more about Authorization and access control? Join Permit’s <a title="https://io.permit.io/permitslack" href="https://io.permit.io/permitslack"><u>Slack Community</u></a>, where world-class authorization specialists and hundreds of devs are discussing, building, and implementing authorization together. </p>]]></content>
        <author>
            <name>Daniel Bass</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Crafting Your Own Application: The 4 Essential Building Blocks]]></title>
        <id>crafting-your-own-application-the-4-essential-building-blocks</id>
        <link href="https://www.permit.io/blog/crafting-your-own-application-the-4-essential-building-blocks"/>
        <updated>2023-04-15T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Explore 4 app building blocks: Authentication, Authorization, Databases & Payments. Use existing solutions for faster development & user trust.]]></summary>
        <content type="html"><![CDATA[<p>TL;DR: When building an application, there are four essential building blocks to consider: <strong>Authentication</strong>, <strong>Authorization</strong>, <strong>Databases/Data Handling</strong>, and <strong>Payments</strong>. This blog will emphasize how to leverage existing solutions to accelerate development and provide recommendations for services in each category, including:</p><ul><li><div>⁠<a title="https://clerk.dev/" href="https://clerk.dev/"><u>Clerk.dev</u></a>, <a title="https://supertokens.com/" href="https://supertokens.com/"><u>SuperTokens</u></a>, and <a title="https://auth0.com/de" href="https://auth0.com/de"><u>Auth0</u></a> for authentication</div></li><li><div>⁠<a title="https://www.permit.io/" href="https://www.permit.io/"><u>Permit.io</u></a>, <a title="https://github.com/permitio/opal" href="https://github.com/permitio/opal"><u>OPAL</u></a>, and <a title="https://github.com/open-policy-agent/opa" href="https://github.com/open-policy-agent/opa"><u>OPA </u></a>for authorization</div></li><li><div>⁠<a title="https://planetscale.com/" href="https://planetscale.com/"><u>PlanetScale</u></a>, <a title="https://supabase.com/" href="https://supabase.com/"><u>Supabase</u></a>, and <a title="https://www.mongodb.com/de-de" href="https://www.mongodb.com/de-de"><u>MongoDB</u></a> for databases</div></li><li><div>⁠<a title="https://stripe.com/de" href="https://stripe.com/de"><u>Stripe</u></a>, <a title="https://www.paypal.com/de/home" href="https://www.paypal.com/de/home"><u>PayPal</u></a>, and <a title="https://squareup.com/us/en" href="https://squareup.com/us/en"><u>Square</u></a> for payments. </div></li></ul><p>⁠Prioritizing user trust, data security, and a seamless user experience ensures long-term success.</p><p>Creating an application from scratch can be an exhilarating experience that brings ideas to life. However, understanding the crucial components and how they work together is key to building a successful application. In this blog post, we’ll explore the four essential building blocks that make up an effective application: Authentication, Authorization, Databases/Data Handling, and Payments. <strong>You need them, but you don’t need to build them from scratch.</strong></p><p>In this blog, we will concentrate on leveraging existing solutions to significantly accelerate your application development process. Additionally, we will discuss some of the best options available to ensure a seamless and efficient experience.</p><h3><strong>Authentication</strong></h3><p>Authentication is the process of verifying a user&#39;s identity, usually by requiring them to provide a unique set of credentials (e.g., username and password). This is a critical aspect of any application, as it ensures that only authorized users can access the system. Here are some common authentication techniques:</p><ul><li><div><p><strong>Password-based authentication</strong>: Users enter their username and password, which is then compared to the stored credentials.</p></div></li><li><div><p><strong>Multi-factor authentication (MFA)</strong>: In addition to a password, users must provide a second form of identification, such as a code sent to their phone.</p></div></li><li><div><p><strong>Social logins</strong>: Users authenticate through a third-party service, such as Google or Facebook.</p></div></li><li><div><p><strong>Passwordless authentication</strong>: Users will receive a link via email or an OTP code to their mobile device, to confirm their identity.</p></div></li></ul><p>Implementing a secure authentication system is crucial for protecting user data and maintaining trust in your application. There are a few awesome services that allow you to do this:</p><ol><li><div><p><a title="https://clerk.dev/" href="https://clerk.dev/"><u><strong>Clerk.dev</strong></u></a><strong> </strong>— A user management platform that provides secure authentication, user profiles, and seamless integration with modern applications.</p></div></li><li><div><p><a title="https://supertokens.com/" href="https://supertokens.com/"><u><strong>SuperTokens</strong></u></a><strong> </strong>— An extensible and customizable authentication solution offering secure session management, social logins, and passwordless options.</p></div></li><li><div><p><a title="https://auth0.com/de" href="https://auth0.com/de"><u><strong>Auth0</strong></u></a> — A robust and flexible identity platform offering customizable authentication, single sign-on, and advanced security features for web and mobile applications.</p></div></li></ol><h3><strong>Authorization</strong></h3><p>Once a user’s identity has been verified, the next step is determining what they’re allowed to do within the application. This is known as authorization. Essentially, authorization involves defining access controls and permissions for various user roles. Some common techniques include:</p><ul><li><div><p><a title="https://www.permit.io/blog/rbac-with-permit" href="https://www.permit.io/blog/rbac-with-permit"><strong>Role-based access control (RBAC)</strong></a>: Users are assigned roles (e.g., admin, editor, or viewer) that determine the actions they can perform.</p></div></li><li><div><p><a title="https://www.permit.io/blog/what-is-abac" href="https://www.permit.io/blog/what-is-abac"><strong>Attribute-based access control (ABAC)</strong></a>: Access control is based on user attributes, such as job title, location, or department, which define the actions they can perform.</p></div></li></ul><p>By clearly defining user roles and permissions, you can ensure that sensitive data and functionality remains protected, while still allowing users to access the features they need.</p><p>As we develop our applications, it’s essential to rely on companies with proven expertise to handle complex tasks, allowing us to focus on seamlessly integrating their solutions into our applications. Here are a few excellent options to consider:</p><ol><li><div><p><a title="https://www.permit.io/" href="https://www.permit.io/"><u><strong>Permit.io</strong></u></a> — A comprehensive access control solution enabling policy-based authorization and simplified no-code permission management for application-level permissions.</p></div></li><li><div><p><a title="https://github.com/permitio/opal" href="https://github.com/permitio/opal"><u><strong>OPAL (Open Policy Administration Layer)</strong></u><u> </u></a>— OPAL is an open-source project for administrating authorization and access-control. It provides live updates to agents in response to policy and data changes, ensuring the speed required for real-time applications.</p></div></li><li><div><p><a title="https://github.com/open-policy-agent/opa" href="https://github.com/open-policy-agent/opa"><u><strong>OPA (Open Policy Agent)</strong></u></a> — A general-purpose policy engine empowering unified, context-aware policy enforcement across the entire technology stack.</p></div></li></ol><h3><strong>Databases / Data Handling</strong></h3><p>A core component of any application is its database and data handling capabilities. Databases store, manage, and retrieve data used by the application, while data handling encompasses the techniques and processes for working with that data. Key considerations for databases and data handling include:</p><ul><li><div><p><strong>Choosing the right database type</strong>: Decide between relational databases (e.g., MySQL, PostgreSQL) or NoSQL databases (e.g., MongoDB, Cassandra) based on your application’s data structure and access requirements.</p></div></li><li><div><p><strong>Data modeling</strong>: Define how data is organized and stored, ensuring efficiency and scalability.</p></div></li><li><div><p><strong>Data security</strong>: Implement measures to protect data from unauthorized access, tampering, or theft, such as encryption and secure backups.</p></div></li><li><div><p><strong>Data validation and sanitization</strong>: Ensure data integrity by validating input, preventing SQL injection attacks, and maintaining a clean database.</p></div></li></ul><p>Efficient and secure data handling is essential for maintaining a stable and reliable application, while also protecting user data. Here are some great databases to consider:</p><ol><li><div><p><a title="https://planetscale.com/" href="https://planetscale.com/"><u><strong> PlanetScale</strong></u></a>: A fully managed, globally distributed, MySQL-compatible database platform designed for high availability, scalability, and seamless application integration.</p></div></li><li><div><p><a title="https://supabase.com/" href="https://supabase.com/"><u><strong>Supabase</strong></u><u> </u></a>— A scalable, open-source alternative to Firebase offering real-time data synchronization and powerful APIs for backend development.</p></div></li><li><div><p><a title="https://www.mongodb.com/de-de" href="https://www.mongodb.com/de-de"><u><strong>MongoDB </strong></u></a>—<strong> </strong>A flexible, document-based NoSQL database designed for high performance, horizontal scaling, and ease of use in modern applications.</p></div></li></ol><h3><strong>Payments</strong></h3><p>If your application involves financial transactions, integrating a reliable payment system is crucial. A robust payment system will allow users to make transactions securely and efficiently, while also handling any related financial tasks. Key aspects of payment integration include:</p><ul><li><div><p><strong>Choosing a payment gateway</strong>: Select a reputable payment gateway provider that supports the currencies and payment methods your application requires.</p></div></li><li><div><p><strong>Security and compliance</strong>: Ensure that your payment system adheres to industry security standards, such as PCI DSS (Payment Card Industry Data Security Standard), to protect sensitive payment data and maintain user trust.</p></div></li><li><div><p><strong>User experience</strong>: Design a seamless and intuitive payment process that minimizes friction, making it easy for users to complete transactions.</p></div></li><li><div><p><strong>Payment tracking and reporting</strong>: Implement a system for tracking and managing transactions, refunds, and disputes, as well as generating reports for financial analysis and bookkeeping.</p></div></li></ul><p>Integrating a secure and efficient payment system not only improves the user experience but also helps build trust in your application, ultimately contributing to its success. Here are a few examples of companies that you can utilize to create a seamless payment experience in your application:</p><ol><li><div><p><a title="https://stripe.com/de" href="https://stripe.com/de"><u><strong>Stripe</strong></u><u> </u></a>— A comprehensive payment processing platform offering a suite of tools for online and in-person transactions, subscription management, and fraud prevention.</p></div></li><li><div><p><a title="https://www.paypal.com/de/home" href="https://www.paypal.com/de/home"><u><strong>PayPal</strong></u><u> </u></a>— A widely-recognized digital payment service enabling secure online transactions, e-commerce integrations, and cross-border money transfers.</p></div></li><li><div><p><a title="https://squareup.com/us/en" href="https://squareup.com/us/en"><u><strong>Square</strong></u><u> </u></a>— A versatile payment solution catering to businesses of all sizes, providing payment processing, point-of-sale systems, and a suite of business management tools.</p></div></li></ol><h3><strong>Summary</strong></h3><p>Creating a successful application requires a solid understanding of the essential building blocks: Authentication, Authorization, Databases/Data Handling, and Payments. By carefully considering these components and implementing them effectively, you can create a robust, secure, and user-friendly application that meets the needs of your target audience. As you continue to develop and refine your application, always prioritize user trust, data security, and a seamless user experience to ensure the long-term success of your project.</p>]]></content>
        <author>
            <name>Filip Grebowski</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Best Practices for Authorization in Microservices]]></title>
        <id>best-practices-for-authorization-in-microservices</id>
        <link href="https://www.permit.io/blog/best-practices-for-authorization-in-microservices"/>
        <updated>2023-04-13T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Best practices for implementing authorization in a microservices architecture. Learn how to create a better access control experience with Permit.io.]]></summary>
        <content type="html"><![CDATA[<h2>Intro</h2><p>As microservice architecture gains popularity, it becomes increasingly important to ensure that the services and their interactions are secure. One critical security aspect is <a title="https://www.permit.io/blog/what-is-authorization" href="https://www.permit.io/blog/what-is-authorization"><u><strong>authorization</strong></u></a>, which refers to determining whether <strong>a user or service</strong> has permission to <strong>access a particular resource</strong> or <strong>perform a specific action</strong>.</p><p>Authorization in a microservice architecture is more complex than in a monolithic one. In a monolithic architecture, a single authorization point typically controls access to all resources. Instead, a microservice architecture has multiple services, each with protected resources.</p><p>Furthermore, each service may have different, independent authorization requirements, and enforcing these requirements in a consistent and scalable manner can be a challenge.</p><p>For example, a user with permission to access resources from one service may not have permission to access another, even though both services belong to the same application.</p><p>In this article, we will overcome these challenges by using essential best practices one should follow when creating a microservice architecture. By implementing these best practices, you can ensure your microservice architecture is secure, compliant with industry regulations, and users can only perform the actions they should have access to.</p><p>Let’s dive in!<br></p><h2>Create Standalone PDPs</h2><p>A <a title="https://docs.permit.io/concepts/pdp/" href="https://docs.permit.io/concepts/pdp/"><u><strong>Policy Decision Point</strong></u></a> (PDP) is a component that makes authorization decisions based on <strong>policies </strong>and <strong>context </strong>information. It evaluates the incoming request against a set of policies and decides whether to allow or deny it. In a microservice architecture, it is essential to <strong>keep the PDP standalone</strong>, separate from application components. Therefore, the PDP should have <strong>its own control and data planes</strong>, which can be independently scaled, managed, and secured. <br><br>Decentralizing the PDPs reduces the impact of any failures, increases availability, and enables horizontal scaling of the authorization process.</p><p>Separating the control plane from the data plane means that <strong>the PDPs can have dedicated resources</strong> - including CPU, memory, network, and storage, as needed for their particular operations. These enable better performance and reliability for the authorization process. It also allows managing and <strong>updating the PDP independently of the application components</strong>. For example, if there is a new need for adding, editing, or modifying policies, it can be done without disrupting the application components.</p><p>An example of a standalone PDP is <a title="https://www.permit.io/blog/introduction-to-opa" href="https://www.permit.io/blog/introduction-to-opa"><u>Open Policy Agent (OPA)</u></a>. OPA is a policy engine that enables fine-grained control over resource access in a microservice architecture. OPA has an implementation of a standalone PDP that evaluates policies and generates telemetry data. The PDP can be scaled independently of the application components, providing better availability and performance.</p><h2>Use Sidecars for PDPs</h2><p>In a microservice architecture, a <strong>sidecar design pattern</strong> is a common approach for providing additional functionality to application components. This design pattern is accomplished by deploying a sidecar container alongside each application component to deliver specific services or features. Using a sidecar design pattern for managing PDPs, we ensure that each application component has its own dedicated PDP, which can be independently controlled and updated.</p><p></p><img src="https://media.graphassets.com/nkU9z131SGef5xN4Cg0t" alt="service mesh control plane.png" title="service mesh control plane.png" width="881" height="520" /><p>The sidecar pattern benefits applications that require low latency and high data reliability. Suppose an application component needs to make multiple requests to different microservices. Having a local PDP that can quickly evaluate the policies and provide the authorization decision could be beneficial in reducing network latency and improving the application&#39;s performance.</p><h2>Decouple Policy from the Enforcement Point</h2><p>The other side of the Policy Decision Point (PDP) is the policy enforcement point (PEP). The application enforces a permission decision made by the PDP and enforces the proper action a user is allowed or not allowed to perform.</p><p></p><img src="https://media.graphassets.com/HSrE8N9pRqC59GtknDF2" alt="pep pdp.png" title="pep pdp.png" width="669" height="416" /><p>In a monolithic application, it&#39;s common to embed the authorization logic in the application code itself. The code checking whether a user is allowed or not to act on a resource is also responsible for enforcing policies and making authorization decisions. While this approach may work, it aligns differently from SOLID principles as it mixes concerns and allows for repetition.</p><p><strong>Decoupling the policy logic from the enforcement point</strong> in a microservice architecture is even more essential. This separation of concerns is critical in reducing the complexity of the authorization process, enabling communication with PDPs and better lifecycle management of policies . It also keeps the application code focused on the functional logic instead of mixing in the permissions where they&#39;re irrelevant.</p><p>Using this approach, if we need to add or update the policy, we can keep it in the authorization control plane without changing the application’s code.</p><h2>Create a Straightforward Enforcement Framework</h2><p>Creating and enforcing a simple check function in the enforcement point is essential to keep the PEP decoupled from the policy logic. The check function should have a single function - <strong>validate the request and send it to the PDP for evaluation</strong>. The PDP should be responsible for making the authorization decisions and sending the response back to the PEP. This design ensures that the authorization logic remains centralized and easy to manage. It also ensures that the authorization process remains simple and easy to understand.</p><p>As part of Permit’s authorization as a service product, we continuously release SDKs for many programming languages to help the users to communicate with our provisioned PDPs. The check consists of one function that gets three parameters, <strong>Identity</strong>, <strong>Action</strong>, and <strong>Resource</strong>, and sends an API call to PDP. We also encourage our users to build compound conditions during the configuration phase, instead of doing it while analyzing the permission check. </p><img src="https://media.graphassets.com/sTHKEZaPQB6rOmPdhH9J" alt="permit check.png" title="permit check.png" width="1068" height="260" /><h2>Use Policy as Code</h2><p><a title="https://www.permit.io/blog/what-is-policy-as-code#:~:text=%E2%81%A0Policy%20as%20code%20is,for%20managing%20and%20deploying%20software." href="https://www.permit.io/blog/what-is-policy-as-code#:~:text=%E2%81%A0Policy%20as%20code%20is,for%20managing%20and%20deploying%20software."><u>Policy as code</u></a> is an emerging best practice for managing policies in a microservice architecture. It involves expressing the policies in a declarative format, such as JSON or YAML, and checking them into version control. This approach enables better lifecycle management of the policies, <strong>as you can manage, update, and version them like any other piece of code</strong>.</p><p>Policy as code also enables better granularity for authorization, making defining policies more robust. For example, you can start with a basic model with the user&#39;s role or group (Or, Role based access control - RBAC), and as your needs grow, support seamlessly also in creating policies based on specific attributes/properties of a user or resource (Or, Attribute based access control - ABAC), resulting in more fine-grained control over access to resources.</p><p>One example of a Policy as Code implementation is <a title="https://www.permit.io/blog/introduction-to-opa" href="https://www.permit.io/blog/introduction-to-opa"><u>Open Policy Agent (OPA)</u></a>. OPA provides a declarative language called Rego for expressing policies and a runtime for evaluating them. The policies can be checked into version control, managed, and updated like any other code. OPA supports a wide range of policies, including <a title="https://www.permit.io/blog/implement-rbac-using-opa" href="https://www.permit.io/blog/implement-rbac-using-opa"><u>RBAC</u></a> and <a title="https://www.permit.io/blog/implement-abac-using-opa" href="https://www.permit.io/blog/implement-abac-using-opa"><u>ABAC</u></a></p><h2>Cache Contextual Data in PDP</h2><p>Not all data required for authorization is available or relevant for every authorization check request. Some data, such as user attributes, object metadata, and entitlements, may need to be fetched from external sources such as IAM providers, application databases, external services, etc. Bringing this data for every request can be slow, inefficient, and may introduce latency into the authorization process.</p><p>Using a policy administration tool that fetches and updates the PDP as changes in the external resources occur makes policy evaluation faster and more efficient. The PDP can quickly access the required data without fetching it from external sources.</p><p>One example of such an administration tool is <a title="https://github.com/permitio/opal" href="https://github.com/permitio/opal"><u>OPAL</u></a>, an open policy administration layer that works with OPA. OPAL tracks changes in external services and propagates the data to the OPA PDPs so the authorization requests can handle existing data and return faster results.</p><img src="https://media.graphassets.com/b6AXrXpyR5W9oh7taYON" alt="OPAL Client.png" title="OPAL Client.png" width="654" height="630" /><h2>Support Multiple Models such as ABAC and RBAC</h2><p>The typical<a title="https://www.permit.io/blog/rbac-with-permit" href="https://www.permit.io/blog/rbac-with-permit"><u> </u><u><strong>Role Base Access Control (RBAC)</strong></u></a> approach can be limited in a microservice architecture as we want to develop independent services and maintain their data models. Creating general roles and resource standards can be complex and exhausting. For such cases, we might want to add permissions models, such as <strong>Attribute Based Access Control (ABAC)</strong> or <strong>Relationship-Based Access Control (ReBAC)</strong>, that allow more granular policy configuration and authorization checks.</p><p>Following patterns such as policy as code and independent PDPs, you can start with a simple RBAC model and integrate ABAC or any other model seamlessly into the application when the need arises. Since the PEP code is always kept as simple as one function checking for permissions by Identity, Resource, and Action, the permission model in the control plane stays valid from the application side. Policy languages such as Rego or AWS Cedar support multiple permission models in the same PDP implementation.</p><h2>What&#39;s Next?</h2><p>Authorization is a crucial aspect of a microservice architecture. It enables organizations to control resource access accurately, ensuring that only authorized users can view sensitive data. However, implementing authorization in a microservice architecture can be quite challenging, as it requires a different approach to authorization from monolithic architectures.</p><p>In this blog post, we have outlined seven best practices for implementing authorization in a microservice architecture. By following these best practices, organizations can implement authorization in a microservice architecture that is resilient, flexible, and efficient. These best practices enable organizations to control access to resources in a granular way without introducing unnecessary complexity into the architecture.</p><p>Besides implementing solutions, organizations can ensure they align to secure authorization by using authorization as a Service product such as <a title="https://www.permit.io" href="https://www.permit.io"><u>Permit.io</u></a>, which provides full-stack support for authorization in microservices and implementing the best practices outlined in this blog out of the box.</p><p><em></em></p><p><em>This post was originally published on TFiR.io as part of the KubeCon EU content.</em></p>]]></content>
        <author>
            <name>Gabriel L. Manor</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[BingBang - Why Authentication is no Longer Enough]]></title>
        <id>bingbang</id>
        <link href="https://www.permit.io/blog/bingbang"/>
        <updated>2023-03-30T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[The recent #BingBang vulnerability discovered by the Wiz team proves once again how crucial implementing proper authorization is.]]></summary>
        <content type="html"><![CDATA[<p>In today&#39;s digital age, cybersecurity has become a critical aspect of every organization&#39;s operations. With increasing cyber-attacks, companies must ensure that their systems are secure and protected from unauthorized access. Authentication has long been the foundation of cybersecurity, but it is no longer enough. <strong>Authorization is equally and maybe even more important</strong>. To face the complexities of the software itself and the incoming attacks it has become essential to have an easy-to-use and accessible authorization mechanism that allows users to manage policies and audit authorization logs.</p><h2>BingBang</h2><p>The <a title="https://www.youtube.com/watch?v=hctqRgQW4IU" href="https://www.youtube.com/watch?v=hctqRgQW4IU"><u>BingBang incident</u></a>, where security researchers from <a title="https://www.wiz.io/" href="https://www.wiz.io/"><u>Wiz</u></a> gained access to the back-office admin dashboard for the Bing search engine, is an excellent example of why authorization is critical. Although authentication was in place, authorization failed due to a wrong policy. This highlights the need for a robust authorization mechanism that complements authentication.</p><h2>Policy As Code and Git-ops </h2><p>One of the best ways to ensure that authorization is effective is by using <a title="https://www.permit.io/blog/what-is-policy-as-code" href="https://www.permit.io/blog/what-is-policy-as-code"><u>policy as code</u></a>. Policy as code involves writing policies in a machine-readable format and storing them in a version control system such as Git. This allows policies to be audited and reviewed, just like code. It also enables organizations to manage complex policies and make changes efficiently, reducing the risk of errors and inconsistencies.</p><p><a title="https://www.permit.io/blog/gitops-today-why-and-how" href="https://www.permit.io/blog/gitops-today-why-and-how">Managing policies with Git-ops</a> has several benefits. It provides a centralized location for managing policies, making it easy to track changes and maintain a history of modifications. It also enables organizations to define and enforce policies consistently across all their applications, reducing the risk of policy violations.</p><h2>Audit logs and interfaces</h2><p>In addition to policy as code, it is critical to have an audit trail of all authorization events. Audit logs provide an essential record of who accessed what and when, enabling organizations to detect and investigate any unauthorized access attempts. They also provide valuable insights into how policies are being used and can help identify areas where policies may need to be updated or improved.</p><h2>You’re not alone - OSS and SaaS</h2><p>Just like authentication, encryption, or billing, authorization and permissions are crucial aspects of modern cybersecurity that organizations cannot afford to overlook. Building an effective authorization mechanism can be a complex and time-consuming process. Fortunately, there are several open-source projects and SaaS services available that can help organizations to implement authorization easily and effectively. Open-source projects such as <a title="https://www.permit.io/blog/introduction-to-opa" href="https://www.permit.io/blog/introduction-to-opa"><u>Open Policy Agent (OPA)</u></a> and <a title="https://www.permit.io/blog/introduction-to-opal" href="https://www.permit.io/blog/introduction-to-opal">Open Policy-Administration Layer (OPAL)</a> provide pre-built policy enforcement capabilities that can be integrated with existing systems. These tools enable organizations to define and manage policies consistently across all their applications while also providing audit capabilities.</p><p>Additionally, SaaS services like <a title="https://www.permit.io/" href="https://www.permit.io/"><u>Permit.io</u></a> (😅) offer an end-to-end solution for managing authorization and permissions. These services provide an easy-to-use interface for defining and enforcing policies, as well as audit logs for tracking all authorization events. By leveraging these tools and services, organizations can avoid the complexity of building their authorization mechanism from scratch, freeing up time and resources to focus on other critical aspects of their business.</p><h2>TL;DR</h2><p>Authentication is no longer enough to ensure the security of an organization&#39;s systems. Authorization is equally important and must be complemented by an easy-to-use and accessible mechanism that allows users to manage policies and audit authorization logs. Using policy as code and Git-ops to manage complex policies and audit logs to track all authorization events is a winning combination that organizations can use to strengthen their security posture. By taking these steps, organizations can reduce the risk of cyber-attacks and protect their sensitive data from unauthorized access.<br><br>Fortunately, with the availability of open-source projects and SaaS services, building an effective authorization mechanism has never been easier. By leveraging these tools and services, organizations can implement authorization quickly, easily, and effectively, allowing them to focus on their core business objectives while keeping their systems and data secure.</p>]]></content>
        <author>
            <name>Or Weis</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Access Control - from scary to simple with one open-source tool]]></title>
        <id>access-control-scary-to-simple</id>
        <link href="https://www.permit.io/blog/access-control-scary-to-simple"/>
        <updated>2023-03-28T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[OPAL, an open-source project, complements and enhances OPA and is already being used by companies like Tesla, Cisco, and the NBA.]]></summary>
        <content type="html"><![CDATA[<p>TL;DR: Open source code promotes innovation, collaboration, and transparency in software development. <a title="https://www.permit.io/blog/introduction-to-opa" href="https://www.permit.io/blog/introduction-to-opa">Open Policy Agent (OPA)</a> is a powerful policy engine that helps manage access control in microservice architectures, and has been adopted by major companies <a title="https://www.permit.io/blog/netflix-authz" href="https://www.permit.io/blog/netflix-authz">such as Netflix</a>. However, OPA alone may not be sufficient for some policy enforcement needs. <a title="https://www.permit.io/blog/introduction-to-opal" href="https://www.permit.io/blog/introduction-to-opal">OPAL</a>, an open-source project, complements OPA by addressing these limitations and is already being used by companies like Tesla, Cisco, and the NBA.</p><h2>Why Open Source?</h2><p>Open source code plays a crucial role in the world of software development. It allows developers from around the globe to access, modify, and contribute to the source code of various projects, resulting in a powerful knowledge-sharing ecosystem. By making software freely available, open source promotes the rapid evolution of technology and ensures that solutions are accessible to a broader audience. This collaborative approach helps accelerate problem-solving, encourages the development of better and more reliable software, and drives the growth of vibrant developer communities. Furthermore, open source enables individuals and organizations to build upon existing solutions, reducing the duplication of effort, lowering entry barriers, and empowering even small teams to create powerful, feature-rich applications.</p><h2>Access Control is Hard</h2><p>Developing access control is not an easy task, especially considering <a rel="noopener" class="markup--anchor markup--p-anchor" target='_blank' title="https://www.permit.io/blog/achieving-modern-authorization" href="https://www.permit.io/blog/achieving-modern-authorization">today’s microservice architectures</a>: many authorization points are required by design, and changing requirements and regulations from various departments constantly challenge the solution. Moreover, <strong>even a minor bug in this sensitive layer can have a devastating effect</strong> on your organization.</p><p>To successfully build an access control layer, it is necessary to embrace some <a rel="noopener" class="markup--anchor markup--p-anchor" target='_blank' title="https://www.permit.io/blog/5-best-practices-for-building-cloud-native-permissions" href="https://www.permit.io/blog/5-best-practices-for-building-cloud-native-permissions">best practices</a> —  One of which is to decouple policy from code. This can be done using <strong>a policy engine </strong>such as <a rel="noopener" class="markup--anchor markup--p-anchor" target='_blank' title="https://www.permit.io/blog/introduction-to-opa" href="https://www.permit.io/blog/introduction-to-opa">Open Policy Agent (OPA)</a>.</p><h2>OPA: Separating policy from code</h2><p>OPA, an all-purpose policy engine OSS project, was introduced several years back to reinvent how we enforce permissions throughout the stack. Since its inception, OPA became a CNCF graduate (alongside Kubernetes) and was battle-tested by major players like Goldman Sachs and <a rel="noopener" class="markup--anchor markup--p-anchor" target='_blank' title="https://www.permit.io/blog/netflix-authz" href="https://www.permit.io/blog/netflix-authz">Netflix</a>.</p><p>OPA is very efficient and built for performance — It keeps the policy and data for which it needs to evaluate the rules in the cache, and supports having multiple instances as sidecars to every microservice, thus avoiding network latency.</p><p>OPA’s policy rules are written in Rego — a high-level declarative (Datalog-like) language. Here is an example:</p><pre><code>default allow = false
allow = true { 
 input.type == &quot;writer&quot;
     input.action == &quot;create&quot;
     input.resource == &quot;article&quot;
}</code></pre><p>Here is a high-level overview of how OPA works.</p><img src="https://media.graphassets.com/HCKZMT8GT5i7bATK3QFT" alt="Screenshot 2023-03-21 at 13.30.23.png" title="Screenshot 2023-03-21 at 13.30.23.png" width="1268" height="1320" /><p>OPA is really powerful and can solve a lot of policy-related issues. Having said that, for some policies, OPA isn’t enough, and another solution is needed.</p><h2>Taking OPA to the next level</h2><p>While OPA is a strong candidate for all permissions-related needs, there are cases where OPA might not be enough.</p><p>For example, let’s say that our policy requires that a user will be a subscriber to see parts of our site. In this case, to make a policy decision, we need to know the user’s subscription status from our billing service (e.g. PayPal or Stripe) and know every time it is changing: a new subscriber expects immediate access to our site, and a churned user should lose access on the spot.</p><p>To make the data accessible to OPA, we will need to develop a pushing mechanism that will update OPA in real-time, which requires additional planning and development.</p><p>There are additional cases for which OPA isn’t enough:</p><ul><li><div>When your policy relies on multiple data sources for decisions, you need to use the <a rel="noopener" class="markup--anchor markup--li-anchor" target='_blank' title="https://www.openpolicyagent.org/docs/latest/external-data/#option-3-bundle-api" href="https://www.openpolicyagent.org/docs/latest/external-data/#option-3-bundle-api">bundle API</a>, which is not really straightforward to implement.</div></li><li><div>When you have multiple OPA instances, you need to build your tools to keep them in sync.</div></li></ul><p>OPA was adopted by giants like Netflix, and they faced the same challenges. Let’s take a look at how they overcame their issues.</p><h2>Learning from giants — Netflix &amp; OPA</h2><p>There are three things that Netflix implemented in their architecture that utilize OPA, which allowed them to have an effective solution.</p><ol><li><div><strong>Running Multiple OPA Instances Simultaneously</strong>: Netflix’s architecture incorporates numerous OPA instances, each operating locally on a service’s pod and equipped with its own authorization agent. By doing so, they significantly reduce network latency when querying OPA, ensuring a smoother and more efficient authorization process.</div></li><li><div><strong>Real-time Policy and Data Synchronization</strong>: Netflix’s authorization system relies on certain inputs not included in OPA’s data, such as employee-department associations. To address this, they developed a microservice called an “Aggregator” that gathers data from various sources and keeps it up to date in real-time. Additionally, they implemented another microservice, the “Distributor,” which ensures that all OPA instances remain synchronized and current.</div></li><li><div><strong>Empowering Developers with Self-service Policy Creation</strong>: As a large organization, Netflix needed a scalable solution that granted developers the autonomy to define policies for their respective services. To achieve this, they designed the “Policy Portal” — a user-friendly website that automatically generates Rego code based on user-defined rules. Once a policy is created or updated, it’s versioned and stored in a dedicated policy database.</div></li></ol><p>There is one issue with this solution —  Netflix never made it public. </p><h2>That’s what OPAL is here for!</h2><p><a rel="noopener" class="markup--anchor markup--p-anchor" target='_blank' title="https://github.com/permitio/opal" href="https://github.com/permitio/opal">Open Policy Administration Layer (OPAL)</a> is an OSS project invented to aid with OPA management, essentially open-sourcing Netflix’s solution. OPAL is an administration layer for the OPA agents, which keeps them updated in real-time with data and policy updates. Since its creation, OPAL has been adopted by major players such as Tesla, Cisco, Palo Alto Networks, multiple banks and even the NBA as the administration layer for their OPA agents.</p><p>OPAL offers two remarkable features that have garnered widespread appreciation among numerous organizations:</p><ul><li><div>The ability to <strong>monitor a specific policy repository</strong> (like GitHub, GitLab, or Bitbucket) for updates. It does this by either using a webhook or checking for changes every few seconds. This makes the system act as a Policy Administration Point (PAP), which sends the policy changes to OPA, the Policy Decision Point (PDP) in this case. This ensures that OPA is always up to date.</div></li><li><div>The ability to <strong>track any relevant data source</strong> (API, Database, external service) for updates via a REST API, and fetch up-to-date data back into OPA.</div></li></ul><p>Designing access control and managing permissions for cloud-native or microservice-based products can be a complex endeavor. The inherent nature of distributed applications and microservices demands numerous authorization points, while evolving requirements from different departments continuously put pressure on every authorization solution. Furthermore, even the slightest oversight in the authorization layer may result in severe consequences for your application, leading to security vulnerabilities and potential privacy or compliance issues. Therefore, it is vital to diligently approach and handle these challenges to ensure robust and secure applications.</p><p>You can join <a rel="noopener" class="markup--anchor markup--p-anchor" target='_blank' title="https://io.permit.io/permitslack" href="https://io.permit.io/permitslack">OPAL’s Slack community</a> to chat with other devs who use OPAL for their projects, <a rel="noopener" class="markup--anchor markup--p-anchor" target='_blank' title="https://github.com/permitio/opal" href="https://github.com/permitio/opal">contribute to the Open-source project</a>, or<a rel="noopener" class="markup--anchor markup--p-anchor" target='_blank' title="https://twitter.com/opal_ac" href="https://twitter.com/opal_ac"> follow OPAL on Twitter </a>for the latest news and updates.</p>]]></content>
        <author>
            <name>Filip Grebowski</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[How to Create an Authorization Middleware for Fastify]]></title>
        <id>how-to-create-an-authorization-middleware-for-fastify</id>
        <link href="https://www.permit.io/blog/how-to-create-an-authorization-middleware-for-fastify"/>
        <updated>2023-03-24T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Learn how to implement middleware for a granular access control system in Fastify applications using the Permit.io cloud service.]]></summary>
        <content type="html"><![CDATA[<p>Fastify has gained popularity among developers as a Node.js API/web framework due to its reputation for being fast, modular, scalable, and well-structured. It is also compatible with modern architectures such as microservices and serverless. Its optimized performance for these architectures has made it a preferred choice for many developers.</p><p>One of the benefits of using Fastify is the plugin system which allows you to easily add functionality to your API routes. This allows you to maintain the ‘separation of concerns’ principle, which prevents the mixing of plugin functionality with the business logic of your application. Thus, you can seamlessly add authentication, error handling, billing, and more services to your application using plugins.</p><p>One of the critical aspects of any modern application is <strong>authorization</strong>. No one wants their application’s users to be able to read data that does not belong to them or perform operations they are not allowed to. This requires a granular access control system that checks what users can do and enforces it.</p><p>When it comes to authorization, many applications mix the permissions logic with the application logic, <a title="https://www.permit.io/blog/four-mistakes-you-make-when-building-permissions#2-mixing-up-app-logic-and-authorization" href="https://www.permit.io/blog/four-mistakes-you-make-when-building-permissions#2-mixing-up-app-logic-and-authorization"><u><strong>which is not a good idea</strong></u></a>. When these two logic sets are combined, they inevitably grow and become increasingly complex, turning any future effort of separating, editing, updating, or upgrading them into a nightmare. Authorization, the same as authentication, requires to be managed separately from our application logic. </p><p>This guide demonstrates a middleware plugin which helps you implement a granular access control system into Fastify applications. We will use Permit.io’s cloud service to configure the proper permissions model, and then demonstrate how it can be seamlessly added to any kind of Fastify application. This will allow a proper enforcement model for your application users.</p><h2>Demo Application</h2><p>To demonstrate the Permit.io service and its Fastify plugin for authorization, we created a demo blogging platform with the relevant Fastify APIs. See the code below:</p><pre><code>require(&#39;dotenv&#39;).config();

import Fastify from &#39;fastify&#39;;
import type { FastifyInstance, FastifyReply, FastifyRequest } from &quot;fastify&quot;;

// Create server
const server: FastifyInstance = Fastify({ logger: true });

// Mock handlers
const mockPublic = async (_req: FastifyRequest, _reply: FastifyReply) =&gt; ({ hello: &#39;public&#39; });
const mockPrivate = async (_req: FastifyRequest, _reply: FastifyReply) =&gt; ({ hello: &#39;private&#39; });
const authenticate = async () =&gt; ({ hello: &#39;authenticate&#39; });

// Scoped private routes
const privateRoutes = async (fastify: FastifyInstance, _opts: any) =&gt; {
    // Mock authentication
    fastify.register(authenticate);

    fastify.post(&#39;/post&#39;, mockPrivate);
    fastify.put(&#39;/post&#39;, mockPrivate);
    fastify.delete(&#39;/post&#39;, mockPrivate);
    fastify.post(&#39;/comment&#39;, mockPrivate);
    fastify.put(&#39;/comment&#39;, mockPrivate);
    fastify.delete(&#39;/comment&#39;, mockPrivate);
    fastify.post(&#39;/author&#39;, mockPrivate);
    fastify.put(&#39;/author&#39;, mockPrivate);
    fastify.delete(&#39;/author&#39;, mockPrivate);
};

// Scoped public routes
const publicRoutes = async (fastify: FastifyInstance, _opts: any) =&gt; {
    fastify.get(&#39;/post&#39;, mockPublic);
    fastify.get(&#39;/comment&#39;, mockPublic);
    fastify.get(&#39;/author&#39;, mockPublic);
}

// Register scoped routes
server.register(privateRoutes);
server.register(publicRoutes);

// Start server
(async () =&gt; {
    try { await server.listen({ port: 3000 }); } catch (err) {
        server.log.error(err);
        process.exit(1);
    }
})();</code></pre><p>For the purpose of this demo, we have implemented a mock authentication plugin (registered as a mock function in the code). </p><p>We separated routes into public and private ones and protected the private ones with the mock Authentication plugin. Permit.io works with every authentication method - so you can integrate it with any authentication method you prefer.</p><p>To follow this tutorial, we are recommending cloning the source code to your local machine, and run <code>npm i &amp;&amp; npm run dev</code> so you can see it in action running on your local environment at port <code>3000</code>.</p><p>You can clone it from here (remove the branch to get the final version of the tutorial).</p><pre><code>git clone -b tutorial git@github.com:permitio/permit-fastify-example.git</code></pre><h2>Designing a Simple RBAC Permissions Model</h2><p>When incorporating permissions into an application, it&#39;s important to design the model and be aware of which permissions should or should not be granted to users. To do this, we need to consider three entities: Who the user is (Their <strong>Identity and Role</strong>), What <strong>Resources </strong>are we monitoring access for, and which <strong>Actions </strong>can be preformed on that resource. The combination of these entities is called a <strong>Policy</strong>. </p><p>With those entities in mind, we can map our application into <strong>conditions </strong>and <strong>policies </strong>to reflect the permissions we want.</p><p>Let’s examine our demo blog’s APIs. </p><ul><li><div><p><strong>Roles </strong>can be assigned to <strong>authenticated users</strong> (Admin, Writer, Commenter).</p></div></li><li><div><p><strong>Actions </strong>can be paired (to simplify the process) with <strong>HTTP methods</strong> (Get, Create, Update, Delete, Patch).</p></div></li><li><div><p><strong>Resources </strong>are the different <strong>endpoints </strong>we want to manage access for (posts, authors, comments, etc.)</p></div></li></ul><p>By mapping them all, we can get the following table:</p><table><tbody><tr><td><p>Role</p></td><td><p>Resource</p></td><td><p>Action</p></td></tr><tr><td><p>Admin</p><p>Writer</p><p>Commenter</p></td><td><p>Post</p><p>Author</p><p>Comment</p></td><td><p>Get</p><p>Create</p><p>Update</p><p>Delete</p><p>Patch</p></td></tr></tbody></table><p>Now that we have our basic outline of our roles, resources and actions, we can map the desired allowed conditions (Following the least privilege principle) of the model as follows: </p><ul><li><div><p><strong>Admins </strong>can perform<strong> any actions</strong> on <strong>any resource</strong></p></div></li><li><div><p><strong>Writers </strong>can <strong>create</strong>, <strong>update</strong>, <strong>patch</strong>, and <strong>delete posts</strong>, and <strong>get comments</strong></p></div></li><li><div><p><strong>Commenters </strong>can <strong>get </strong>and <strong>create comments</strong></p></div></li></ul><h2>Configuring Permissions in Permit.io</h2><p>Now that we have our model designed, let’s implement it! As we previously mentioned, we do not intent to incorporate the policy code as part of the API logic. To keep </p><p>things clean, we want a separate service that allows us to define and configure the policies. This way, the service can focus on enforcing permissions, while the application code focuses on vital application logic.</p><p>Permit.io is an authorization-as-a-service product that lets us configure and enforce permissions, keeping your code clean and controlling your application access. The tool has an extensive free tier, and is completely self service.</p><p>To configure the desired application permissions, let’s follow these steps:</p><ol><li><div><p>Log in to Permit.io at <a title="https://app.permit.io/" href="https://app.permit.io/">app.permit.io</a></p></div></li><li><div><p>After logging in, go to the Policy page and create the following roles:</p><img src="https://media.graphassets.com/rl4unQM2SzSwNn5E8b7T" alt="Create roles blog.png" title="Create roles blog.png" width="1437" height="778" /></div></li><li><div><p>Continue by creating the resources with their actions:⁠</p><img src="https://media.graphassets.com/Gurboi71RGTog7ZE21aA" alt="Resources Blog.png" title="Resources Blog.png" width="1919" height="641" /></div></li><li><div><p>Implement the desired conditions to the policy table by checking the relevant boxes.</p><img src="https://media.graphassets.com/lwNUckXwQZGMUcLp2Q9q" alt="Policy editor blog.png" title="Policy editor blog.png" width="1401" height="918" /></div></li><li><div><p>We will finish the configuration by creating three users and assign them the relevant roles in the Users screen.</p><img src="https://media.graphassets.com/QIW5E9rpT2GXf2Dhmbij" alt="Users blog.png" title="Users blog.png" width="1466" height="469" /></div></li></ol><p>That’s it! Now that we set up our permissions, its time to connect them to our Fastify application.</p><h2>Enforce Permissions with the Fastify Plugin</h2><p>To enforce the policy in our application, let’s do the following:</p><ol><li><div><p>Grab the SDK code for Permit.io’s APIs from the application:</p><img src="https://media.graphassets.com/0aCsTw4YSmWvEa1p5vZG" alt="saveAPI.png" title="saveAPI.png" width="1600" height="898" /></div></li><li><div><p>Paste it in your .env file in the following format.<br><code>PERMIT_SDK_TOKEN=&lt;permit_sdk_token&gt;</code></p></div></li><li><div><p>Let’s now create a new plugin file. If you cloned our project, you can find the <code>authorize.ts</code> file in the <code>plugin</code> folder. If you are using your own project, do it in your desired plugin folder.</p></div></li><li><div><p>In the file we created, paste the following code. Look at this commented code, you’ll find a granular middleware that checks the permissions of the API requests by the request configuration.<br></p><pre><code>import type { FastifyReply, FastifyRequest, HookHandlerDoneFunction } from &#39;fastify&#39;;
import { Permit } from &#39;permitio&#39;;

// Initialize Permit SDK with token from the .env file
const permit = new Permit({
  token: process.env.PERMIT_SDK_TOKEN,
  pdp: &#39;https://cloudpdp.api.permit.io&#39;
});

export const withPermitMiddleware = async (req: FastifyRequest, reply: FastifyReply, done: HookHandlerDoneFunction) =&gt; {
  const { headers: { user = &#39;&#39; }, body: attributes, routerPath, method: action } = req;

  // Take user from the header, in a real world scenario this would be a JWT token
  const identity = (Array.isArray(user) ? user[0] : user);

  // Split the path to get the resource type
  const type = routerPath.split(&#39;/&#39;)[1]

  // Build the resource object. If the request body is empty, we only need the type
  const resource = attributes ? { type, attributes } : type;

  // Check if the user is allowed to perform the action on the resource
  const allowed = await permit.check(identity, action.toLowerCase(), resource);

  // If the user is not allowed, return a 403
  if (!allowed) {
    reply.code(403).send({ error: &#39;Forbidden&#39; });
  }
};
</code></pre></div></li><li><div><p>Now that we have the generic middleware, we only have to paste the following code at the top of the private routes registry, just after the authentication plugin register.</p><pre><code>import { withPermitMiddleware } from &#39;./plugins/authorize&#39;;
⁠
...
// Add authorization middleware
fastify.addHook(&#39;preHandler&#39;, withPermitMiddleware);⁠
...</code></pre></div></li></ol><p>Looking at the code, we can see the options object where we streamlined the auth header as the identity key, the URL to the resource name, and the action method. At this point, we have access control protection with Permit.io Fastify middleware.<br>Let’s run our project with npm run dev and send a creating an author request with a writer user. This should result in the following error:<br></p><video controls width="undefined" height="undefined">
          <source src="https://media.graphassets.com/IKw1Tg8mSryrROMyvJcA" type="video/mp4" title="rbac.mp4" />
          Sorry, your browser doesn't support embedded videos.
        </video><h2>Evolve your Permissions with ABAC</h2><p>Note: Enforcing ABAC policies requires deploying a local PDP - to get started, follow <a title="https://docs.permit.io/tutorials/deploying/overview" href="https://docs.permit.io/tutorials/deploying/overview">this guide</a>. <br><br>In a real world scenario, it can be challenging to streamline our Identity, Resource, and Action to a flat list of Roles, Resource types, and Action names, as we did in our example. </p><p>If, for example, we would like to have approval flow for content in our blog, and only allow approved writers to publish articles, disallow comments from a specific geolocation, or any other more granular limitations, simple RBAC will not suffice.  </p><p>Managing more granular permissions such as these require handling <strong>attributes</strong>, which can be achieved through Attribute-Based access control (ABAC).</p><p>Let’s write the conditions we list above, but with more details on the attributes.</p><ul><li><div><p><strong>Admin</strong> users can perform any <strong>action</strong> on any <strong>resource</strong>.</p></div></li><li><div><p><strong>Writers</strong> can <strong>edit</strong>, and <strong>delete</strong> posts but <strong>create</strong> only <strong>unpublished posts</strong>.</p></div></li><li><div><p><strong>Approved writers</strong> can <strong>create</strong> any kind of <strong>post</strong>.</p></div></li><li><div><p><strong>Commenters</strong> can <strong>create</strong> comments.</p></div></li></ul><p>Adding attributes to an RABC model, thus essentially switching to ABAC is quite a complex task. Permit.io helps you to alleviate this complexity, as we can simply change our configuration to support the new permission model without any changes in the application code. <br>A typical way to implement ABAC is using <strong>Resource Sets</strong> and <strong>User Sets</strong>—these sets are built from conditions that combine user and resource attributes. Let’s see how we can utilize these and configure these policies within Permit.</p><ol><li><div><p>We start by configuring the attributes on the following resources. You can do this by clicking the three dots on the resource table in the <strong>Policy Editor</strong> and then Add Attribute<br></p><img src="https://media.graphassets.com/sDIFnoOgTm6t2VAZ9Xxo" alt="Resource attribute config blog.png" title="Resource attribute config blog.png" width="875" height="682" /></div></li><li><div><p>Now that Permit.io is aware of our resource attributes, let’s create the conditions by creating <code>Resource Sets</code> in the <strong>Policy Editor</strong>.⁠</p><img src="https://media.graphassets.com/LJtUXBM6Q9Orn2ZDxF4L" alt="Resource set config blog.png" title="Resource set config blog.png" width="1439" height="682" /></div></li><li><div><p>To match the policy with user attributes, we need to configure user attributes as well. This can be done from the Users screen by clicking the <code>Attributes</code> tab and creating an approved attribute.</p><img src="https://media.graphassets.com/xhSGr1ROq7JbAQQvm9GA" alt="Create user attributes blog.png" title="Create user attributes blog.png" width="1437" height="778" /></div></li><li><div><p>Let’s also add a new user in the Writer role that has the approved attribute in their profile. This will help us to check the ABAC policy later. To do so, just add a Writer role user, and then assign them the following attributes.</p><img src="https://media.graphassets.com/PPfZBWu5RRStf8eCrwQG" alt="Create roles ABAC.png" title="Create roles ABAC.png" width="1437" height="778" /></div></li><li><div><p>Now that Permit.io is aware of our custom user attributes, let’s create the conditions by creating <code>User Sets</code> in the <strong>Policy Editor</strong>.</p><img src="https://media.graphassets.com/QSZspQWJRLD9wTDcqwt6" alt="User Sets blog.png" title="User Sets blog.png" width="842" height="641" /></div></li><li><div><p>You can now see new options in the policy table - let’s adopt the policy configuration to our newly defined conditions.</p><img src="https://media.graphassets.com/05N4WVJTKaNPK7zk0ilB" alt="Policy editor ABAC blog.png" title="Policy editor ABAC blog.png" width="1293" height="918" /></div></li></ol><p>Instead of rewriting our application code, the same middleware we created for our private routes will continue to enforce permissions with the new policy model configuration we assigned.</p><p></p><video controls width="undefined" height="undefined">
          <source src="https://media.graphassets.com/kzql6KRSQda6lJJUVonQ" type="video/mp4" title="abac.mp4" />
          Sorry, your browser doesn't support embedded videos.
        </video><h2>What Next?</h2><p>At this point, you should have a basic understanding of how to implement a basic authorization model into your Fastify application, enforcing permissions with single line of code. </p><p>The next step would be to analyse the particular needs of your application, and implement a reliable permission model into it. As you saw in the article - it shouldn’t be very complicated. </p><p>The plugin we created for this blog is available and ready to use - Just adapt it to your application’s factors in the relevant request fields, and your done.</p><p>If your organization already implemented an authorization model, and you want to learn more about how to scale it right, <a title="https://io.permit.io/permitslack" href="https://io.permit.io/permitslack"><u>Join our Slack community</u></a> where hundreds of devs and authorization experts discuss building and implementing authorization.</p>]]></content>
        <author>
            <name>Gabriel L. Manor</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[RBAC VS ABAC: Pros, Cons, Choosing the Right AuthZ Policy Model]]></title>
        <id>rbac-vs-abac</id>
        <link href="https://www.permit.io/blog/rbac-vs-abac"/>
        <updated>2023-03-16T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[RBAC and ABAC are two of the most common authorization policy models out there. How do you choose the right one for your application?]]></summary>
        <content type="html"><![CDATA[<p>Authorization is a complex challenge that basically every developer building an application has to face. As a software product grows, the need to grant or deny access to specific resources based on a user&#39;s verified identity becomes critical (It’s also important <a title="https://www.permit.io/blog/authn-vs-authz" href="https://www.permit.io/blog/authn-vs-authz">not to confuse</a><strong> Authentication</strong>, which is verifying a user&#39;s identity, with <strong>Authorization</strong>). </p><p>At the end of the day, it&#39;s crucial that we make sure The<strong> right people</strong> have the <strong>right access</strong> to the <strong>right assets</strong>. This is what <a title="https://www.permit.io/blog/what-is-authorization" href="https://www.permit.io/blog/what-is-authorization"><u>authorization </u></a>is all about. </p><p>Application-level Authorization can be managed through different <strong>authorization models</strong>. These authorization models determine the level of access or permissions granted to users based on factors such as user roles, attributes, contextual information, or a combination of these factors. </p><p>Choosing the right authorization model and properly implementing it is not an easy task, and it is critical to maintaining the security and privacy of an application, its users, and its data. </p><p>To make this decision easier, we’ll review two of the most common authorization models - Role Based Access Control (RBAC) and Attribute Based Access Control (ABAC), the main differences between them, and when they should be applied. </p><p>Let’s start with RBAC -<br></p><h2>What is RBAC</h2><p><a title="https://www.permit.io/blog/rbac-with-permit" href="https://www.permit.io/blog/rbac-with-permit"><strong>Role Based Access Control</strong> <strong>(RBAC)</strong></a> is an authorization model used to determine access control based on predefined <strong>roles</strong>. Access permissions are assigned to roles like “<strong>Admin</strong>” or “<strong>Editor</strong>”. Then, roles are assigned to specific users by the administrator. </p><p>This structure allows you to easily understand <strong>who has access to what</strong> based on these defined roles. </p><p>For example, here’s a rather simple example of an RBAC policy in simple English - </p><p><strong>Employees </strong>can <strong>View </strong>and <strong>Edit </strong>Documents, while <strong>Admins </strong>can <strong>View, Edit, Create, and Delete </strong>them.</p><p>RBAC provides a rather simple solution for controlling access to resources based on a predefined set of roles that can, for example, correlate with an individual&#39;s job function or responsibilities. </p><p></p><h2>RBAC Pros</h2><ul><li><div><p><strong>Simplicity:</strong> RBAC provides a solution that is<strong> rather simple</strong> and <strong>familiar </strong>to both your developers and end-users while allowing for more granular access control than basic models like <strong>Admin/Non-Admin.</strong> </p></div></li><li><div><p><strong>Easy management:</strong> The predefined roles set by RBAC can, for example, correlate with an individual&#39;s job function or responsibilities. This can allow administrators to manage access control at a high level by defining roles and assigning them with permissions<strong> rather than managing permissions for individual users</strong>.</p></div></li><li><div><p><strong>Scalability:</strong> RBAC enables developers to <strong>scale</strong> rather easily as their application grows. If <a title="https://www.permit.io/blog/rbac-with-permit" href="https://www.permit.io/blog/rbac-with-permit"><u>implemented correctly</u></a>, adding or removing roles and permissions can be a simple task, making it easier to support a growing number of users, roles, and resources efficiently.</p></div></li></ul><h2>RBAC: Cons</h2><ul><li><div><p><strong>Implementation complexity:</strong> While less complex than ABAC, RBAC can still be quite challenging to implement, especially in large and complex applications that require support for a large number of roles and users. Designing and implementing RBAC requires <strong>a thorough understanding of the application&#39;s requirements</strong> and the roles and permissions needed to support them. It is crucial to follow <a title="https://www.permit.io/blog/5-best-practices-for-building-cloud-native-permissions" href="https://www.permit.io/blog/5-best-practices-for-building-cloud-native-permissions"><u>established best practices</u></a> when doing so.</p></div></li><li><div><p><strong>Limited flexibility:</strong> As user access is defined solely by roles and <strong>not specific attributes</strong>, an RBAC system can quickly become insufficient when new, more granular access control requirements emerge. </p></div></li></ul><p>So how is ABAC any different? Let’s dive into it - <br></p><h2>What is ABAC</h2><p>While <strong>RBAC </strong>determines access based on predefined roles, <a title="https://www.permit.io/blog/what-is-abac" href="https://www.permit.io/blog/what-is-abac"><strong>Attribute Based Access Control (ABAC)</strong></a> is all about conditional <strong>attributes</strong>. These allow for a much more fine-grained way of managing access control. </p><p>Attributes can contain a vast number of parameters, such as a user’s role, security clearance, time of access, location of the data, current organizational threat levels, resource creation date or ownership, data sensitivity, etc.</p><p>For example, here’s an example of an ABAC policy in simple English - </p><p><strong>Employees </strong>that are based within the<strong> European Union</strong> can perform any action on a <strong>GDPR Protected</strong> <strong>Document</strong>.</p><p>The policy, as any authorization policy, can be divided into three parts:</p><p><strong>Who </strong>can perform which <strong>Action </strong>on which <strong>Resource </strong></p><p>In this example, the question ‘Who?’ can be answered by:</p><ol><li><div><p>Employees - a <strong>Role </strong></p></div></li><li><div><p>Based in the European Union - a <strong>User Attribute</strong></p></div></li></ol><p>The same goes for the Resource: </p><ol><li><div><p>Document - a <strong>Resource</strong></p></div></li><li><div><p>GDPR Protection - a <strong>Resource Attribute</strong></p></div></li></ol><img src="https://media.graphassets.com/lcH1kds3TUGzRavt3FsT" alt="Group 67691.png" title="Group 67691.png" width="1600" height="455" /><p>To learn more about<strong> ABAC and its implementation methods</strong>, <a title="https://www.permit.io/blog/what-is-abac" href="https://www.permit.io/blog/what-is-abac"><u>check out this guide</u></a>. </p><p>ABAC provides us with the ability to create highly granular, complex, and detailed authorization policies, which can be based on varying user and resource attributes. <br></p><h2>ABAC: Pros </h2><ul><li><div><strong>Fine-grained: </strong>ABAC provides the ability to create extremely fine-grained access control policies with its use of attributes. This becomes an ever-growing requirement as policies for billing (e.g. &quot;only users who paid for a feature can use it&quot;), location, time, trust level, quotas, anomaly, fraud, and risk profiles are becoming basic requirements.<br></div></li><li><div><strong>Highly Dynamic:</strong> It is very often that applications rely on abilities that have to be managed in a real-time fashion. If implemented <a title="https://www.permit.io/blog/introduction-to-opal" href="https://www.permit.io/blog/introduction-to-opal"><u>using the right tools</u></a>, ABAC can provide dynamic access control based on real-time changes in user/resource attributes. Perfect examples of this are the need for attributes such as time, a user’s geolocation, payment status, etc. </div></li></ul><h2>ABAC: Cons</h2><ul><li><div><strong>Complexity:</strong> ABAC can be<strong> a huge challenge to implement, manage, and maintain</strong>. Not only can it be very complex and time-consuming to design, but it&#39;s also an ongoing endeavor. <br><br>Authorization doesn’t stop at the point of implementation, and it needs to be managed and adapted to the needs of the application as it changes and grows. It is absolutely crucial to provide both your developers and relevant stakeholders with<strong> </strong><a title="https://www.permit.io/blog/what-is-abac#permit-a-ui-for-managing-abac%5C" href="https://www.permit.io/blog/what-is-abac#permit-a-ui-for-managing-abac%5C"><u><strong>an accessible way to manage and maintain their ABAC policies</strong></u></a>. <br></div></li><li><div><strong>Resource-intensive:</strong> As ABAC potentially requires taking a very large number of attributes into account, <strong>it can be very resource-intensive</strong>, requiring more processing power and time.<br></div></li><li><div><strong>Difficult to audit:</strong> ABAC can be difficult to audit because access control decisions are based on complex policies that may be difficult to understand. This challenge can be addressed by using an authorization service that allows <a title="https://docs.permit.io/features/audit-logs/types/" href="https://docs.permit.io/features/audit-logs/types/"><u><strong>easy access to audit logs</strong></u></a> for both RBAC and ABAC. </div></li></ul><p>Now that we have reviewed both policy models, how would we know which one is more suitable for our needs? </p><h2>Making a choice: RBAC vs. ABAC</h2><p>In short, the choice between the two depends on the needs of your organization and the application you are building. </p><p>RBAC provides a rather simple solution for determining authorization: Only a person with the <strong>role </strong>of X can perform <strong>action </strong>Y on <strong>resource </strong>Z. It’s simple and is usually sufficient for most organizations.<br><br>While keeping things rather simple, RBAC lacks flexibility as user access is defined solely by roles and <strong>not specific attributes.</strong><br><br>ABAC provides a more in-depth approach, allowing you to add attributes into the mix and create much more granular, dynamic access control. That being said, ABAC can require more processing power and implementation time - so it&#39;s important to strike a balance so your authorization policy is neither too simplistic nor too complex.</p><p>In many cases,<strong> RBAC and ABAC can be used together hierarchically</strong>, with broad access enforced by RBAC protocols and more complex access managed by ABAC. Organizations often start by implementing their own RBAC and then gradually evolve it into ABAC as additional attributes are required. When dynamic data points such as time, location, billing status, and current behavior come into effect - <strong>ABAC is unavoidable</strong>. </p><p>If <strong>implementing </strong>and <strong>maintaining </strong>authorization wasn’t complex enough, creating a structure that allows you to <strong>switch from one model to another</strong> or <strong>use them together </strong>can be even more daunting. An easy solution to this complexity is picking an <a title="https://www.permit.io/blog/choose-an-authz-service" href="https://www.permit.io/blog/choose-an-authz-service"><u>authorization solution</u></a> that <a title="https://www.permit.io/blog/5-best-practices-for-building-cloud-native-permissions" href="https://www.permit.io/blog/5-best-practices-for-building-cloud-native-permissions"><u>adheres to authorization best practices</u></a> and is <strong>flexible and accessible.</strong><br></p><h2>Scalable Implementation</h2><p>Authorization requirements tend to grow exponentially along with the application. The requirement to shift from hardcoded Admin / Not admin rules into RBAC and ABAC can happen extremely fast. As various requirements from customers, security, compliance, and 3rd party integrations come in, you might need to <strong>refactor your entire authorization system every 3-6 months</strong>.</p><p>Setting up a system as complex as ABAC could take months of work, which doesn’t end at the point of implementation - as creating additional roles, attributes, and policies requires <strong>complex R&amp;D work and steep learning curves</strong>. </p><p>This creates a situation where <strong>developers become bottlenecks in your app’s permission management</strong>, other<strong> stakeholders are locked out of the conversation</strong>, and your <strong>customers are left without the flexibility they require</strong>. </p><p>The solution is implementing and managing your RBAC and ABAC policies using an authorization service that allows for<strong> flexible transition between authorization models</strong> and provides <strong>a simple no-code UI</strong> that makes permission management accessible to other stakeholders. <br><br>That’s where Permit comes in - <br></p><h2>Permit - RBAC and ABAC with a no-code UI</h2><p>Permit provides developers with a permission management solution that allows for both <strong>smooth transitioning from RBAC to ABAC</strong>, and the ability to create and manage policies using <strong>an accessible no-code UI</strong>. </p><p>Permit’s UI generates<strong> Rego code</strong> for both <a title="https://www.permit.io/blog/implement-rbac-using-opa" href="https://www.permit.io/blog/implement-rbac-using-opa"><u>RBAC</u></a> and <a title="https://www.permit.io/blog/implement-abac-using-opa" href="https://www.permit.io/blog/implement-abac-using-opa"><u>ABAC</u></a> (See links for code examples), wrapping it nicely into Git, and API / UI interfaces which you can edit, add to, and manage however you like.</p><p>This allows both developers and other stakeholders to set up RBAC policies and add complex attributes and conditions - all without having to write a single line of code. </p><img src="https://media.graphassets.com/LGXMhn9QFGYxwSUhYWRd" alt="pasted image 0.png" title="pasted image 0.png" width="649" height="202" /><p></p><img src="https://media.graphassets.com/8dmqmNLVRyaVDRiWScRL" alt="pasted image 0 (1).png" title="pasted image 0 (1).png" width="649" height="154" /><p></p><img src="https://media.graphassets.com/GuVrkR6tQeGdiETElLXp" alt="pasted image 0 (2).png" title="pasted image 0 (2).png" width="632" height="528" /><p><em>Setting up an ABAC policy with Permit&#39;s UI is as easy as checking a box </em><br><br>Implementing authorization with Permit ensures that everyone is included in the permission management process, <strong>preventing developers from becoming bottlenecks while also allowing a smooth transition between RBAC and ABAC</strong>.</p><p>Want to learn more about Authorization? Join our <a title="https://io.permit.io/permitslack" href="https://io.permit.io/permitslack"><u>Slack community</u></a>, where there are hundreds of devs building and implementing authorization.</p>]]></content>
        <author>
            <name>Daniel Bass</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[How to Add RBAC Into a Next.JS Application]]></title>
        <id>how-to-add-rbac-in-nextjs</id>
        <link href="https://www.permit.io/blog/how-to-add-rbac-in-nextjs"/>
        <updated>2023-03-09T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Learn how to implement RBAC in Next.js applications with Permit.io, a permission management system. Follow a step-by-step guide in a to-do app.]]></summary>
        <content type="html"><![CDATA[<h2>Introduction</h2><p>As web applications become increasingly complex, ensuring that users have the appropriate level of access to the application&#39;s features and data is crucial. Without a well-defined access control system, it&#39;s easy for unauthorized users to access sensitive information or perform harmful actions.</p><p><strong>Next.js</strong> is a popular framework for building server-side rendered web applications quickly and efficiently. However, implementing a robust permission management system can be a daunting task. Permit.io provides an end-to-end solution for managing permissions and roles for users with a simple, intuitive UI.</p><p>This tutorial will guide you through building a permission management system into a Next.js application using Permit.io. We&#39;ll do this by creating a simple to-do application that includes a robust permission model derived from permissions you can easily set using Permit&#39;s UI. By the end of this tutorial, you&#39;ll have a solid understanding of <strong>how to implement a well-defined permission management system in your Next.js application</strong>.</p><p>Before we dive in, it&#39;s important to note that this article assumes you have a basic knowledge of JavaScript, React, and Next.js. If you need to brush up on those skills, we recommend checking out some beginner-friendly resources:</p><p><a title="https://www.freecodecamp.org/news/learn-javascript-free-js-courses-for-beginners/" href="https://www.freecodecamp.org/news/learn-javascript-free-js-courses-for-beginners/"><u>Learn JavaScript – a curriculum and interactive course</u></a></p><p><a title="https://reactjs.org/community/courses.html" href="https://reactjs.org/community/courses.html"><u>Learn React - a full course</u></a></p><p><a title="https://www.freecodecamp.org/news/the-next-js-handbook/" href="https://www.freecodecamp.org/news/the-next-js-handbook/"><u>Learn Next.js - a full handbook</u></a></p><p>With that said, let&#39;s get started!</p><h2>Setting up the Next.js project</h2><p>To get started, let&#39;s create a new Next.js project. To save you time and as you already understand the basics of Next.JS, we already have a starter project set up where you&#39;ll find the simple to-do app we’ll be using in this tutorial.</p><ol><li><div><p>First, make sure you have <strong>Node.js</strong> and <strong>npm </strong>installed on your machine. You can download them from the official Node.js website:<a title="https://nodejs.org/en/" href="https://nodejs.org/en/"><u> https://nodejs.org/en/</u></a>.</p></div></li><li><div><p>Open a terminal window and create a new Next.js project using the following command:<br><br><code>⁠npx create-next-app@latest permit-todo --use-npm --example https://github.com/permitio/permit-next-todo-starter next-tutorial &amp;&amp; cd permit-todo<br></code><br>This will create a new Next.js project with the default settings.</p></div></li><li><div><p>Once the project is created, navigate to the project directory by running:<br><br><code>cd permit-todo</code></p></div></li><li><div><p>Next, let&#39;s add the necessary dependencies. We&#39;ll need the <strong>permitio </strong>package to enable permission management using Permit. Run the following command to install this package:<br><br><code>npm install permitio --save<br></code><br>This package provides the necessary tools to implement permissions easily into the API layer in your Next.js application.</p></div></li></ol><p>With the project set up and the necessary dependencies installed, let’s go over the todo application’s code.</p><h2>To-Do Application Code Overview</h2><p>One of the advantages of Next.JS is the ability to write server-side code as part of a UI application. This way, we can easily enforce the permission model even if our backend does not support it yet.</p><p>Let&#39;s break it down into the pages/api/tasks.ts file containing an API route handler that enables the creation, retrieval, updating, and deletion of tasks in memory.</p><p>First, we define a Task interface that describes the shape of our task objects. Each task has a <em>text </em>property (a string) and an <em>isCompleted </em>property (a boolean).</p><pre><code>export type Task = {
 text: string,
 isCompleted: boolean,
}</code></pre><p>Then, we define a Response interface that describes the shape of our API response messages. Each response has a message property (a string).</p><pre><code>type Response = {
  message: string,
}    </code></pre><p>Next, we create an array of tasks representing our in-memory data store. We initialize it with three sample tasks.</p><pre><code>const tasks: Task[] = [
  {
    text: &#39;Learn Next.js&#39;,
    isCompleted: true,
  }, {
    text: &#39;Learn React.js&#39;,
    isCompleted: false,
  }, {
    text: &#39;Learn ReactNative&#39;,
    isCompleted: false,
  },
];</code></pre><p>After that, we define an asynchronous request handler function handler that takes in a Next.js NextApiRequest object and a NextApiResponse object.</p><pre><code>export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse&lt;Task | Task[] | Response&gt;
) {</code></pre><p>We use a switch statement inside the handler function to handle different HTTP methods. We will have a short code for each one that will create, read, update, or remove the data sent from the frontend application in the array we initialized out of the function.</p><pre><code>...
switch (req.method) {
  case &#39;POST&#39;: {
    tasks.push(req.body);
    res.status(200).json(req.body);
    break;
  }
...</code></pre><p>To complete the application, we also created a simple UI for the application that you can find in the index.tsx file. Since we are not focusing in this article on the authorization feature toggling in the frontend, we will not go in-depth through the code there.</p><p>Let&#39;s execute <code>npm run dev</code> to view our to-do application in a browser running on our local machine.</p><p>As you can see in the application, we have a fully-functional to-do application. We can list the tasks, create, and update by clicking on the task text and marking them as completed.</p><p></p><img src="https://media.graphassets.com/oQXMhr2HRAmSSfCmRzx3" alt="todo_ap.png" title="todo_ap.png" width="1050" height="600" /><p>Now that we have our application up and running, let’s add a permission management system to it!</p><h2>Defining a Permission Model</h2><p>Overall, the code snippet above provides a solid foundation for building a full-stack simple in-memory application. However, in a real-world scenario, a more sophisticated policy model is required to ensure the app&#39;s security. For instance, <strong>we may need to restrict certain user roles to specific actions</strong>, such as only allowing some users to view tasks while permitting others to mark them as complete, or defining that only administrators should be authorized to delete tasks.</p><p>To address these requirements, we will implement a<strong> Role-Based Access Control (RBAC)</strong> model. In this model, each user is assigned a <strong>role </strong>that determines the <strong>actions </strong>they can perform within the app. When enforcing this policy, we take into account the user&#39;s identity, role, and the action they are trying to perform (IRA) to make a decision about their authorization status.</p><p>To design our permission model, we need to identify the app&#39;s potential <strong>identities</strong>, <strong>roles</strong>, and <strong>resources</strong>. Using this information, we can create tables that outline the desired permissions for each role. This table will help us enforce the policy at various enforcement points in the application.</p><p></p><table><tbody><tr><td><p></p></td><td><p>Create</p></td><td><p>Update</p></td><td><p>Mark</p></td><td><p>Delete</p></td><td><p>Read</p></td></tr><tr><td><p>Admin</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td></tr><tr><td><p>Task</p></td><td><p>✔</p></td><td><p>✔</p></td><td><p>✔</p></td><td><p>✔</p></td><td><p>✔</p></td></tr><tr><td><p>Editor</p></td></tr><tr><td><p>Task</p></td><td><p>✔</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>✔</p></td></tr><tr><td><p>Moderator</p></td></tr><tr><td><p>Task</p></td><td><p></p></td><td><p>✔</p></td><td><p></p></td><td><p></p></td><td><p>✔</p></td></tr><tr><td><p>Roles…</p></td></tr></tbody></table><p><br>Understanding the Identity, Resource, and Action components of the enforcement point is crucial to ensure the authorization is done right. This will help us maintain the security of our app.</p><h2>Use Permit to Configure the IRA Table</h2><p>To simplify the RBAC implementation process and avoid creating complex, intertwined code within the application, Permit offers a decoupled policy that enables effortless checks to be added where needed. Permit also provides an SDK for easy integration into the application. To get started with configuring permissions, log in to <a title="https://app.permit.io" href="https://app.permit.io"><u>app.permit.io</u></a></p><p>Once you have logged in, we can proceed to create appropriate resources and actions for our IRA design. At present, we have only one resource named &quot;Task.&quot; To maintain simplicity, we will utilize the same HTTP methods that we intend to use in our application for these actions.</p><ol><li><div><p>Go to the <strong>Policy </strong>page and click  Create &gt; Resource</p></div></li><li><div><p>Create the following resource and actions:<br></p><img src="https://media.graphassets.com/Afs0IeB5SjCriKsyXD53" alt="Frame 68089.png" title="Frame 68089.png" width="1437" height="778" /></div></li></ol><p>Next, we will discuss our identities and their roles. For that, we will first create different roles in our application.</p><ol><li><div><p>Go to the <strong>Policy </strong>page and click Create &gt; Role</p></div></li><li><div><p>Add the following roles<br></p><img src="https://media.graphassets.com/Xvfs8lbyT626o2nhYG0Q" alt="Frame 68088 (1).png" title="Frame 68088 (1).png" width="1437" height="778" /></div></li></ol><p>To complete our identities, we need to create users in the system. In the real world, we may use our identity management APIs to sync users with Permit, but for now, let&#39;s just add one user per role.</p><ol><li><div><p>Go to the <strong>Users </strong>screen</p></div></li><li><div><p>Create one user per role</p><img src="https://media.graphassets.com/qRrGkTkSYmZVQwtUXR4y" alt="users.png" title="users.png" width="1600" height="450" /></div></li></ol><p>Now that we have configured our IRA table, Permit will do all the rest for us by running a <a title="https://docs.permit.io/concepts/pdp" href="https://docs.permit.io/concepts/pdp"><u><strong>policy decision point (PDP)</strong></u></a> in the cloud. This way, we will have a web address that we can call to get the policy decision on each point we would like to enforce the policy we just set. Later in production, we will want to use a local container. This is important in order to avoid latency every time someone calls an endpoint. Permit supports this option, and you can find more details on it on the <strong>Connect </strong>page.</p><h2>Check Permissions with the Permit SDK</h2><p>The Permit SDK empowers us to verify permission decisions in our IRA table through an asynchronous function invocation. In order to confirm whether our administrator possesses the </p><p>authorization to execute a GET operation, we shall consult the SDK as follows:</p><pre><code>permit.check(‘admin@todo.app’, ‘get’, ‘Task’)</code></pre><p>For our application, which showcases distinct roles within a brief list of users, this straightforward verification employs a hard-coded email. However, in a production environment, we would want to utilize JWTs (or any other auth token) belonging to our authenticated users instead of relying on hard coded emails. The implementation of tokens will also facilitate the proper transmission of roles, thereby decoupling the verification from the identity and roles configuration.</p><p>Since we already installed the <em>permitio </em>SDK at the beginning of the tutorial, we don’t need to install any other dependencies. We are ready to go and implement the permissions in the handler.</p><h2>Add Permissions Checks to the Tasks Handler</h2><h5>1. Get an API Key</h5><p>The <em>permitio </em>SDK provides us with a simple way to make API calls. It does so by initializing a Permit instance once with the API key of our Permit account, and makes all the calls (and other API requests) by using this key. To grab your account key, go to the <strong>Project </strong>page, and, within your relevant environment (if it is a new account, it’ll be Default/Production), click the three dots and <strong>Copy the API Key</strong>.</p><img src="https://media.graphassets.com/0aCsTw4YSmWvEa1p5vZG" alt="saveAPI.png" title="saveAPI.png" width="1600" height="898" /><h5>2. Store the API Key in the Application</h5><p>To prevent the unintentional pushing of this confidential key to a remote repository, it is important to <strong>employ it as an environment variable within a file that git ignores</strong>. Subsequently, generate a fresh file in the primary directory named .env.local and insert the KEY=value snippet there:</p><pre><code>PERMIT_SDK_KEY=&lt;your_copied_sdk_key&gt;</code></pre><p>Now it’s time to initialize our Permit instance. Since we are just giving an example we will do it in the tasks.ts file. In a real application we will want to make it available globally for all the handlers so they will consume it without reinitializing it.</p><pre><code>import { Permit } from &#39;permitio&#39;;

const permit = new Permit({
  // We’ll use a cloud hosted policy decision point
  pdp: &quot;http://cloudpdp.api.permit.io/&quot;,
  // The secret token we got from the UI
  token: process.env.PERMIT_SDK_TOKEN,
});</code></pre><h5>3. Add a Permission Check</h5><p>Since we have already invoked our resources in the method name, we can perform a check for all handler operations in one centralized location. Navigate to our tasks.ts file and insert the ensuing code snippet, which first verifies the user&#39;s existence in the headers (authentication) and then incorporates the &quot;magic&quot; permit check function for authorization:</p><p></p><pre><code>const { user } = req.headers;
if (!user) {
  res.status(401).json({ message: &#39;unauthorized&#39; });
  return;
}

const isAllowedForOperation = await permit.check(user as string, req.method?.toLowerCase() as string, &#39;Task&#39;);
if (!isAllowedForOperation) {
  res.status(403).json({ message: &#39;forbidden&#39; });
  return;
}</code></pre><h5>4. Add a User to the API Calls</h5><p>Now, when we return to the application view in the browser we will see there are no visible tasks in the UI. This is because we have to add the user in our API call. Let’s do it in the index.tsx file, add the following code in the fetch config at the api function.</p><pre><code>const req: RequestInit = {
  method,
  headers: {
    &#39;Content-Type&#39;: &#39;application/json&#39;,
    user: &#39;admin@permit-todo.app&#39;
  },
};</code></pre><p>Go back to the UI - you can now see that tasks can be listed, yet any other operation will fail with a ‘forbidden’ response. If you go back to the code and change it to admin@permit-todo.app, try to remove a task and see the magic happen 🙂</p><p>As we said already, now it looks a bit frustrating to manually replace the user for each test, but the real app will just get the authenticated user instead. Happy permissioning!</p><h2>What Next?</h2><p>Congratulations! By using Permit, you just successfully implemented role-based access control (RBAC) into a Next.js application. This tutorial taught us how to set up and configure Permit to secure the application and control user access based on their roles.</p><p>By implementing RBAC, you can improve the security of your application and restrict user access to the features and resources they should be allowed to access. This is crucial in protecting your application from unauthorized access and data breaches.</p><p>Now that you have implemented RBAC into your application, you can improve your applications&#39; security by leveraging it to real use cases in your application and even use some advanced features in Permit, such as <a title="https://www.permit.io/blog/what-is-abac" href="https://www.permit.io/blog/what-is-abac"><u><strong>ABAC (Attribute-based access control)</strong></u></a>, <a title="https://www.permit.io/elements" href="https://www.permit.io/elements"><u><strong>Elements</strong></u></a>, <a title="https://www.permit.io/blog/gitops-today-why-and-how" href="https://www.permit.io/blog/gitops-today-why-and-how"><strong>GitOps</strong> </a>features for complex policy definitions, and many more.<br><br>Want to learn more about implementing authorization? Got questions? Reach out to us in our <a title="https://io.permit.io/permitslack" href="https://io.permit.io/permitslack">Slack community</a>. </p>]]></content>
        <author>
            <name>Gabriel L. Manor</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Building and Testing App Permissions with Cypress]]></title>
        <id>testing-app-permissions-with-cypress</id>
        <link href="https://www.permit.io/blog/testing-app-permissions-with-cypress"/>
        <updated>2023-03-08T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Learn how to build & test app permissions with our Cypress tutorial. Improve your app's security & user experience. Start coding now!]]></summary>
        <content type="html"><![CDATA[<h2>Intro</h2><p>Handling permissions properly is a crucial part of every application. Whether you are developing a mobile app, API service, or infrastructure servers, you want to avoid finding yourself with a user who can perform an operation they are not allowed to.</p><p>Permission management is a critical component of developing secure and functional applications. By implementing one of the permissions models, such as <a title="https://www.permit.io/blog/rbac-with-permit" href="https://www.permit.io/blog/rbac-with-permit"><u>Role-Based Access Control (RBAC) </u></a>or <a title="https://www.permit.io/blog/what-is-abac" href="https://www.permit.io/blog/what-is-abac"><u>Attribute-Based Access Control (ABAC)</u></a> in applications, we ensure that only authorized users can access specific resources and features.</p><p>In this article, we&#39;ll show you how to build a resilient permission model in a to-do application by using Permit.io as the authorization as a service solution and Cypress to verify the end-to-end functionality and reliability of the model. We chose this combination of tools mainly due to their popularity in their respective categories, and their custom code minimal footprint.</p><h2>Setting up a demo project</h2><p><em>This tutorial assumes that you have installed a </em><a title="https://nodejs.org/en/download/" href="https://nodejs.org/en/download/"><u><em>Node/npm environment </em></u></a><em>and </em><a title="https://docs.docker.com/get-docker/" href="https://docs.docker.com/get-docker/"><u><em>Docker</em></u></a><em> on your machine</em></p><p>To demonstrate our solution, we will create a NextJS starter project in our local environment and build a classic to-do application. As part of our project, we already created a starter template that includes a basic todo app. Run the following command in your main development folder to get it on your local machine.</p><p>npx create-next-app@latest permit-todo --use-npm --example https://github.com/permitio/permit-next-todo-starter cypress-tutorial &amp;&amp; cd permit-todo</p><p>Once the command has finished installing, open your preferred code editor in this folder, and let&#39;s see what we got.</p><p>This application starts with a small backend handler that will be responsible for Create, Read, Update, Delete, and Patch tasks. It can be found in the <code>pages &gt; api</code> folder in <code>tasks.ts</code>, a fairly simple file that is responsible for all the operations in one handler function.</p><p>A single file frontend uses the API to display tasks on the other side of the app. Users can perform CRUD operations and mark tasks as completed using this app. The code can be found under the pages folder in a file called <code>index.tsx</code></p><p>Now lets run npm run dev and view our todo application in the browser running on our local machine.</p><h2>Permissions Model</h2><p>The basic to-do app has no policy or permission model, meaning anyone can do anything. However, in a real-world scenario, we need things to act differently with a strict policy to protect the app. For example, we need a policy like: some user roles may only be able to view tasks, while others may also mark them as complete, and only administrators are allowed to delete tasks.</p><p>To begin, we will implement one of the simplest permission models, Role Based Access Control (aka RBAC). In RBAC, we assign roles to each identity that uses our app and according to this role, get a policy decision on what they can do in the application.</p><p>While enforcing policy, we analyze three dimensions that help us make a policy decision on the desired permissions model. These dimensions are Identity, Role, and Action (IRA). To design the permission model in our application, we will look at the enforcement points (where we enforce the policy decisions), and use these three dimensions to create the model.</p><p>We need to know the app&#39;s potential Identities, Roles, and Resources to create the model. It is easiest to create a simple table with the desired permissions.</p><table><thead><tr><th><p>Action 👉</p><p>Resource 👇</p></th><th><p>Create</p></th><th><p>Update</p></th><th><p>Mark</p></th><th><p>Delete</p></th><th><p>Read</p></th></tr></thead><tbody><tr><td><p>Task</p></td><td><p>Admin</p><p>Editor</p></td><td><p>Admin</p><p>Moderator</p></td><td><p>Admin</p><p>User</p></td><td><p>Admin</p></td><td><p>Admin</p><p>Moderator</p><p>Editor</p><p>User</p></td></tr></tbody></table><p>Understanding the Identity, Resource, and Action components of the enforcement point (the actual application where we ask for permission decisions) is helpful before testing these permissions. As a result, we can develop tests that verify that authorization is performed correctly for each role, ensuring that our to-do app&#39;s tasks are private and secure.</p><h2>Configuring Permissions</h2><p>When starting with simple RBAC, the typical approach is to write a simple code that gets the decision. It could work, but it has some problems. The main one is when we want to grow, and the RBAC code quickly becomes a spaghetti code in the application. Saas authorization services, such as Permit.io, solve this problem by decoupling the policy from the code and letting you add effortless checks where you need them in the code.</p><p>Permit.io also provides an SDK for easy implementation in the application, and their basic plan is free. Let’s start by log in to their application at app.permit.io to start configuring the permissions.</p><p>After you logged in we could start create relevant resources and actions for our IRA design. For now, there is only one resource, called Task. To keep things simple, we&#39;ll just use the HTTP methods we&#39;ll use in our application for the action.</p><ol><li><div><p>Go to the Policy page and click Create &gt; Resource</p></div></li><li><div><p>Create the following resource and actions.</p><img src="https://media.graphassets.com/resize=width:1437,height:778/Afs0IeB5SjCriKsyXD53" alt="create resource and actions" title="Frame 68089.png" width="1437" height="778" /></div></li></ol><p>Next, we will discuss our identities and their roles. For that we will first create different roles in our application.</p><ol><li><div><p>Go to Policy page and click Create &gt; Role</p></div></li><li><div><p>Add the following roles⁠<br></p><img src="https://media.graphassets.com/resize=width:1437,height:778/Xvfs8lbyT626o2nhYG0Q" alt="create roles" title="Frame 68088 (1).png" width="1437" height="778" /></div></li></ol><p>To complete our identities, we need to create users in the system. In the real world, we may use our identity management APIs to sync users with Permit, but for now, let&#39;s just add one user per role.</p><ol><li><div><p>Go to Users screen</p></div></li><li><div><p>Create one user per role</p><img src="https://media.graphassets.com/resize=width:1600,height:450/qRrGkTkSYmZVQwtUXR4y" alt="Users table" title="users.png" width="1600" height="450" /></div></li></ol><p>Now that we have configured our IRA table, we need to initialize the Policy Decision Point container. Our container is meant to be used as a lean decision point that can be used alongside any of our applications. As of now, it will run locally. Go to Permit&#39;s <code>Connect</code> page. This page shows the command that needs to be executed on the local machine. Let&#39;s run it and see if it works.</p><h3>Implement Permission Checks</h3><p>Permit&#39;s official SDK is the recommended way to integrate Permit into an application. In Nodejs we can install it by running:</p><pre><code>npm install –save permitio</code></pre><p>You can get the permit SDK key from the website by going to the Projects page and choose the Copy API Key option from the three dots menu.</p><img src="https://media.graphassets.com/0aCsTw4YSmWvEa1p5vZG" alt="saveAPI.png" title="saveAPI.png" width="1600" height="898" /><p>To avoid mistakenly pushing this secret key to a remote repository, we&#39;ll use it as an environment variable on a file that&#39;s ignored by git. Then create a new file in the main directory called .env.local and paste the following <code>KEY=value</code> there:</p><pre><code>PERMIT_SDK_KEY=&lt;your_copied_sdk_key&gt;</code></pre><p>To make Permit SDK available for our checks, we will initialize the Permit SDK with our key. In an actual application, we will make it accessible globally, but for now, let’s add it to the top of the <code>tasks.ts</code> file so we can use it in the APIs. Paste the following code just below the imports.</p><pre><code>import { Permit } from &#39;permitio&#39;;

const permit = new Permit({
  // We’ll use a cloud hosted policy decision point
  pdp: &quot;http://cloudpdp.api.permit.io/&quot;,
  // The secret token we got from the UI
  token: process.env.PERMIT_SDK_TOKEN,
});</code></pre><p>Permit&#39;s SDK enables us to check for specific rules in our IRA table using an async function call. To check if our admin is allowed to perform a GET operation, we will ask the SDK:</p><pre><code>permit.check(‘admin@todo.app’, ‘get’, ‘Task’)</code></pre><p>This simple check uses a hard-coded email because our application demonstrates specific roles in a short list of users. In production, we will use our authenticated users&#39; JWT (or any other auth token) instead of just emails. Using tokens also helps us send the right roles to decouple the check from the identity and roles config.</p><p>Having already called our resources in the method name, we can check for all handler operations in one place. Let&#39;s go to our <code>tasks.ts</code> file and paste the following code that will first check for the user’s existence in the headers (authentication) and then adds the permit “magic” check function for authorization:</p><pre><code>const { user } = req.headers;
if (!user) {
  res.status(401).json({ message: &#39;unauthorized&#39; });
  return;
}

const isAllowedForOperation = await permit.check(
  user as string,
  req.method?.toLowerCase() as string,
  &#39;Task&#39;
);
if (!isAllowedForOperation) {
  res.status(403).json({ message: &#39;forbidden&#39; });
  return;
}
</code></pre><p>Now, when we will return to the application and choose a different user than admin we will see the relevant permission restrictions take effect as a result of the permit’s check that we implemented.</p><p>Try to choose any user who is not an admin,and create a task to see the full power of Permit. Did you see what happened? That&#39;s right, you&#39;ve been blocked. What happens if you change the user to editor@permit-todo.app? You got it, right? :) </p><h2>Add Tests</h2><p>In order to ensure continuous stability of our permission model, it is time to add tests that verify that any code changes will not break it. Assuming we have some tests on the backend for the IRA functionality, it&#39;s time to conduct an end-to-end test, and we&#39;ll be using Cypress for this.</p><p>It&#39;s okay if you&#39;ve never encountered Cypress before. You can test our application by running npm run cypress:open since we have already set up the testing environment in the starter project. In any case, we highly recommend taking a quick glance at their <a title="https://docs.cypress.io/guides/end-to-end-testing/writing-your-first-end-to-end-test" href="https://docs.cypress.io/guides/end-to-end-testing/writing-your-first-end-to-end-test"><u>getting-started</u></a> guide to understand the general concepts.</p><p>Client side e2e tests are critical to ensure the complete flows are working as expected. This is both from the client side, where partial permissions enforcement is often present (as in our app, we only show errors but do not limit views) as well as how we connect the backend flow and enforcement to our frontend screen. During permissions testing, we want them to ensure that no permissions are broken.</p><h2>Add a Test for Every Occasion</h2><p>Since our simple application focuses on the impersonation feature that helped us demonstrate Permit.io’s permissions model, we can go directly on to the permissions testing we would like to perform.</p><p>To create a habit of constantly verifying permissions, let’s start with creating a file called <code>cypress/e2e/permissions.cy.ts</code> as a centralized place where we verify the proper permissions for each user.</p><p>By looking at this file, you can see that we created an iteration for each kind of user we have in our application and verified the CRUD operations they can do. For the example below, we are running verification that a Moderator can only edit tasks but not create them:</p><pre><code>// Try to fail in add task
addTask(&#39;Learn Cypress and Next.js&#39;);
cy.contains(&#39;forbidden&#39;).should(&#39;exist&#39;);
cy.get(&#39;[data-testid=&quot;CloseIcon&quot;]&#39;).parent().click();
cy.contains(&#39;Learn Cypress and Next.js&#39;).should(&#39;not.exist&#39;);

// Try to edit task
editTask(&#39;Learn Cypress&#39;, &#39;Learn Cypress and Next.js&#39;);
cy.contains(&#39;Learn Cypress and Next.js&#39;).should(&#39;exist&#39;);</code></pre><p>Now that we have this file, we can always refer our developers to it; and create permission verifying tests for every occasion. We could also add it to the code-review process and verify that every code change related to permissions has a proper test case in the <code>permissions.cy.ts</code> file.</p><p>Here is a recording example of the complete impersonation tests:</p><video controls width="undefined" height="undefined">
          <source src="https://media.graphassets.com/ejnDGkMdT0mZB94PzVST" type="video/mp4" title="spec.cy.ts.mp4" />
          Sorry, your browser doesn't support embedded videos.
        </video><h2>Next Steps: Cypress Commands</h2><p>One of the features I like the most in  Cypress is <a title="https://docs.cypress.io/api/cypress-api/custom-commands" href="https://docs.cypress.io/api/cypress-api/custom-commands"><u>Commands</u></a>, a small and granular test logic that we can access from anywhere to perform and verify repetitive application behavior.</p><p>To make our tests even better and more robust, we could create a bunch of authorization Cypress commands so our users could perform permission behavioral checks from anywhere. Look at the following code, for example:</p><pre><code>// This command verify that the error message is displayed
// Run it from everywhere with cy.verifyForbiddenError()
const verifyForbiddenError = () =&gt; {
  cy.contains(&#39;forbidden&#39;).should(&#39;exist&#39;);
  cy.get(&#39;[data-testid=&quot;CloseIcon&quot;]&#39;).parent().click();
}</code></pre><p>In this command, we are verifying that an action performed by the user failed and they got a “forbidden” message. Just think of the simplicity of having it easily accessible from anywhere and letting developers make the relevant tests just in time.</p><p>This sample command is in our project&#39;s <code>/cypress/support/commands.ts</code> file.</p><h2>Conclusion</h2><p>In this article, we covered the process of implementing permissions into an example to-do application and testing it end-to-end using Cypress. By following these step-by-step instructions, you should now have a solid understanding of how to implement and verify that permissions are working correctly in your own applications.</p><p>Adding permissions is an essential component of building secure and user-friendly applications. By using Cypress for end-to-end testing, you can ensure that your application is functioning as expected and that user data is protected. With this knowledge, you have the tools to create robust and secure applications that meet the needs of your users.<br><br>Want to learn more about implementing authorization? Got questions? Reach out to us in our <a title="https://io.permit.io/permitslack" href="https://io.permit.io/permitslack">Slack community</a>. </p>]]></content>
        <author>
            <name>Gabriel L. Manor</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Building App Authorization: The 5 Keys for Scalability and Compliance]]></title>
        <id>building-app-authorization-the-5-keys-for-scalability-and-compliance</id>
        <link href="https://www.permit.io/blog/building-app-authorization-the-5-keys-for-scalability-and-compliance"/>
        <updated>2023-02-23T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[5 key factors for effective & scalable app authorization: simplicity, flexibility, compliance & more.]]></summary>
        <content type="html"><![CDATA[<p>As a software product becomes more successful and expands to a global market, the issue of authorization becomes increasingly important. There are several key factors to consider when building an effective and scalable authorization system that meets the needs of your product and its users. First, let&#39;s do a quick recap of what authorization is.</p><h2>What is Authorization (AuthZ)?</h2><p>Authorization is the process of granting or denying access to specific resources based on a user&#39;s verified identity.  Authorization is often done by assigning roles or permissions to specific users or user groups. <br><br>Authorization is managed through <strong>policies </strong>- sets of rules that determine what actions or resources a user or system is allowed to access. Common policy models include⁠ <a title="https://www.permit.io/blog/rbac-with-permit" href="https://www.permit.io/blog/rbac-with-permit"><u>Role Based Access Control (RBAC)</u></a>, <a title="https://www.permit.io/blog/what-is-abac" href="https://www.permit.io/blog/what-is-abac"><u>Attribute Based Access Control (ABAC)</u></a>, and <a title="https://www.permit.io/blog/what-is-rebac" href="https://www.permit.io/blog/what-is-rebac">Relationship-Based Access Control (ReBAC)</a>.</p><p>When building a scalable and compliant authorization system, there are five crucial points to consider. </p><h2>Simplicity is key</h2><p>Simplicity and Maintenance are crucial to building an effective authorization system. Complex, inconsistent authorization logic spread across the codebase can <strong>and will </strong>be difficult to maintain and can potentially cause significant issues down the line. It is important to balance flexibility and simplicity to ensure the system is easy to maintain and update. One best practice that can help to achieve this is the <a title="https://www.permit.io/blog/5-best-practices-for-building-cloud-native-permissions#the-5-best-practices" href="https://www.permit.io/blog/5-best-practices-for-building-cloud-native-permissions#the-5-best-practices"><u><strong>decoupling policy and code</strong></u></a>.</p><h2>Flexibility and Customization</h2><p>As the product matures and the customer base becomes more diverse, the authorization system there may need more flexibility and customization. This could include:</p><ul><li><div><p>Creating <a title="https://docs.permit.io/features/policy-editor/editor-overview" href="https://docs.permit.io/features/policy-editor/editor-overview"><u><strong>a user-friendly interface</strong></u></a> for managing authorization. It&#39;s important to remember that your fellow stakeholders (e.g., product managers, security teams, compliance, support, or sales) might need to create authorization policies. The better you can delegate this ability to them, the less of a bottleneck the developer becomes. </p></div></li><li><div><p>Making permission decisions based on time context, such as a user&#39;s assigned package limits. This can be achieved by implementing <a title="https://www.permit.io/blog/what-is-abac" href="https://www.permit.io/blog/what-is-abac"><u><strong>attribute-based access control</strong></u></a> (ABAC) policies.</p></div></li></ul><h2>International Data Protection Regulations and Compliance</h2><p>As the product expands to a global market, it is important to consider international data protection regulations and compliance issues. Different regions may have different requirements for data storage and access, and it is essential to ensure that the authorization system is compliant with these regulations. An excellent place to start is <a title="https://docs.permit.io/concepts/control-plane-and-data-plane/" href="https://docs.permit.io/concepts/control-plane-and-data-plane/"><u><strong>decoupling data from policy</strong></u></a> - decoupling the data plane from the control plane provides the best combination of security, scale, stability, and cost management.</p><h2>External Partners and Integrations</h2><p>As the product grows, there may be a need to support external partners and integrations. This may require providing access to certain resources and actions while still maintaining control over the data and the overall system. It’s crucial to maintain control over role creation, permissions, and conditions with ease - having the granular control needed for any integration. </p><h2>Scalability</h2><p>As the user base grows, it is important to consider the scalability of your authorization system. The system should be able to handle a large volume of requests without failing, and it should be able to adapt to the changing requirements of the user needs.<br></p><p><a title="https://www.permit.io/" href="https://www.permit.io/"><u>Permit.io</u></a> can help streamline the process of building an authorization system for your software product and provide a comprehensive, scalable, and compliant access control solution.</p>]]></content>
        <author>
            <name>Daniel Bass</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[How to build authorization like Netflix with Open Source?]]></title>
        <id>netflix-authz</id>
        <link href="https://www.permit.io/blog/netflix-authz"/>
        <updated>2023-02-19T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[How Netflix solved the challenge of authorizing millions of users by using OPA, how you can adopt this solution, and possibly create something even better]]></summary>
        <content type="html"><![CDATA[<p><em>This blog is based on our video &quot;</em><a title="https://www.youtube.com/watch?v=zsYdGrdDoDE" href="https://www.youtube.com/watch?v=zsYdGrdDoDE"><em><strong>Build Authorization like Netflix with Open Source</strong></em></a><em>&quot;</em></p><p>Netflix has over 220 million active users and is worth over 100 billion dollars. With such an enormous user base, they are responsible for managing a vast amount of personal information. A big part of that is ensuring relevant people have the permissions required to access that information, while others do not. </p><p>How does Netflix handle the challenge of <strong>managing its authorization</strong>? Where does <strong>open-source</strong> come in? How can you adopt this solution? (Or build something <strong>even better</strong>) Let’s find out. </p><h2>With Great Power - </h2><p>In 1997, Netflix was little more than an upstart DVD rental company. Fast forward two decades, and Netflix has become one of the biggest TV and movie studios in the world. </p><p>As a company grows, the responsibility it has towards its customers grows as well, and security becomes increasingly important with every new user joining the platform. </p><p>The first challenge is authenticating users when they log into the system - that’s <strong>authentication</strong>. Once users are in the system, the second step is to decide what they have access to - that’s where <strong>authorization </strong>comes in. </p><img src="https://media.graphassets.com/qfzxt899TrGGwjPa8YAC" alt="spider-man-uncle-ben.gif" title="spider-man-uncle-ben.gif" width="498" height="266" /><p></p><h2>Why is authorization critical?</h2><p>Authorization (Not to be <a title="https://www.permit.io/blog/authn-vs-authz" href="https://www.permit.io/blog/authn-vs-authz"><u>confused with authentication</u></a>) is the process of managing access to <strong>resources</strong> based on a user&#39;s <strong>identity</strong> and the <strong>permissions</strong> assigned to that identity. This is typically done by comparing a user&#39;s credentials against a set of rules (policies) to determine what they are allowed to access.</p><p><strong>Authorization is crucial for Netflix</strong> - not only to make sure only paying customers have access to shows but also as <strong>a means of maximizing potential revenue</strong>. How you may ask? By being able to tailor shows based on specific countries or user interests, by offering purchasing power parity - adjusting their prices in accordance with income levels per country, and more.</p><p> </p><h2>Authorization is a complicated task</h2><p>Writing authorization policies is quite a complex task. To address this issue, Netflix chose <a title="https://www.permit.io/blog/introduction-to-opa" href="https://www.permit.io/blog/introduction-to-opa"><u>Open Policy Agent</u></a> (OPA) - an open-source general-purpose policy engine that unifies policy enforcement across the stack. </p><p>OPA provides a high-level declarative language called <strong>Rego </strong>that lets you write policy as code, along with a simple API to offload policy decision-making from your software (As pairing authorization logic with application logic <a title="https://www.permit.io/blog/four-mistakes-you-make-when-building-permissions#2-mixing-up-app-logic-and-authorization" href="https://www.permit.io/blog/four-mistakes-you-make-when-building-permissions#2-mixing-up-app-logic-and-authorization"><u>is a bad idea</u></a>). OPA can be used to enforce policies in microservices, Kubernetes, CI/CD pipelines, API gateways, and more.</p><p>The thing is - Rego is quite hard to master, thus limiting the ability to manage policies to a very small chunk of people. Netflix encountered a problem where <strong>very few people in the organization could actually write Rego policies</strong>, yet they wanted to distribute the ability to create and manage policies across the organization.</p><p></p><h2>How did Netflix solve its authorization problem? </h2><p>Netflix built a UI on top of OPA, which allowed them to create Rego policies and simplify the process. That solved the issue, but then another problem emerged:</p><p><strong>Once the policy was in place, did they actually capture its intent? <br></strong><br>They knew in plain English what they wanted to achieve with the policy, and they proceeded to define it in the UI, but they didn&#39;t know if it would actually perform. To solve this issue, Netflix ended up building <strong>unit-testing mechanisms</strong> for the UI. </p><p>You want a policy to be implemented in the system? Write it, write a test for it, and make sure that the test passes. Before you save and the policy change gets pushed, all the tests are run, and then, if they all pass, the changes get applied to production. Voila. </p><p>This allowed Netflix to create a solution on top of open-source components, saving them much of the effort it would take to build a homebrew authorization layer from scratch. Unfortunately - Netflix kept this solution to themselves, never exposing it to a wider audience.</p><p><em>A great video by the CNCF where Manish Mehta and Torin Sandall from Netflix tell the story of how Netflix solved authorization with OPA in much more technical depth:</em></p><img src="https://media.graphassets.com/8VXQHjJoTiCf3Wvo2MPw" alt="Screenshot_3.png" title="Screenshot_3.png" width="1903" height="1067" /><p><strong></strong><a title="https://www.youtube.com/watch?v=R6tUNpRpdnY" href="https://www.youtube.com/watch?v=R6tUNpRpdnY"><u><strong>How Netflix Is Solving Authorization Across Their Cloud [I] - Manish Mehta &amp; Torin Sandall, Netflix</strong></u></a></p><h2>How can I implement this solution? </h2><p>While Netflix never open-sourced their solution, the solution they built on top of OPA inspired another open-source project: <a title="https://github.com/permitio/opal" href="https://github.com/permitio/opal"><u>OPAL</u></a></p><p><a title="https://www.permit.io/blog/introduction-to-opal" href="https://www.permit.io/blog/introduction-to-opal">OPAL (Open Policy Administration Layer)</a> is an open-source administration layer for OPA that allows you to easily keep your authorization layer up-to-date in real time. As you push updates to your application&#39;s stores (e.g. Git, DBs, S3, SaaS services) OPAL will make sure your services are always in sync with the authorization data and policy they need.</p><p>A similar high-level architecture to Netflix&#39;s is expressed within OPAL: </p><p>The <strong>Aggregator </strong>is the OPAL server, the <strong>Distributor </strong>is the split between a server and a client, and the <strong>Updater </strong>is the OPAL client. <br></p><p></p><img src="https://media.graphassets.com/IgTngW0TGGVBXcURNZYo" alt="68747470733a2f2f692e6962622e636f2f43766d583872522f73696d706c69666965642d6469616772616d2d686967686c696768742e706e67.png" title="68747470733a2f2f692e6962622e636f2f43766d583872522f73696d706c69666965642d6469616772616d2d686967686c696768742e706e67.png" width="1997" height="945" /><p><br></p><p><em>You can learn more about OPAL’s architecture </em><a title="https://docs.opal.ac/overview/architecture" href="https://docs.opal.ac/overview/architecture"><u><em>here</em></u></a></p><p>Using this inspired approach allows OPAL to aggregate policy and data from different sources, and integrate them seamlessly into the authorization layer in real-time. The project is free and available to everyone as a public project and is already being used by companies like <strong>Tesla, Cisco, Palo Alto Networks, </strong>and <strong>Walmart</strong>. </p><p>If you want to go even further, <a title="https://www.permit.io/" href="https://www.permit.io/"><u>Permit.io</u></a> provides a no-code UI that allows you to create, manage, and enforce Rego policies and is based on <a title="https://www.permit.io/blog/opal-opa-vs-xacml" href="https://www.permit.io/blog/opal-opa-vs-xacml"><u>a combination of OPA and OPAL</u></a>. Allowing you to implement complex RBAC and ABAC policies into your application, and manage them with a simple UI anyone in your organization can use.</p><h2>Help OPAL grow </h2><p>OPAL is an ongoing open-source project which is already keeping hundreds of policy agents updated in real-time. You can join <a title="https://io.permit.io/permitslack" href="https://io.permit.io/permitslack"><u>OPAL’s Slack community </u></a>to chat with other devs who use OPAL for their projects, <a title="https://github.com/permitio/opal" href="https://github.com/permitio/opal"><u>contribute to the open-source project</u></a>, or <a title="https://twitter.com/opal_ac" href="https://twitter.com/opal_ac"><u>follow OPAL on Twitter</u></a> for the latest news and updates.</p>]]></content>
        <author>
            <name>Daniel Bass</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Authentication vs. Authorization: Understanding the Difference]]></title>
        <id>authn-vs-authz</id>
        <link href="https://www.permit.io/blog/authn-vs-authz"/>
        <updated>2023-02-14T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Authentication and Authorization are two critical Identity Access Management (IAM) concepts. Although often confused, they have distinct meanings and functions.]]></summary>
        <content type="html"><![CDATA[<p>Authentication and Authorization, also known as AuthN and AuthZ, are two essential terms used in the context of access control, and more specifically, <a title="https://www.permit.io/blog/what-is-authorization" href="https://www.permit.io/blog/what-is-authorization"><u>Identity-Access-Management</u></a> (IAM). Understanding the difference between the two is absolutely crucial. The IAM space can be a bit confusing - and the fact that authentication and authorization sound similar doesn’t help either. Combined, AuthN and AuthZ determine the security of your application - and you can’t build a secure application unless you have configured both correctly.</p><img src="https://media.graphassets.com/ox83OUWwRui7oai8BnOW" alt="E_KwzqjXMAoitHj.jpg" title="E_KwzqjXMAoitHj.jpg" width="556" height="500" /><p><em>Is this you?</em></p><h2>TLDR - </h2><p>The easiest way to distinguish between authentication and authorization is this:</p><p>Authentication is about determining <strong>who has access to a system</strong>, while authorization is about determining what they can do <strong>within the system</strong>. </p><p>If we look at a simple real-world example - authentication identifies <strong>who&#39;s at the door</strong> and <strong>whether they may enter</strong>. Authorization deals with deciding <strong>what they can</strong> <strong>do</strong> <strong>inside the house</strong>.</p><p>Let’s dive in a little deeper - </p><p></p><h2>What is Authentication (AuthN)?</h2><p>Authentication refers to <strong>the process of verifying the identity of a user or entity.</strong> This is typically done by requiring the user to provide a set of credentials, such as a username and password, to access a system or resource. The authentication process ensures that only authorized users are granted access to sensitive data and systems.<br><br>There are several methods used for authentication, including:</p><ul><li><div><p>Username and password</p></div></li><li><div><p><a title="https://www.permit.io/blog/iam-buzzwords" href="https://www.permit.io/blog/iam-buzzwords"><u>Multi-factor authentication</u></a> (MFA)</p></div></li><li><div><p>Biometric authentication (fingerprint, face recognition)</p></div></li></ul><p>Leading authentication services include:<br><br><a title="https://auth0.com/" href="https://auth0.com/"><u>Auth0</u></a>, <a title="https://aws.amazon.com/cognito/" href="https://aws.amazon.com/cognito/"><u>AWS Cognito</u></a>, <a title="https://supertokens.com/" href="https://supertokens.com/"><u>SuperTokens</u></a>, <a title="https://fusionauth.io/" href="https://fusionauth.io/"><u>FusionAuth</u></a>, <a title="https://magic.link/" href="https://magic.link/"><u>Magic.link</u></a>, <a title="https://stytch.com/" href="https://stytch.com/"><u>Stych</u></a>, <a title="https://www.descope.com/" href="https://www.descope.com/"><u>Descope</u></a>.<br></p><h2>What is Authorization (AuthZ)?</h2><p>Authorization is the process of granting or denying access to specific resources based on a user&#39;s verified identity. This means that after a user has been authenticated, the system must also determine which resources or data the user is authorized to access. Authorization is often done by assigning <strong>roles</strong> or <strong>permissions</strong> to specific users or user groups. </p><p>Authorization is managed through <strong>policies </strong>- sets of rules that determine what actions or resources a user or system is allowed to access. Common policy models include <a title="https://www.permit.io/blog/rbac-with-permit" href="https://www.permit.io/blog/rbac-with-permit"><u>Role Based Access Control (RBAC)</u></a>, <a title="https://www.permit.io/blog/what-is-abac" href="https://www.permit.io/blog/what-is-abac"><u>Attribute Based Access Control (ABAC)</u></a>, and <a title="https://www.permit.io/blog/what-is-rebac" href="https://www.permit.io/blog/what-is-rebac">Relationship-Based Access Control (ReBAC)</a>.</p><p>Leading <a title="https://www.permit.io/blog/authorization-as-a-service" href="https://www.permit.io/blog/authorization-as-a-service">Authorization services</a> include:<br><br><a title="https://permit.io/" href="https://permit.io/"><u>Permit.io</u></a>, <a title="https://authzed.com/" href="https://authzed.com/"><u>AuthZed</u></a>, <a title="https://www.ory.sh/keto/" href="https://www.ory.sh/keto/"><u>Ory Keto</u></a>, <a title="https://www.styra.com/styra-das/" href="https://www.styra.com/styra-das/"><u>Styra DAS</u></a> <br></p><h2>Connecting Authentication and Authorization</h2><p>Now that we understand the difference between authentication and authorization, we need to understand where the two connect. </p><p>Modern authentication solutions gather the relevant information about the user into a passport-like document called a <strong>JSON Web Tokens</strong> (JWTs). The information within the JWT is signed cryptographically, allowing later recipients of the JWT (mainly the authorization layer and the application itself) to be able to make trustworthy decisions based on the user&#39;s identity without having to re-authenticate.</p><p>Permit.io integrates with any authentication solution which provides a JWT -</p><p>The unique ID of the authenticated user, along with other information like their email and name, can be extracted from the JWT and passed into a <a title="https://docs.permit.io/tutorials/onboarding/connect-your-app/#sync-user" href="https://docs.permit.io/tutorials/onboarding/connect-your-app/#sync-user"><u>“SyncUser” function</u></a> Permit provides via any of the SDKs and the <a title="https://api.permit.io/v2/redoc#tag/Users/operation/create_user" href="https://api.permit.io/v2/redoc#tag/Users/operation/create_user"><u>API</u></a>. </p><p>Once synced, users can be assigned roles and permissions via Permit, allowing policies to be enforced.</p><p></p><h2>Learn More</h2><p>Want to learn more about Auth? Join our <a title="https://io.permit.io/permitslack" href="https://io.permit.io/permitslack"><u>Slack community</u></a>, where there are hundreds of devs building and discussing AuthN and AuthZ.</p>]]></content>
        <author>
            <name>Daniel Bass</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[The Ultimate Guide to Permit Elements]]></title>
        <id>elements-guide</id>
        <link href="https://www.permit.io/blog/elements-guide"/>
        <updated>2023-01-24T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Permit Elements are prebuilt, embeddable UI components that provide fully functional access control, allowing you to delegate them to your end users safely.]]></summary>
        <content type="html"><![CDATA[<p><a title="https://www.permit.io/elements" href="https://www.permit.io/elements">Permit Elements</a> are a set of out-of-the-box access control elements you can embed directly into your app. </p><h2>Element features include:</h2><ul><li><div><p>High security to meet industry-standard protocols and ensure user authorization processes are robust</p></div></li><li><div><p>Responsive design to fit seamlessly on any screen size</p></div></li><li><div><p>Custom styling rules so you can match the look and feel of your site</p></div></li><li><div><p>Easy embedding process, allowing you to work with elements in just a few minutes</p></div></li></ul><h2>TLDR:</h2><p>In this guide, you will learn how to implement <strong>Permit Elements</strong>, and how to configure your frontend methods (login and logout) - which will send the currently authenticated user to your backend, and log that user into or out of the elements within your application.</p><p><strong>Note:</strong><br><em>As Permit and Permit Elements implement very strict and secure implementation practices, you must remember to initialize Permit and perform all element logic on the server side.</em></p><h2>Prerequisites:</h2><ul><li><div><p>Use Permit.io to manage authorization. </p></div></li><li><div><p>Have <a title="https://www.permit.io/blog/rbac-with-permit" href="https://www.permit.io/blog/rbac-with-permit">existing roles and users within the system</a>. </p></div></li></ul><p>Each element offers its own set of customization and configurations. Before we dive into those, let&#39;s dive into some of the mechanics here:</p><h2>Permission Levels:</h2><h3><strong>What are Permission Levels?</strong><a title="https://deploy-preview-73--permitio-docs.netlify.app/features/permit-elements/permission-levels#what-are-permission-levels" href="https://deploy-preview-73--permitio-docs.netlify.app/features/permit-elements/permission-levels#what-are-permission-levels"><u><strong>​</strong></u></a></h3><p>Every Permit Embeddable UI Element provides a way to control access and assign roles to different permission levels.</p><p>Permission levels provide a way to elevate or restrict access control for that specific element, and all the same element types in an environment. Roles are assigned to different levels via a simple drag-and-drop operation.</p><p>When creating a new element, all the permission levels start empty, with all the available roles inside the “Hidden Roles” section. These are all the roles you can drag into the permission levels of your choice. </p><img src="https://media.graphassets.com/MVwEzFOBSKyDrJpIioAg" alt="MacBook.png" title="MacBook.png" width="1600" height="1531" /><p><br>Let’s go over what each permission level signifies: </p><h3><strong>The 5 Permission Levels</strong><a title="https://deploy-preview-73--permitio-docs.netlify.app/features/permit-elements/permission-levels#5-permission-levels" href="https://deploy-preview-73--permitio-docs.netlify.app/features/permit-elements/permission-levels#5-permission-levels"><u><strong>​</strong></u></a></h3><table><tbody><tr><td><p>Workspace Permission Level</p></td><td><p>Description</p></td></tr><tr><td><p>Workspace Owner</p></td><td><p>The highest level of permissions, the workspace owner has full access to the element. They can assign and remove roles, and thus, the permissions of every other user.</p></td></tr><tr><td><p>Manager</p></td><td><p>The Manager has access to all of the element’s components. They can assign and remove roles and permissions for other users, but they cannot make changes to the overall workspace.</p></td></tr><tr><td><p>Viewer</p></td><td><p>A viewer can only view the element, but cannot make any changes.</p></td></tr><tr><td><p>Assignable Roles</p></td><td><p>Assignable can be assigned to users by the workspace owner or manager. However, a user with that role will not see the element.</p></td></tr><tr><td><p>Hidden Roles</p></td><td><p>The hidden roles are roles that will not appear in the element.</p></td></tr></tbody></table><p>As more elements come out, not every element will have the need to contain all five permission levels. Some elements will be ‘view only,&#39; which means you can only expect the Hidden Roles and the Viewer levels to be available for configuration.</p><h2>Live Preview Feature</h2><p>Our embeddable UI elements include a preview feature that allows users to see how the element will look and function for different permission levels and tenants. This can be useful in understanding the various configurations available and how they may affect the appearance and functionality of the element.</p><h3>How to use the Preview Feature</h3><p>Once you enter the configuration panel of the element you are currently working on, you will see a preview on the right. Use the dropdown menus to select the desired permission level and tenant for the preview. The preview will update to show how the element will appear and function for the selected permission level and tenant, which have been assigned to a particular end user.</p><h2>Customization</h2><p>With every new element, you can adjust several settings to make the look and feel of the element match your own.</p><ul><li><div><p>Change the background and primary color of any element to match your brand.</p></div></li><li><div><p>Give the element a title that makes sense to your end user, or hide it fully.</p></div></li><li><div><p>Decide if you want to display your user&#39;s Email, Full Name, or both on the element.</p></div></li></ul><img src="https://media.graphassets.com/Ksef6HSMai1KeK2416uA" alt="pasted image 0.png" title="pasted image 0.png" width="1336" height="1194" /><p></p><h2>Configuring the Webhook:</h2><p>With some Permit Elements, you will get the option to configure a webhook to stay informed of the actions that are performed by the end users.</p><p><strong>EXAMPLE:</strong><br><br>For the User Management Element, a webhook will allow you to receive updates each time a new user is created in your system.</p><p>You will need to generate a new webhook URL that points to the running server-side application. As part of the configuration, you are required to pass in a secret key and we will pass it as Bearer auth header with the user email role and level.</p><h2>Embedding the iFrame:</h2><p>After you finish configuring and customizing your element, you are ready to embed it into your App. A code snippet for the element will be generated for you. This will be an <code>&lt;iframe&gt;</code> that you can insert anywhere on your website. It will look like the code snippet below.</p><pre><code>&lt;iframe
   title=&quot;Permit Element Name&quot;
   src=&quot;https://embed.permit.io/name?envId=&lt;SOME_UNIQUE_ID&gt;&quot;
   width=&quot;100%&quot;
   height=&quot;100%&quot;
   style=&quot;border: none;&quot;
/&gt;</code></pre><h3><strong>Step 1:</strong></h3><p>Install the permit-js package</p><p>For Node:</p><pre><code>npm i --save @permitio/permit-js</code></pre><p>For yarn:</p><pre><code>yarn add @permitio/permit-js</code></pre><h3><strong>Step 2: </strong></h3><p>If you are configuring this whole setup with your first setup of Permit, you will need to import the permit package and initialize the permit instance in your backend. If you are already using Permit, you will already have that instance defined. </p><p>As part of the permit instance, Please remember to copy your `SDK Secret Key` and pass it into the initialized Permit object.</p><pre><code>const { Permit } = require(&quot;permitio&quot;);
    const [permit] = new Permit(
        {token: permit_key_SERCRET}
    );</code></pre><h3>Step 3: </h3><p><strong>Create a server-side login route</strong></p><p>You need to create a route in your backend server to allow your client to <code>`login_as` </code>themselves and get access to the Permit Element.</p><p>The backend <code>`login_as`</code> route is a bit different if your backend is using cookies, a bearer token or custom auth http headers to authenticate users.</p><p>You can choose the one that suits your backend needs best. The option you choose will depend on how you already handle authentication in your application.</p><p>Three examples will now follow: </p><ul><li><div>Using cookies:<br></div><div><pre><code>const express = require(&quot;express&quot;);
 const app = express();
 app.get(&quot;/login_cookie&quot;, async (req, res) =&gt; {
     // const user_key = get_user_from_jwt();
     const ticket = await permit.elements.loginAs({userId: user_key, tenantId: TENANT});
     res.status(302).redirect(ticket.redirect_url);
 });
 app.listen(port, () =&gt; {
   console.log(`Example app listening at http://localhost:${port}`);
 });</code></pre></div></li><li><div>Using a bearer token:<br></div><div><pre><code>const express = require(&quot;express&quot;);
 const app = express();
 app.get(&quot;/login_header&quot;, async (req, res) =&gt; {
     // const user_key = get_user_from_jwt();
     const ticket = await permit.elements.loginAs({userId: user_key, tenantId: TENANT});
     res.status(200).send(ticket.content);
 });
 app.listen(port, () =&gt; {
   console.log(`Example app listening at http://localhost:${port}`);
 });
</code></pre></div></li></ul><ul><li><div>Using any other http security header:<br></div><div><pre><code>const express = require(&quot;express&quot;);
 const app = express();
 app.get(&quot;/login_header&quot;, async (req, res) =&gt; {
     // const user_key = get_user_from_jwt();
     const ticket = await permit.elements.loginAs({userId: user_key, tenantId: TENANT});
     res.status(200).send(ticket.content);
 });
 app.listen(port, () =&gt; {
   console.log(`Example app listening at http://localhost:${port}`);
 });
</code></pre></div></li></ul><h3>Step 4: </h3><p><strong>Client-side login method</strong></p><p>Two login methods need to be called in your frontend application. The login method, and the logout method.<br><br>The login function should be called as early as possible in your App. It is best to do this inside an <strong>App/index</strong> file,  right after the users had their identity confirmed by the Authorization provider of your choice, but just before the Embedded component is loaded.</p><p>This is a client-side element login method that calls the backend route we have previously configured server-side. It sends the relevant information to the server, which allows us to login into the Permit elements within the app.</p><pre><code>permit.elements.login({
        loginUrl: &#39;https://your_app_url.com/permit_login,
        tenant: &#39;your_tenant_key&#39;,
        token:&#39;&lt;TOKEN&gt;&#39;,
        loginMethod: LoginMethod.bearer
    });</code></pre><p>There are a couple of things that need to be configured here:</p><p></p><p><strong>loginUrl</strong> - The URL that corresponds to your backend login route created in the last step.</p><p><strong>loginMethod</strong> - The login method you are using in your backend.</p><p><strong>tenant (Optional)</strong> - The name of the tenant that the user is part of. You can set it at your backend as well.</p><p><strong>token (Optional)</strong> - If your login method is a bearer token, you need to pass the token here.</p><p><strong>headers (Optional)</strong> - If your login method has custom headers, you need to pass the headers here.</p><p>There are three supported login options - choose the one you use in your backend.</p><ul><li><div>Cookie Login Method<br></div><div><pre><code>permit.elements.login({
    loginUrl: &#39;https://your_app_url.com/permit_login,
    tenant: &#39;your_tenant_key&#39;
}).then((res: any) =&gt; {//optional handle success
 }).catch((err: any) =&gt; {//handle error
});</code></pre></div></li></ul><ul><li><div><p>Bearer Token Login Method</p><pre><code>permit.elements.login({
    loginUrl: backendUrl,
    tenant: &#39;your_tenant_key&#39;,
    loginMethod: LoginMethod.bearer,
    token: JWT_secret
}).then((res: any) =&gt; {//optional handle success
 }).catch((err: any) =&gt; {//handle error
});</code></pre></div></li><li><div><p>Any other header login Method</p><pre><code>permit.elements.login({
    loginUrl: backendUrl,
    tenant: &#39;your_tenant_key&#39;,
    loginMethod: LoginMethod.header,
    headers: {&#39;&lt;secure header name&gt;&#39;: &#39;secret&#39;}
}).then((res: any) =&gt; {//optional handle success
 }).catch((err: any) =&gt; {//handle error
});</code></pre></div></li></ul><h3>Step 5: Client-side logout method</h3><p>This function should be called along with the logout logic that you have within your App. <br>This is to make sure the user does not continue to have access to the Permit Element.</p><pre><code>permit.elements.logout();</code></pre><h2>Possible Login Errors</h2><p>There are a few possible errors you might encounter while working Permit Elements, and user login.</p><table><tbody><tr><td><p>Error</p></td><td><p>Description</p></td></tr><tr><td><p>USER_NOT_FOUND</p></td><td><p>This error can appear if you are trying to log in as a particular user, but that user does not exist within Permit.</p></td></tr><tr><td><p>TENANT_NOT_FOUND</p></td><td><p>This error can appear when you pass in a tenant, either in the frontend permit.elements.login function, or in your backend URL endpoint, where the tenant has not been created in Permit.</p></td></tr><tr><td><p>INVALID_PERMISSION_LEVEL</p></td><td><p>The error will appear when you try to access part of the Element to which you have not been given access too. This usually means the role that the person obtained has remained in the Hidden Roles permission level.</p></td></tr><tr><td><p>FORBIDDEN_ACCESS</p></td><td><p>This error will emerge when you are trying to log in to an Element you have not been given permission to see.</p></td></tr></tbody></table><h2>Having Trouble? </h2><p>Let us know in our <a title="https://io.permit.io/permitslack" href="https://io.permit.io/permitslack">Slack Community</a> - we will be more than happy to help 🙂</p>]]></content>
        <author>
            <name>Filip Grebowski</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Permit Elements]]></title>
        <id>elements</id>
        <link href="https://www.permit.io/blog/elements"/>
        <updated>2023-01-24T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Delegate access control with simple, embeddable interfaces]]></summary>
        <content type="html"><![CDATA[<h2>You’ve built these a thousand times</h2><p>If you’re a developer, you <strong>know</strong> that as time progresses, the mere fundamentals required to get an application off the ground are constantly increasing. This added complexity doesn&#39;t just affect how the application works but also how users interact with it.</p><p>In no space is this more evident than application access control. It&#39;s a set of critical, must-have experiences that are hard to build and risky to get wrong. They deeply affect both vendors and users and worst of all - they are not unique to any product.</p><p>But what if you could skip over all this nonsense? </p><p>What if every user in your application (Including your fellow stakeholders - e.g., product, security, support, sales, as well as customers) could be a super-user, not only having all the permissions they need, but also the power and capability to extend permissions to those who need them?</p><p><strong>That would allow you to focus on developing the core of your product rather than being a bottleneck</strong> for mundane tasks like adding another role. </p><p><strong>That’s what </strong><a title="https://www.permit.io/elements" href="https://www.permit.io/elements"><strong>Permit Elements</strong></a><strong> are here for -</strong><br></p><h2>Permit - Never Build Permissions Again</h2><p>With Permit’s initial launch, we provided all the building blocks needed (SDKs, gateway plugins, data updates) to integrate permissions into an application with ease, allowing you to empower your stakeholders with a powerful back-office to manage permissions (low-code, and policy as code - RBAC, ABAC, and more).</p><img src="https://media.graphassets.com/LXOLahBTEeBWXj89sCAX" alt="Blog.png" title="Blog.png" width="5073" height="5029" /><p>The next natural step in this flow is the extension of these capabilities to the end customers through the application itself. And not just permissions - but also <em>permissions for permissions</em>.</p><h2><a title="https://www.permit.io/elements" href="https://www.permit.io/elements">Permit Elements</a> - Let the Power Flow</h2><p>Just as Permit&#39;s back office and API give developers the control they need; Permit Elements extend this ability to the application users themselves, without giving up on security, compliance, development speed, style, or control. <br>Critical experiences (like user management, audit logs, API key management, permission requests, approval flows, and many more) are ready to be customized and embedded into your application.<br><br>Customization includes the look and feel you want:</p><img src="https://media.graphassets.com/vY08ZmjSR7WYPgqT8n1g" alt="2.png" title="2.png" width="578" height="380" /><p>But more importantly, customization includes who can use the embedded interface, and how - aka authorization for authorization. With the ease of simply mapping your existing roles to the higher-level ones.</p><img src="https://media.graphassets.com/I7BD3ETeRPam0oJ6aVEQ" alt="MacBook.png" title="MacBook.png" width="2280" height="2182" /><p>Permit Elements allow every user to become a superuser (within safely set bounds) - eliminating bottlenecks and enabling control to flow from <strong>developers</strong> to <strong>team members</strong> to <strong>end</strong> <strong>customers</strong>.<br></p><h2>Summary</h2><p>Permit helps developers build and manage permissions in applications. Permit Elements takes it a leap forward, enabling developers to focus on building the core product while empowering other stakeholders and end-customers to manage permissions within the application. Permit Elements allows for customization of both the look and feel of the interface and the authorization for who can use it, with the goal of allowing every user to become a &quot;superuser.&quot;</p>]]></content>
        <author>
            <name>Or Weis</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[How to implement RBAC with Permit.io]]></title>
        <id>rbac-with-permit</id>
        <link href="https://www.permit.io/blog/rbac-with-permit"/>
        <updated>2023-01-05T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[A tutorial explaining how to implement RBAC (Role Based Access Control) by using Permit.io]]></summary>
        <content type="html"><![CDATA[<p>Before we dive into the step-by-step tutorial, let’s start with a short introduction - </p><h2>What is RBAC?</h2><p>Role-based access control (RBAC), is an authorization model used to determine access control based on <strong>predefined roles</strong>. Permissions are assigned to roles (Like “Admin or “User”), and roles are assigned to users by the administrator. This structure allows you to easily understand who has access to what. </p><p>The combination of <strong>who</strong> (Which Identity, and what role are they assigned?) can do <strong>what</strong> (What actions are they allowed to perform) with a <strong>resource</strong> (On which aspects of the software) is called a <strong>policy</strong>.</p><p>For example, a user with the role of &quot;System Administrator&quot; might be granted access to perform every available action on all the resources in the system, while a user with the role of &quot;Guest&quot; might only be granted access to perform very limited actions on a few specific resources. </p><p>Having predefined roles makes it easier to manage access to resources since the administrator only needs to manage the roles rather than the individual permissions for each user.</p><h2>Who needs RBAC?</h2><p>RBAC provides a rather simple solution for controlling access to resources based on a predefined set of roles (Which can, for example, correlate with an individual&#39;s job function or responsibilities). <br><br>RBAC is a perfectly balanced policy model (not too complex [like <a title="https://www.permit.io/blog/what-is-abac" href="https://www.permit.io/blog/what-is-abac">ABAC</a> or <a title="https://www.permit.io/blog/what-is-rebac" href="https://www.permit.io/blog/what-is-rebac">ReBAC</a>] and not too simple [like Admin/Non-Admin]), as a result, it has grown to be very popular and is the default model your customers are probably familiar with.</p><p>Implementing RBAC can help ensure that only authorized users have access to sensitive resources and also make it easier to manage and revoke access as one&#39;s role and responsibilities within the organization change.</p><p>Using RBAC can help to improve security by making it more difficult for unauthorized users to gain access to resources and improve efficiency by reducing the need for manual assignment of access per individual user.<br></p><h2>Example RBAC policy -</h2><p>Say we are managing a Blog. In our blog, we have three different users, each requiring a different set of permissions - </p><p>1. The system administrator, who manages the entire system</p><p>2. A person writing an article needs to be able to create new entries</p><p>3. A person who can edit existing content but shouldn’t be able to create new entries</p><p>In this example, we can divide these three users into three <strong>roles</strong>: <br><br>An <strong>Admin</strong>, a <strong>Writer</strong>, and an <strong>Editor</strong>. </p><p>These roles will be able to perform <strong>actions</strong> on the different <strong>resources</strong> within our blog. <br><br>A resource, in this case, will be a <strong>blog post</strong>. </p><p>The next question we have to ask ourselves is, “Which <strong>action</strong> can each of these users perform on the blog-post <strong>resource</strong>?” </p><p>In this example, we can define actions such as <strong>Create</strong>, <strong>Edit</strong>, <strong>Delete</strong>, and <strong>View</strong>. <br><br>If we try and define this policy in simple English, it would look something like this:</p><ul><li><div><p>The <strong>Admin</strong> can <strong>Create</strong>, <strong>Edit</strong>, <strong>Delete</strong> and <strong>View</strong> the <strong>Blog Post</strong></p></div></li><li><div><p>The <strong>Writer</strong> can <strong>Create</strong>, <strong>Edit</strong>, and <strong>View</strong> the <strong>Blog Post</strong></p></div></li><li><div><p>The <strong>Editor</strong> can <strong>Edit</strong> and <strong>View</strong> the <strong>Blog Post</strong> </p></div></li></ul><h2>Why use Permit?</h2><p>Permit allows setting up and managing all of our application-level RBAC roles in a unified user interface, saving you the time of having to develop such a system from scratch, so you can focus on the actual cool and unique features of our application.<br><br>Permit also allows you to embed parts of its UI as components within your application using <a title="https://permit.io/elements" href="https://permit.io/elements"><u><strong>Permit Elements</strong></u></a>, thus propagating permission management (User management, Audit logs, etc.) functionality to other stakeholders - tackling the complex challenge of Authorization-for-Authorization. <br><br><a title="https://www.permit.io/rbac" href="https://www.permit.io/rbac">⁠Learn more about the benefits of setting up RBAC with Permit.io here </a></p><h2>Let’s get down to it!</h2><h3>Step 1: Onboarding</h3><ul><li><div><p>Go to <a title="https://app.permit.io/?utm_source=website&utm_medium=website-home&utm_campaign=hero" href="https://app.permit.io/?utm_source=website&utm_medium=website-home&utm_campaign=hero"><u>https://app.permit.io/</u></a></p></div></li><li><div><p>Register and log in. Permit is free to use up to <a title="https://www.permit.io/pricing" href="https://www.permit.io/pricing"><u>1K MAU</u></a> . </p></div></li><li><div><p>Follow the onboarding process step by step (The purpose of the onboarding is to help you set up basic RBAC - in this article, we aim to give you a more detailed dive into this setup). </p></div></li></ul><img src="https://media.graphassets.com/iLYDz0B8S9qbEpW8zjKF" alt="1.png" title="1.png" width="1060" height="783" /><p><em>The first screen of the onboarding process</em></p><ul><li><div>Once you reach the last screen of the onboarding process, you will be asked to connect your application to Permit. Let’s quickly go over how that’s done - </div></li></ul><h3>Step 2: Connecting your application </h3><ul><li><div><p>In the last screen of the onboarding process, you will be asked to connect your application to Permit. To achieve that, follow the instructions on the screen. You will need to perform three actions:</p></div><div><ol><li><div><p>Select the programming language which is relevant to your application. </p></div></li><li><div><p>Deploy a PDP (Policy Decision Point) image to your application via ‘docker pull’. <br>The PDP stores information about all the rules and permissions, and it resides on the client&#39;s server (<a title="https://docs.permit.io/concepts/pdp" href="https://docs.permit.io/concepts/pdp"><u>You can learn more about the PDP here</u></a>).</p></div></li><li><div><p>Add the SDK to your code (In your relevant coding language). </p></div></li></ol></div></li></ul><p>A detailed explanation of this process can be found <a title="https://docs.permit.io/tutorials/quickstart" href="https://docs.permit.io/tutorials/quickstart"><u>here</u></a>. </p><img src="https://media.graphassets.com/nuogrFXTJFbE1lr0N1CA" alt="2.png" title="2.png" width="1324" height="942" /><p><em>Connecting a Node.js app instruction screen</em></p><p>Once our application is connected, we can continue to the setup step. <br></p><h2>Creating and Mapping Roles, Actions, and Resources</h2><p>Let’s do a quick recap of the three terms we will be dealing with here. Going back to our example, we are going to -</p><ul><li><div><p>Setup three <strong>roles</strong> - Admin, Writer, and Editor</p></div></li><li><div><p>Set up a Blog Post <strong>resource</strong>.</p></div></li><li><div><p>Add four possible actions these roles can perform - Create, Edit, Delete, and View.</p></div></li></ul><p>⁠Let’s dive right in.</p><p></p><h3>Step 3: Creating a resource, defining actions </h3><p>Resources, roles, and actions are managed on the policy page. </p><ul><li><div><p>Go to the <strong>‘Policy’</strong> page in the menu bar on your left.</p></div></li><li><div><p>Click ‘Create’ and select ‘Resource’<br></p><img src="https://media.graphassets.com/7UIZOfyeTs2GMoGJK2uT" alt="3.png" title="3.png" width="1600" height="738" /></div></li><li><div><p>Name your resource - in this example, let’s name it <strong>Blog Post</strong>.</p></div></li><li><div>In the ‘Actions’ panel, define the actions that can be performed on the resource - in this example: <strong>Create</strong>, <strong>Edit</strong>, <strong>Delete</strong>, and <strong>View</strong>.<br></div><div><img src="https://media.graphassets.com/YWlsGMlRop6fXNFJ83zQ" alt="4.png" title="4.png" width="622" height="530" /></div></li><li><div>Finalize by clicking ‘Save Resource.’ </div></li></ul><ul><li><div><p><strong>We now have our first resource and the actions which can be performed on it! Nice!</strong></p><img src="https://media.graphassets.com/6AMFyvWJQeqbTxtpbmUH" alt="5.png" title="5.png" width="434" height="280" /></div></li></ul><p><strong>Note</strong>: You can remove the sample ‘document’ resource which was created during the onboarding - we won’t be needing it. </p><img src="https://media.graphassets.com/xfynZ34T4SDg7M37aBGV" alt="8.png" title="8.png" width="544" height="330" /><p></p><h3>⁠Step 4: Creating roles </h3><p>Now that we have our resources and actions set up, we can add new roles. </p><ul><li><div><p>Click ‘Create’ and select <strong>‘Role’</strong></p></div></li><li><div><p>Give the role a name - In the case of this example, <strong>‘Writer’</strong> (As we already have an Admin from the onboarding). </p></div></li><li><div><p>Repeat the process to create an <strong>‘Editor’</strong> role as well. </p></div></li><li><div><p>We now have our roles set up! <br><strong>Notice resources and actions are automatically propagated between the different</strong> <strong>roles</strong>.</p><img src="https://media.graphassets.com/PvBmxRgfQHy6JSWgJeFL" alt="6.png" title="6.png" width="433" height="992" /></div></li><li><div><p><strong>Note</strong>: You can provide a short description for each role to give other users a better understanding of the definition of each role. <br></p></div></li></ul><h3>Step 5: Add actual users to the roles you set up</h3><p>Now that you have RBAC, it&#39;s time to assign these roles to actual users. This is done through the ‘User Management screen. </p><ul><li><div><p>Go to the <strong>‘Users’</strong> page in the menu bar on your left.</p></div></li><li><div><p>Click <strong>‘New User’</strong> and fill in the user details: email, first name, last name, and pick the roles you want to assign to the new user. </p></div></li><li><div><p>Assign the required roles to the newly created user. Note that each user can be assigned several roles. </p></div></li><li><div><p>Click ‘Create User, and you’re done!<br></p><img src="https://media.graphassets.com/WPezWiPNTKSCFlwXUPci" alt="7.png" title="7.png" width="638" height="518" /></div></li></ul><p>Note: The email field you fill in will serve as the <strong>unique user key</strong>. It doesn’t have to be a real operational email address as long as it&#39;s unique. <br></p><h3>Step 6: Adding enforcement points - Permit.check()</h3><p>Once your Roles, resources, and actions are defined, Permit has created the policies that correspond to them. Now that we have our policies, you can set up enforcement points within your app at the points where permissions need to be checked. To do that - </p><ul><li><div><p>Go to a point within your app’s code that requires a permission check.</p></div></li><li><div><p>Add this code snippet: </p><pre><code>const permitted = await permit.check(&quot;john@permit.io&quot;, &quot;create&quot;, &quot;document&quot;);</code></pre></div></li></ul><ul><li><div><p>The permit.check function requires three parameters to be passed - a <strong>unique user key</strong> that exists within Permit, the action that’s being performed, and the resource that action is being performed on. The result of the permit.check will be a boolean that you can reference in your code logic to perform functions based on the outcome of the permission check. </p><pre><code>if (permitted) {
    console.log(&quot;User is PERMITTED to create a document&quot;);
} else {
    console.log(&quot;User is NOT PERMITTED to create a document&quot;);
}</code></pre></div></li></ul><p></p><h3>Step 7: Set the permissions for each role </h3><p>Now that everything is set up, it&#39;s as easy as checking a box. </p><ul><li><div><p>Select the relevant actions for each role </p></div></li><li><div><p>Click ‘Save Changes’ </p><img src="https://media.graphassets.com/K6WoiMjR7e0xWtfYTmjN" alt="9.png" title="9.png" width="650" height="79" /></div></li><li><div><p>Once the changes have been saved, they should come into effect in your application instantaneously. </p></div></li><li><div><p><strong>That’s it! You have an active RBAC system set up in your application. </strong></p></div></li></ul><p><strong>FYI: </strong>The policies generated via the Permit UI are all generated as <a title="https://www.permit.io/blog/implement-rbac-using-opa" href="https://www.permit.io/blog/implement-rbac-using-opa"><u><strong>Rego code</strong></u></a>, which you can manage via your own Git Repository. If you want us to set that up for you - <a title="https://bit.ly/permitcommunity" href="https://bit.ly/permitcommunity"><u><strong>let us know</strong></u></a>!<br></p><h3>Step 8 (Optional): Adding users through the SDK / API</h3><p>While you can create users with the UI dashboard, Permit also allows you to perform any action through the API. On top of that, you can use any of the <a title="https://docs.permit.io/tutorials/quickstart#integrate-sdk" href="https://docs.permit.io/tutorials/quickstart#integrate-sdk"><u>multiple SDKs</u></a> that abstract from the complexity of the API. </p><ul><li><div><p>A detailed explanation of creating users with the API <a title="https://api.permit.io/v2/redoc#tag/Users/operation/create_user" href="https://api.permit.io/v2/redoc#tag/Users/operation/create_user"><u>can be found here</u></a>.</p></div></li><li><div><p>An explanation about creating users with the Node.JS SDK <a title="https://docs.permit.io/sdk/nodejs/user/create-user" href="https://docs.permit.io/sdk/nodejs/user/create-user"><u>is available here</u></a>. </p></div></li><li><div><p>You can find the <a title="https://docs.permit.io/tutorials/quickstart#integrate-sdk" href="https://docs.permit.io/tutorials/quickstart#integrate-sdk"><u>rest of the SDKs here</u></a>. <br></p></div></li></ul><h2>Summary</h2><p>In this tutorial, we learned what role-based access control (RBAC) is, why someone would want to use it, and how it can be implemented by using Permit.io - Including creating Roles, Actions, and Resources and mapping permissions to them accordingly. </p><p>Having trouble setting this up? Have any additional questions? Want to share a cool project you’ve built using this? Let us know in our <a title="https://io.permit.io/permitslack" href="https://io.permit.io/permitslack"><u>Slack community</u></a>.</p>]]></content>
        <author>
            <name>Shuvy Ankor </name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[How to choose an Authorization Service?]]></title>
        <id>choose-an-authz-service</id>
        <link href="https://www.permit.io/blog/choose-an-authz-service"/>
        <updated>2023-01-04T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Every developer building an app faces the challenge of AuthZ. RBAC, ABAC, multitenancy, invites, approval flows - How do you pick the best service for it?]]></summary>
        <content type="html"><![CDATA[<p>Before we start breaking the decision process of picking an authorization service, let&#39;s, just for the sake of clarity, define what it is first –</p><h2>What is Authorization as a Service</h2><p>Authorization as a service (or better-named ‘Permissions as a Service’ to differentiate from ‘Authentication as a Service’) enables software developers to build applications that can request and receive permissions to access certain resources or perform certain actions on behalf of an end-user. These permissions are typically granted by the end users themselves.</p><p>By using a ‘Permissions as a Service’ provider, developers can focus on building their application’s core functionality rather than spending time and resources building and maintaining their own authorization and permission management systems.<br><br><a title="https://www.permit.io/blog/authorization-as-a-service" href="https://www.permit.io/blog/authorization-as-a-service">Learn more about authorization as a service</a></p><h2>Don’t Confuse with Authentication</h2><p>Every developer, when presented with the question: “<em>Do you know the difference between Authentication and Authorization</em>”? Will undoubtedly reply: “<em>Of course!</em>” In reality, you&#39;d be surprised how often they <a title="https://www.permit.io/blog/authn-vs-authz" href="https://www.permit.io/blog/authn-vs-authz">confuse the two</a>.<br> <br>Authorization as a service really (and I mean really) shouldn’t be confused with authentication as a service; which deals with verifying identities (as opposed to checking what they can do or not, once verified).</p><p>Some authentication services come with role and/or user management - making you think they include permissions, but <strong>these always just translate to claims in your JWT</strong>, which still require you to write code to enforce alongside more data points (e.g., billing status, anomaly detection); or worse - <strong>they translate into a simple API you query in their cloud</strong> - both killing your application’s performance with latency and limiting your ability to upgrade to more complex policies (e.g., moving from RBAC to ABAC).  </p><h2>Why Should You Use an Authorization Service </h2><p>Building permissions as a service is at a critical junction of requiring advanced knowledge in cryptography, cybersecurity, the intricacies of policy models (e.g., <a title="https://www.permit.io/blog/implement-rbac-using-opa" href="https://www.permit.io/blog/implement-rbac-using-opa">RBAC</a>, <a title="https://www.permit.io/blog/implement-abac-using-opa" href="https://www.permit.io/blog/implement-abac-using-opa">ABAC</a>, or <a title="https://www.permit.io/blog/what-is-rebac" href="https://www.permit.io/blog/what-is-rebac">ReBAC</a>), and high-performance real-time distributed systems - all while not being unique to any product. <br><br>Authorization requirements have a tendency to grow exponentially with the application; starting easy at first (e.g., Admin / Not admin  - hardcoded into the app) but quickly becoming complex with the various requirements from customers, security, compliance, and 3rd party integrations. With new requirements often leading to a full refactor every 3-6 months.<br><br>The bottom line is that you should use an authorization service to avoid wasting time reinventing the wheel and avoid making mistakes that can easily translate into vulnerabilities or critical performance issues.</p><h2>The Key Factors for Choosing an Authorization Service</h2><h3><strong>Compatibility</strong>: </h3><p>Let’s face it: you probably already have something in place (even if it’s just a single DB table with a user role column). So make sure the solution is compatible with your existing systems and infrastructure. This includes compatibility with your cloud environment, programming language, and data sources.</p><p>In addition, you should make sure that the transition to the new solution can be a gradual and fast one (or at least gradual). Gradual means the ability to run the new solution side by side with your existing one and test it behaves as you expect. </p><h3><strong>Best Practices:</strong></h3><p>Anyone can build a service that just returns a list of roles (and many developers do at some point or another in their careers) - but without <a title="https://www.permit.io/blog/5-best-practices-for-building-cloud-native-permissions" href="https://www.permit.io/blog/5-best-practices-for-building-cloud-native-permissions">the best practices</a> baked into the solution, maintaining it, and ultimately refactoring or replacing it would be painstaking and time-consuming. </p><p>Policy as Code, event-driven updates, Gitops, control-plane back office, and customer-facing experiences are some of the best practices you will need and really shouldn’t compromise on. </p><h3><strong>Latency and locality:</strong></h3><p>The average microservice-based application triggers three authorization queries per request. If each takes more than 50-100ms, the performance of your application is basically dead before it even starts to handle its own core logic. Latency across cloud services is basically unavoidable (the service provider might be able to reduce it somewhat but not remove it altogether - especially under heavy workload scenarios).<br>Hence, it is best to avoid authorization services that provide only remote querying options and that haven’t taken latency into account.</p><h3><strong>Policy Model Support:</strong></h3><p>As your application evolves to meet new demands, so will your authorization layer - so while everyone often starts with Admin/Not-admin, <a title="https://www.permit.io/blog/implement-rbac-using-opa" href="https://www.permit.io/blog/implement-rbac-using-opa">RBAC</a>, <a title="https://www.permit.io/blog/implement-abac-using-opa" href="https://www.permit.io/blog/implement-abac-using-opa">ABAC</a>, or <a title="https://www.permit.io/blog/what-is-rebac" href="https://www.permit.io/blog/what-is-rebac">ReBAC</a>, and variants of them are most likely in your app’s future. Different solutions would support different models and varying levels. </p><p>For example, Google-Zanzibar-inspired solutions are a great way to implement ReBAC but are <a title="https://www.permit.io/blog/policy-engines" href="https://www.permit.io/blog/policy-engines">often impossible to implement or impractical for ABAC</a>.</p><h3><strong>Scalability:</strong></h3><p>Consider the scalability of the solution. If you expect your user base to grow significantly over time, you&#39;ll want a solution that can handle the increased load and complexity (e.g., of policy or application structure).</p><h3><strong>Security and compliance:</strong> </h3><p>Security is always an important consideration, especially regarding access control. When picking a service provider, you should aim for one that has cybersecurity as part of its DNA, building with security by design (and not adding it as layers later). You should ask your provider how they intend to work with your sensitive data for authorization without increasing your attack surface and risk of data leakage.</p><h3><strong>Ease of use:</strong></h3><p>Choose a solution that is easy to use and set up. This will make it easier for you to manage permissions and reduce the risk of errors. Remember that this tool isn’t going to be just for your own use - your fellow stakeholders (e.g., product managers, security teams, compliance, support, sales, …) will need to work with this as well. The better you can delegate usage to them, the less of a bottleneck you’d have to be. Prefer solutions that provide user interfaces, as opposed to just APIs and infrastructure.</p><h3><strong>Support:</strong></h3><p>Make sure the solution has good customer support in case you have any issues or questions.<br>I’d recommend taking their support for a spin, asking a question in the solutions community or support forum, seeing how quickly you get a response; or at least glance at how quickly other people’s questions get answered.</p><h2>TL;DR</h2><p>Authorization as a Service, also known as permissions as a service, enables developers to build applications that can securely gate access to certain resources or perform certain actions on behalf of an end-user. Using an authorization service allows developers to focus on building their core application functionality rather than spending time and resources building and maintaining infrastructure, APIs, and human interfaces that aren’t unique to any application. When choosing an authorization service, compatibility with existing systems and infrastructure, best practices, latency and locality, scalability, and cost should all be considered. It is important to use an authorization service to avoid reinventing the wheel and to avoid mistakes that can lead to vulnerabilities or performance issues.<br><br>Have any questions about authorization as a service? Let us know in our <a title="https://io.permit.io/permitslack" href="https://io.permit.io/permitslack"><u>Slack community</u></a>.</p>]]></content>
        <author>
            <name>Or Weis</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[DARCC - The five layers of Modern App Security]]></title>
        <id>darcc-blog</id>
        <link href="https://www.permit.io/blog/darcc-blog"/>
        <updated>2023-01-03T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[The DRACC framework is a DevSecOps methodology which allows mapping the security posture of your application in a communicative, comprehensive way.]]></summary>
        <content type="html"><![CDATA[<h1>Death to the Security Questionnaire </h1><p>The DRACC framework is a DevSecOps methodology that allows you to map the security posture of your application in a way that’s communicative and comprehensive. It shouldn’t take more than an hour or so to create - effectively removing the necessity for filling out ridiculously long security questionnaires while allowing you to find security gaps in the solution you are building. <br><br>How, you ask? Let’s dig in.</p><img src="https://media.graphassets.com/Fsfl6BIS1u3Uf3C39Bjg" alt="unnamed (4).png" title="unnamed (4).png" width="1088" height="956" /><p><em>The dreaded security questionnaire </em></p><p><em></em></p><h2><strong>The challenge </strong></h2><p>As the software stack that we&#39;re building is continuously getting bigger, software gets more complex. We keep on adding more parts and layers to our software - all of which mean potential weak links being added to the chain, or in other words, many potential attack surfaces all over the plane.</p><p>The issue is it&#39;s tough to communicate these new attack surfaces to our customers, vendors, or between DevOps and security - leaving us feeling <em>lost in the dark</em>. </p><p>Take the example of a startup in the healthcare sector - </p><img src="https://media.graphassets.com/ElnvUfakRjmEMelWcvgS" alt="unnamed (3).png" title="unnamed (3).png" width="1600" height="900" /><p>The startup connects to an element deployed on the hospital’s side, which allows them to provide a machine learning-driven service. This service has both a backend part and a frontend customer-facing application, allowing <strong>patients</strong> and <strong>doctors</strong> to work on the produced data. </p><p>They have <strong>data scientists</strong> responsible for training the machine learning model and integrating it into the interface, <strong>platform engineers</strong> handling the planning and development of the platform, and an <strong>R&amp;D team</strong> responsible for constructing all the necessary elements.</p><p>Looking at this picture, you can see how valuable and sensitive data flows through the system and how proprietary aspects of the system, such as the model, can be translated into attack surfaces and vulnerabilities we need to deal with. <strong>Now try and imagine what it would take to give a detailed description of this picture to someone.</strong></p><img src="https://media.graphassets.com/I3gbrUrEQ5Krx8O2f7xw" alt="unnamed (2).png" title="unnamed (2).png" width="750" height="755" /><p><em>Try to describe what&#39;s happening in this picture.</em></p><p>Trying to cover all of the areas will take a while, especially if we plan on connecting this system to other partners, vendors, or solutions - which is usually inevitable. </p><p>This issue is extremely clear when you think about <strong>security questionnaires</strong>. Anyone who&#39;s ever built a product or SaaS offering is probably familiar with these documents - long spreadsheets you need to fill out just to communicate the baseline of how you do security and how your product looks. <strong>Filling one out can drive someone insane</strong> - they are stressful, annoying, and very hard to work with. <br><br>With the plane and potential attack surfaces constantly growing, it&#39;s difficult to communicate them and find the gaps and potential weak points that need to be addressed.<br><br>This is where DARCC comes in.</p><h2><strong>The solution? DARCC - Death to the security questionnaire </strong></h2><p>DARCC is a new methodology/framework that is focused on providing <strong>a quick, broad view of your DevSecOps status</strong>. It allows you to easily communicate the status of your system&#39;s security both within the organization as well as to your customers, <strong>all without having to fill out absurdly long security questionnaires</strong>. While DARCC allows you to view the overall picture, it also enables you to ensure every aspect of your system adheres to best practices and easily translates into understanding which tools you need to apply to avoid potential issues.</p><p>DARCC consists of 5 basic layers which exist in every application. <strong>If all five are covered properly, you should be able to avoid any potential security vulnerabilities.</strong> These are -</p><h3><strong>Dependency | Access Control | Runtime | Configuration | Containers</strong></h3><p>⁠Let’s dive into each of these layers to understand it better. Handling each layer requires us to answer a different question, so let&#39;s dive into those - </p><p></p><h3><strong>Dependency</strong></h3><p>Supply chains are a really hot topic right now, and managing the dependencies of the software we&#39;re providing is a critical thing. We basically want to ask ourselves, <br><br>How secure is the software supply chain that we&#39;re depending on? </p><h3><strong>Access Control </strong></h3><p>How do we connect other people, services, or identities to what we are building, and are we doing so securely?</p><h3><strong>Runtime</strong> </h3><p>How do we know that the software that we&#39;ve built is going to behave the way that we expect?</p><h3><strong>Configuration</strong></h3><p>How do we know that we&#39;ve set and configured the software that we&#39;re deploying to run in the way that we expect and want? </p><h3><strong>Containers</strong></h3><p>How do we set up the containing environment? How do we ensure that our software runs within the intended box/servers/cloud in the way it is intended to work?</p><p></p><h2><strong>The best practices</strong></h2><p>Now that we have our layers in place, we need to pair those with best practices. These will serve as our light in the dark, as they will provide you with an understanding of any potential gaps in your security. <strong>Each of these best practices is relevant to every single layer we listed previously</strong>. These best practices are: </p><h3><strong>Manage as Code | Zero Trust | Event Driven | Decoupled | Unified View | Approachable </strong></h3><p>So what does each of these mean? </p><h3><strong>Manage As Code</strong></h3><p>There is a very mature ecosystem that allows developers to manage complex things as code. Translating complex concepts into code (IaC, Config as code, Policy as code) is huge right now, as managing them with GitOps saves us from reinventing the wheel.</p><h3><strong>Zero Trust</strong></h3><p>Also a very common best practice, each component has to stand securely on its own, answering the weakest link principle, with a need-to-know basis baked into all of its layers. </p><p>This will really affect how we compile or build the software itself and how we connect different software components to one another. </p><h3><strong>Event Driven</strong></h3><p>Being event-driven is a necessity of every modern application. If your software is moving too slowly, or if it is unable to respond to changes in customer demands or infrastructure, you will have a bad time. Modern systems mutate in real time; your security needs to match.</p><h3><strong>Decouple</strong></h3><p>A classic principle from software development, you need to ensure that only the necessary parts are bundled together and that you have the tools to do so. If you abstain from doing so today because the software seems too complex - you’ll end up with spaghetti code or spaghetti architecture tomorrow. Coupled components are harder to monitor, track, and upgrade, making them harder to defend. </p><h3><strong>Unified view</strong></h3><p> Having this will allow you to monitor the entire layer in a way that is easy and aggregated so that you can connect it to other systems. Modern systems are often distributed - so we need to aggregate and unify views on top of them.</p><h3><strong>Approachable</strong></h3><p>Everyone is becoming a developer, and every stakeholder has to be involved in security. This means we can no longer apply security as an afterthought, and we need developers to be able to access it in a way that is comfortable for them to use. Not only that, but we also often need to enable the product, security, compliance, sales, and support teams, to chime in on our security posture or at least be part of the conversation. Modern security can’t be left just to the CISO or developers - everyone needs to be able to contribute.</p><p>Now we will see how these best practices can be combined with the layers we mentioned earlier. For each layer in DARCC, we’re going to look at each of the best practices and ask ourselves: <strong>How are we implementing the best practice?</strong> And more importantly, <strong>Which tools do we have in our arsenal that allow us to do so?</strong> <br></p><h2><strong>The Breakdown</strong></h2><p>Here is a detailed breakdown of each DARCC layer, with tools that we think are worthwhile knowing to apply these best practices. </p><h3><strong>Dependency</strong></h3><table><tbody><tr><td><p><strong> Best Practice</strong></p></td><td><p><strong>Implementation / Method</strong></p></td><td><p><strong>Tool </strong></p></td></tr><tr><td><p><strong>As Code</strong></p></td><td><p>SBOM manifests</p></td><td><p><a title="https://github.com/spdx" href="https://github.com/spdx">SPDX</a>, <a title="https://snyk.io/product/snyk-cloud/" href="https://snyk.io/product/snyk-cloud/">SnykCloud</a></p></td></tr><tr><td><p><strong>Zero Trust</strong></p></td><td><p>Minimize; silo; limit</p></td><td><p>Build tools, <a title="https://snyk.io/" href="https://snyk.io/">Snyk</a></p></td></tr><tr><td><p><strong>Event Driven</strong></p></td><td><p>CI/CD</p></td><td><p></p></td></tr><tr><td><p><strong>Decouple</strong></p></td><td><p>Each service is siloed</p></td><td><p></p></td></tr><tr><td><p><strong>Unified View</strong></p></td><td><p>Dev Portals</p></td><td><p><a title="https://backstage.io/" href="https://backstage.io/">Backstage</a>, <a title="https://www.getport.io/" href="https://www.getport.io/">GetPort.io</a></p></td></tr><tr><td><p><strong>Approachable</strong></p></td><td><p>Dev Portals</p></td><td><p><a title="https://backstage.io/" href="https://backstage.io/">Backstage</a>, <a title="https://www.getport.io/" href="https://www.getport.io/">GetPort.io</a></p></td></tr></tbody></table><h3><br><strong>Access Control</strong></h3><table><tbody><tr><td><p><strong> Best Practice</strong></p></td><td><p><strong>Implementation / Method</strong></p></td><td><p><strong>Tool </strong></p></td></tr><tr><td><p><strong>As Code</strong></p></td><td><p>Policy as Code</p></td><td><p><a title="https://www.openpolicyagent.org/" href="https://www.openpolicyagent.org/">OPA</a>, <a title="https://www.cedarpolicy.com/" href="https://www.cedarpolicy.com/">Cedar</a>, <a title="https://www.permit.io/" href="https://www.permit.io/">Permit.io</a></p></td></tr><tr><td><p><strong>Zero Trust</strong></p></td><td><p>Policy Decision Point</p></td><td><p><a title="https://www.openpolicyagent.org/" href="https://www.openpolicyagent.org/">OPA</a> + <a title="https://github.com/permitio/opal" href="https://github.com/permitio/opal">OPAL</a></p></td></tr><tr><td><p><strong>Event Driven</strong></p></td><td><p>Policy update stream</p></td><td><p><a title="https://github.com/permitio/opal" href="https://github.com/permitio/opal">OPAL</a>, <a title="https://github.com/authzed/spicedb" href="https://github.com/authzed/spicedb">Spice DB</a></p></td></tr><tr><td><p><strong>Decouple</strong></p></td><td><p>Policy from Code, Code from Data</p></td><td><p><a title="https://www.openpolicyagent.org/" href="https://www.openpolicyagent.org/">OPA</a> + <a title="https://github.com/permitio/opal" href="https://github.com/permitio/opal">OPAL</a></p></td></tr><tr><td><p><strong>Unified View</strong></p></td><td><p>Audit Logs, Decision Logs</p></td><td><p>Logging, <a title="https://www.permit.io/" href="https://www.permit.io/">Permit.io</a>, <a title="https://frontegg.com/" href="https://frontegg.com/">Frontegg</a></p></td></tr><tr><td><p><strong>Approachable</strong></p></td><td><p>Low-code Control Interfaces</p></td><td><p><a title="https://www.permit.io/" href="https://www.permit.io/">Permit.io</a></p></td></tr></tbody></table><p></p><h3><strong>Runtime</strong></h3><table><tbody><tr><td><p><strong> Best Practice</strong></p></td><td><p><strong>Implementation / Method</strong></p></td><td><p><strong>Tool </strong></p></td></tr><tr><td><p><strong>As Code</strong></p></td><td><p>Policy as Code</p></td><td><p><a title="https://github.com/open-policy-agent/gatekeeper" href="https://github.com/open-policy-agent/gatekeeper">GateKeeper</a></p></td></tr><tr><td><p><strong>Zero Trust</strong></p></td><td><p>Containers</p></td><td><p>Docker </p></td></tr><tr><td><p><strong>Event Driven</strong></p></td><td><p>RASP, WAF</p></td><td><p><a title="https://falco.org/" href="https://falco.org/">Falco</a></p></td></tr><tr><td><p><strong>Decouple</strong></p></td><td><p>Security tests standalone (SAST,  DAST)</p></td><td><p><a title="https://snyk.io/product/snyk-code/" href="https://snyk.io/product/snyk-code/">Snyk Code</a></p></td></tr><tr><td><p><strong>Unified View</strong></p></td><td><p>SIEM</p></td><td><p></p></td></tr><tr><td><p><strong>Approachable</strong></p></td><td><p>Security Control Panel</p></td><td><p>Know one? <a title="https://permit-io.slack.com/" href="https://permit-io.slack.com/">Let us know</a></p></td></tr></tbody></table><h3><br><strong>Configuration</strong></h3><table><tbody><tr><td><p><strong> Best Practice</strong></p></td><td><p><strong>Implementation / Method</strong></p></td><td><p><strong>Tool </strong></p></td></tr><tr><td><p><strong>As Code</strong></p></td><td><p>Configuration as Code / Infrastructure as Code</p></td><td><p><a title="https://www.terraform.io/" href="https://www.terraform.io/">Terraform</a>, <a title="https://www.pulumi.com/" href="https://www.pulumi.com/">Pulumi</a>, <a title="https://helm.sh/" href="https://helm.sh/">Helm</a></p></td></tr><tr><td><p><strong>Zero Trust</strong></p></td><td><p>SDLC policies</p></td><td><p><a title="https://www.conftest.dev/" href="https://www.conftest.dev/">Conftest</a>, <a title="https://www.datree.io/" href="https://www.datree.io/">Datree</a>, <a title="https://www.checkov.io/" href="https://www.checkov.io/">Checkov</a></p></td></tr><tr><td><p><strong>Event Driven</strong></p></td><td><p>Gitops</p></td><td><p></p></td></tr><tr><td><p><strong>Decouple</strong></p></td><td><p>Config loading hierarchy</p></td><td><p>E.g. Python’s <a title="https://pypi.org/project/python-decouple/" href="https://pypi.org/project/python-decouple/">Decouple</a></p></td></tr><tr><td><p><strong>Unified View</strong></p></td><td><p>Configuration Management</p></td><td><p><a title="https://configu.com/" href="https://configu.com/">Configu</a></p></td></tr><tr><td><p><strong>Approachable</strong></p></td><td><p>Dev Portals</p></td><td><p><a title="https://backstage.io/" href="https://backstage.io/">Backstage</a>, <a title="https://www.getport.io/" href="https://www.getport.io/">GetPort.io</a></p></td></tr></tbody></table><h3><br><strong>Containers</strong></h3><table><tbody><tr><td><p> <strong>Best Practice</strong></p></td><td><p><strong>Implementation / Method</strong></p></td><td><p><strong>Tool </strong></p></td></tr><tr><td><p><strong>As Code</strong></p></td><td><p>Infrastructure as code</p></td><td><p>Docker-file, Helm charts, <a title="https://www.env0.com/" href="https://www.env0.com/">Env0</a></p></td></tr><tr><td><p><strong>Zero Trust</strong></p></td><td><p>Provenance and Integrity</p></td><td><p><a title="https://helm.sh/" href="https://helm.sh/">Helm</a>, OCI signatures</p></td></tr><tr><td><p><strong>Event Driven</strong></p></td><td><p>CI/CD</p></td><td><p></p></td></tr><tr><td><p><strong>Decouple</strong></p></td><td><p>Compute, Infra, Container</p></td><td><p>Cloud Services</p></td></tr><tr><td><p><strong>Unified View</strong></p></td><td><p>Services inventory</p></td><td><p><a title="https://www.datadoghq.com/" href="https://www.datadoghq.com/">DataDog</a>, <a title="https://prometheus.io/" href="https://prometheus.io/">Prometheus</a></p></td></tr><tr><td><p><strong>Approachable</strong></p></td><td><p>Containerized Envs on demand</p></td><td><p><a title="https://www.raftt.io/" href="https://www.raftt.io/">Raftt.io</a>, <a title="https://velocity.tech/" href="https://velocity.tech/">Velocity</a></p></td></tr></tbody></table><p>This breakdown provides an example of tools we can utilize to manage all of the best practices we need to apply to each layer, giving us a full overview of our company’s security posture, with all its potential gaps. </p><img src="https://media.graphassets.com/jLx0bS9Q526tIZmVjwQf" alt="unnamed (1).png" title="unnamed (1).png" width="1432" height="769" /><p><em>An example of a “DARCC Map” mapping each tool used to achieve best practices</em></p><h2><strong>Who should be using DARCC? </strong></h2><p><strong>DARCC is relevant for anyone building software</strong> (Developers, DevOps, SREs, AppSec) and everyone managing the overall picture (Architects, Security Analysts, AppSec, the management team) and it can be a valuable tool to speed up processes on both those sides. </p><p><strong>For management,</strong> this can be a guiding principle. Whether you’re building something new, refactoring something, or working on new architecture, you can start with a DARCC map to quickly highlight where you have answers and where you have gaps you need to address.  </p><p><strong>For developers</strong>, DARCC is foremost a checklist. When you build something, you want it to be secure, and by going through the DARCC map you can make sure that you are addressing every part of the security landscape. </p><p>A DARCC map can also be a great way to <strong>communicate your security posture</strong> <strong>as part of your docs</strong>. As much of the documentation for SaaS offerings nowadays tends to include a section on security, having a DARCC map as part of that security section could significantly speed up someone&#39;s ramping up into the project and finding the answers they need to make sure your product is up to their standards. </p><p>A DARCC map can be used as a baseline for a <strong>SWOT analysis</strong> to identify your strengths, your gaps, and where you need to invest your time when dealing with technical debt. </p><p>It can also be a base to decide which tools you need to invest in, knowing what you have in place, knowing which gaps you have, prioritizing them, and understanding which ones are more critical and which ones you need to bring in next. </p><p>Eventually, this DARCC map will look different depending on how you build and run your software and the interaction that you have with your vendors and customers. Regardless, creating this type of map for an average midsize SaaS offering would probably take you not more than a few hours and will provide you with a tool to communicate internally, share it as a part of, or even eventually, instead of a security questionnaire, and most importantly the ability to find security gaps in the solution you are building. </p><p>For a more detailed overview of this methodology, with a specific example of how you can apply this to what you are building, <a title="https://www.youtube.com/watch?v=wX5wKA6c4KA" href="https://www.youtube.com/watch?v=wX5wKA6c4KA"><u>check out Or Wies’s full DevSecCon talk here</u></a>. </p>]]></content>
        <author>
            <name>Or Weis</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Permit.io's Top 6 Dev Podcasts of 2022]]></title>
        <id>podcasts2022</id>
        <link href="https://www.permit.io/blog/podcasts2022"/>
        <updated>2022-12-20T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Permit.io's top 6 developer podcasts of 2022 that are definitely worth your time and attention]]></summary>
        <content type="html"><![CDATA[<p>Podcasts are a super popular way for developers to stay up-to-date with the latest trends, techniques, and tools in the tech industry. With so many podcasts available, choosing which ones to listen to it can be overwhelming. We’re here to give you our top six favorite ones, which we loved listening to (and sometimes even being hosted on  😉).<br><br><strong>Here are our top six developer podcasts of 2022 that are definitely worth your time and attention:</strong></p><ol><li><div><p><a title="https://softwareengineeringdaily.com/category/all-episodes/exclusive-content/Podcast/" href="https://softwareengineeringdaily.com/category/all-episodes/exclusive-content/Podcast/"><strong>Software Engineering Daily</strong></a><strong> - Something for everyone </strong>Software Engineering Daily is a daily podcast that covers a wide range of topics related to software development. This podcast has something for every developer - from machine learning and artificial intelligence to microservices and cloud computing. <br><br>Jeff Meyerson, the founder and one of the hosts, who sadly passed away in July, was an experienced software engineer and brought a wealth of knowledge and expertise to the show. The show continues to be hosted by a wonderful team of fascinating, experienced leaders in the dev world. They frequently interview industry experts and thought leaders, providing listeners with valuable insights and practical advice.<br><br>Check out the episode on <a title="https://softwareengineeringdaily.com/2022/08/15/permissions-and-access-control-with-or-weis/" href="https://softwareengineeringdaily.com/2022/08/15/permissions-and-access-control-with-or-weis/"><u>Permissions and Access-control</u></a> with our CEO Or Weis.</p></div></li><li><div><p><a title="https://www.infoq.com/the-infoq-podcast/" href="https://www.infoq.com/the-infoq-podcast/"><strong>The InfoQ Podcast </strong></a><strong>- The software dev angle<br><br></strong>The InfoQ Podcast explores the latest ideas and techniques in software development while focusing specifically on software development and related topics rather than broader tech industry topics. Each episode features interviews with experts in the field and discussions on current events and emerging trends in the tech industry. <br><br>The podcast is aimed at professionals working in software development and related fields and covers a wide range of topics, including agile methodologies, cloud computing, DevOps, microservices, and more. This makes InfoQ a comprehensive resource for staying up to date on the latest trends and techniques in the field.</p></div></li><li><div><p><a title="https://www.softwareatscale.dev/about" href="https://www.softwareatscale.dev/about"><strong>Software at Scale</strong></a><strong> - Aiming for BIG <br></strong><br>Software at Scale is a podcast that examines the technical and organizational challenges of building and maintaining large-scale software systems. The show features interviews with software engineering leaders and practitioners who share their experiences and insights on topics such as distributed systems, microservices, cloud computing, data engineering, and DevOps. Some podcast guests have included engineers from companies like Google, Airbnb, Dropbox, and Netflix. <br><br>The podcast is hosted by engineering leaders at Google. It aims to provide valuable insights and practical advice to software engineers and technology leaders who are looking to improve their skills and build successful software systems at scale. It is a great resource for staying up to date with the latest trends and best practices in software engineering and for gaining important insights from experts in the field.<br><br>Check out “<a title="https://www.softwareatscale.dev/p/software-at-scale-46-authorization#details" href="https://www.softwareatscale.dev/p/software-at-scale-46-authorization#details"><u>Authorization with Or Weis: RBAC, ABAC, GBAC, OPAL, and even more acronyms in this deep-dive of permission management.</u></a>”</p></div></li><li><div><p><a title="https://thenewstack.io/podcasts/" href="https://thenewstack.io/podcasts/"><strong>The New Stack Podcast </strong></a><strong>- The business side of dev<br><br></strong>The New Stack Podcast focuses on the intersection of technology and business, covering a wide range of topics, including software development, cloud computing, DevOps, and more. While many other tech podcasts tend to focus more on the technical aspects of the industry, The New Stack looks at the business implications of technology and how it can be used to drive innovation and growth.</p></div></li><li><div><p><a title="https://changelog.com/podcast" href="https://changelog.com/podcast"><strong>The Changelog Podcast </strong></a><strong>- Getting personal </strong><br><br>The Changelog focuses on the people behind the software and the stories they have to tell. Rather than simply discussing the technical aspects of software and technology, it aims to highlight the experiences and perspectives of individuals who create and work with these tools. This allows listeners to gain a deeper understanding of the people and processes involved in the development world. <br><br>Interviewing industry leaders, developers, and maintainers of popular open-source projects, the podcast covers a wide range of topics, including programming languages, software development methodologies, and the culture of the tech industry.</p></div></li><li><div><p><a title="https://whatthedev.buzzsprout.com/" href="https://whatthedev.buzzsprout.com/"><strong>What the dev? </strong></a><strong>- Short and to the point<br><br></strong>What the Dev? Is a podcast by the SD Times editorial team which covers the biggest and newest topics in software and technology. The podcast provides short, high-level introductions to the latest trends in software development - one spoonful at a time, with episodes averaging around 15 minutes.<br><br>You can listen to an episode with one of our own devs, Oded Ben David, in an episode where he discusses <a title="https://whatthedev.buzzsprout.com/673192/11715206-setting-up-app-permissions-with-permit-io-episode-187" href="https://whatthedev.buzzsprout.com/673192/11715206-setting-up-app-permissions-with-permit-io-episode-187"><u>Setting up app permissions with Permit.io</u></a>. </p></div></li></ol><p>These are our six top developer podcasts of 2022! Each one of them offers something unique and valuable to developers, whether it be practical advice, industry insights, or inspiration. Whether you are a seasoned developer or just starting out in the field, these podcasts will surely provide something of interest and value to you. </p><p>Know of other podcasts we should give a listen to? Want to host us? Hit us up in our <a title="https://io.permit.io/permitslack" href="https://io.permit.io/permitslack">Slack community</a></p>]]></content>
        <author>
            <name>Daniel Bass</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[What is Policy as Code?]]></title>
        <id>what-is-policy-as-code</id>
        <link href="https://www.permit.io/blog/what-is-policy-as-code"/>
        <updated>2022-12-13T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[What is Policy as Code, what are the benefits of implementing it, and how can we allow different stakeholders access to it?]]></summary>
        <content type="html"><![CDATA[<h2>TL;DR</h2><p>⁠Policy as code is a concept that refers to the practice of defining and managing policies using code. This allows policies to be managed and enforced using the same tools and processes that are used for managing and deploying software.</p><h2>The Benefits of Policy as Code</h2><p>There are many benefits to having policy as code, including improved consistency, accuracy, and traceability.</p><p>Defining policies using code provides organizations with the ability to <strong>ensure policies are consistently enforced across different systems and environments</strong>, which can help prevent policy violations and reduce the risk of unauthorized access to sensitive data or systems.</p><p>Policy as code allows them to be more easily managed and updated. When managed as code, policies can be managed using the same tools and processes used to manage and deploy software. This makes it easier to <strong>track changes to policies over time</strong>, <strong>roll back changes</strong> if necessary, and in general, enjoy the well-thought-through best practices of the code world (e.g., GitOps).<br><br>Now that we have gone over the benefits of having policy as code let’s talk about what this would look like in practice!</p><h2>Examples of Policy as Code</h2><p>One example of a policy as code implementation is <strong>Rego</strong> - the language used by <a title="https://www.permit.io/blog/introduction-to-opal" href="https://www.permit.io/blog/introduction-to-opal"><u>Open Policy Agent (OPA)</u></a>. Rego is a high-level declarative language that is designed specifically for defining and managing policies. It is a Prolog / Datalog derivative language, and it allows policies to be defined using simple sets of rules, which can be handled recursively by the OPA engine.</p><p>Here is a super simple example of a policy written in Rego:</p><pre><code>package example

import input

default allow = false

allow {
  input.user.role == &quot;admin&quot;
  input.resource.category == &quot;sensitive&quot;
}</code></pre><p>In this example, the policy specifies that a user is only allowed to access a resource if they have the &quot;admin&quot; role and the resource is in the &quot;sensitive&quot; category. The policy is defined using simple, declarative statements, and it can be easily understood and modified by anyone familiar with the language.</p><p>That being said, Rego isn’t your run-of-the-mill programming language like Python or Java and can have somewhat of a steep learning curve. To learn more, check out these articles about <a title="https://www.permit.io/blog/implement-rbac-using-opa" href="https://www.permit.io/blog/implement-rbac-using-opa"><u>implementing RBAC with OPA</u></a> and <a title="https://www.permit.io/blog/implement-abac-using-opa" href="https://www.permit.io/blog/implement-abac-using-opa"><u>Implementing ABAC with OPA</u></a>. </p><p>OPA’s Rego is just one example of a policy-as-code language. Many other such languages exist (Such as Google Zanzibar Schemas, <a title="https://www.cedarpolicy.com/" href="https://www.cedarpolicy.com/"><u>Cedar</u></a>, <a title="https://www.osohq.com/" href="https://www.osohq.com/"><u>OSO</u></a>, and many more), with each of them having its own supporting tools. At the end of the day, picking the correct language and tools will depend on the specific needs and requirements of what you’re building. <br>-- ⁠Want to learn more about the differences between <a target='_blank' title="/blog/opa-vs-cedar" href="/blog/opa-vs-cedar">Rego and Cedar - check out this article</a>.</p><h2>Policy as low/no code </h2><p>While policy-as-code should be managed in a code repository, <strong>that doesn’t mean it should be authored as pure code</strong>. By simplifying policy creation, we can make our work as developers easier, free ourselves  from becoming bottlenecks, and empower other critical stakeholders (e.g., product managers, security, compliance, support, professional services, and sales) to participate in the policy creation process.</p><p>The way to achieve this is through using solutions that provide low-code interfaces that generate policy code right into a Git repository (Like <a title="https://permit.io" href="https://permit.io"><u>Permit.io</u></a> 😉). This allows developers to <strong>test, benchmark, and even code review the generated code</strong> - all while maintaining the ability to <strong>add more code on their own</strong> for the more advanced cases.<br><br>Using low-code policy interfaces also reduces dependence on a single policy engine and allows for embracing a more polyglot dynamic approach to software (as you would anyway - it&#39;s all about using the right tool for the right job).<br></p><img src="https://media.graphassets.com/i3slhcCBRCKFSsoFGyBd" alt="unnamed.png" title="unnamed.png" width="972" height="815" /><p><em>Permit.io’s no-code UI, which generates RABC and ABAC policies as code. </em></p><p>Want to learn more about authorization best practices? Join our <a title="https://io.permit.io/permitslack" href="https://io.permit.io/permitslack"><u>Slack community</u></a>, where there are hundreds of devs building and discussing authorization.</p>]]></content>
        <author>
            <name>Or Weis</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[The Developer’s Guide to Identity Access Management Buzzwords]]></title>
        <id>iam-buzzwords</id>
        <link href="https://www.permit.io/blog/iam-buzzwords"/>
        <updated>2022-12-11T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[IAM is huge in DevSecOps, with seemingly infinite buzzwords and terms. Here are the main ones every engineer and security professional should know.]]></summary>
        <content type="html"><![CDATA[<h2>What is IAM?</h2><p><strong>Identity and access management</strong> (IAM) is the processes and technologies used to manage the identities of users and the access they have to different systems and resources. IAM can be divided into three main parts - <strong>authentication</strong> (verifying a user&#39;s identity), <strong>authorization</strong> (granting or denying access to resources), and <strong>identity management</strong> (creating, updating, and deleting identity records and associated information). IAM systems are often used to improve security, simplify access management, and reduce the risk of unauthorized access to sensitive data or systems.<br><br>IAM works like a waterfall: </p><img src="https://media.graphassets.com/9LDi6bQzSmKfCnj8J90W" alt="image 22.png" title="image 22.png" width="3090" height="1481" /><p>Information flows from the organization side to products used by the organization, starting at the <strong>identity provider</strong> to <strong>authentication</strong> at a product’s gateway, and finally to <strong>authorization</strong> within the product itself.</p><p>Let’s Zoom in on each of these —</p><p></p><h2>Identity management</h2><p>Identity management solutions help organizations to securely manage the identities of their users and control access to their applications and resources. <br>Identity providers and the identity management process, in general, act as the <strong>main source of truth</strong> for Authentication and Authorization.</p><p>Leading Identity management services include:<br><a title="https://www.okta.com/" href="https://www.okta.com/">Okta</a>, <a title="https://azure.microsoft.com/en-us/products/active-directory/" href="https://azure.microsoft.com/en-us/products/active-directory/">Microsoft Azure Active Directory</a>, <a title="https://www.onelogin.com/" href="https://www.onelogin.com/">OneLogin</a>, <a title="https://www.pingidentity.com/en.html" href="https://www.pingidentity.com/en.html">Ping Identity</a>, <a title="https://cloud.google.com/identity-platform" href="https://cloud.google.com/identity-platform">Google Identity Platform</a></p><p>Key Identity management Buzzwords:</p><ul><li><div><p><strong>Single sign-on (SSO)</strong>: A system that allows users to log in to multiple applications using a single set of credentials. This can make it easier for users to access the resources they need, and it can also reduce the number of passwords that need to be managed and remembered.</p></div></li><li><div><p><strong>Identity provider (IdP)</strong>: An identity provider is a service that manages the identities of users and provides authentication services. This might be a separate service, or it might be integrated into other systems.</p></div></li><li><div><p><strong>Federation</strong>: Refers to the process of linking different identity systems so that users can use the same credentials to access multiple systems. This can be useful in situations where multiple systems need to share user information, but each system has its own authentication mechanism. </p></div></li></ul><ul><li><div><p><strong>SAML (Security Assertion Markup Language)</strong>: A standard for securely exchanging authentication and authorization data between different systems. It is often used in enterprise environments to enable single sign-on across multiple applications.<br>SAML is one of the main protocols authentication services would connect to Identity providers.</p></div></li></ul><ul><li><div><p><strong>LDAP (Lightweight Directory Access Protocol)</strong>: A protocol for accessing and managing directory information over a network. It is often used for authentication and authorization in enterprise environments.</p></div></li></ul><h2>Authentication Examples</h2><p>The process of verifying a user&#39;s identity. This is typically done by requiring the user to provide some kind of credentials, such as a username and password, a fingerprint, or a facial recognition scan.</p><p>Leading authentication services include:<br><a title="https://auth0.com/" href="https://auth0.com/">Auth0</a>, <a title="https://aws.amazon.com/cognito/" href="https://aws.amazon.com/cognito/">AWS Cognito</a>, <a title="https://supertokens.com/" href="https://supertokens.com/">SuperTokens</a>, <a title="https://fusionauth.io/" href="https://fusionauth.io/">FusionAuth</a>, <a title="https://Magic.link" href="https://Magic.link">Magic.link</a>, <a title="https://stytch.com/" href="https://stytch.com/">Stych</a>, <a title="https://www.descope.com/" href="https://www.descope.com/">Descope</a>.</p><p>Key Authentication Buzzwords:</p><ul><li><div><p>OAuth: OAuth is an open standard for <a title="https://www.permit.io/blog/what-is-authorization" href="https://www.permit.io/blog/what-is-authorization"><u>authorization</u></a> (but de-facto powers a lot of authentication) that allows users to securely access resources on one site using the credentials of another site. OAuth is often used to allow users to log in to third-party applications using their Google, Facebook, or other social media accounts.</p></div></li><li><div><p>OpenID Connect: OpenID Connect is a protocol that builds on top of OAuth to provide authentication as well as authorization. It allows users to securely log in to a web application using their existing credentials from another site.</p></div></li><li><div><p>Multi-factor authentication (MFA): Multi-factor authentication is a security system that requires users to provide multiple pieces of evidence to prove their identity. This might include something they know (like a password), something they have (like a security token), and something they are (like a biometric factor like a fingerprint or a facial recognition scan).</p></div></li><li><div><p>JSON Web Tokens (JWTs): JWTs are a compact, URL-safe way of representing claims to be transferred between two parties. They are often used for authorization and can be signed using a secret key or a public/private key pair. It is the main connection point between authentication and authorization solutions. </p></div></li><li><div><p>Passwordless authentication: a method of authentication that does not require users to enter a password in order to access a system or service. Instead, users are authenticated using other methods, such as a biometric factor (like a fingerprint or facial recognition), a security token, or a one-time code sent to their email or mobile device. It is becoming increasingly popular as a way to improve security and user experience (by reducing dependency on stupid passwords 😅) </p></div></li><li><div><p>WebAuthn: is a web standard that defines an API for performing authentication using various authentication methods. This includes methods like biometric authentication (using a fingerprint or facial recognition), security keys (using a hardware token), and other methods that are more secure and user-friendly than traditional password-based authentication.</p></div></li></ul><h2>Authorization Examples (aka Permissions)</h2><p>The process of granting or denying access to resources based on a user&#39;s identity and the permissions that have been assigned to them. This is typically done by comparing the user&#39;s credentials against a set of rules or policies to determine what they are allowed to access.</p><p>Leading Authorization services include:<br><a title="https://permit.io" href="https://permit.io">⁠Permit.io</a>, <a title="https://authzed.com/" href="https://authzed.com/">AuthZed</a>, <a title="https://www.ory.sh/keto/" href="https://www.ory.sh/keto/">Ory Keto</a>, <a title="https://www.styra.com/styra-das/" href="https://www.styra.com/styra-das/">Styra DAS</a> </p><p>Key Authorization Buzzwords:</p><ul><li><div><p><a title="https://www.permit.io/blog/rbac-with-permit" href="https://www.permit.io/blog/rbac-with-permit">Role-based access control</a> (RBAC):  The bread and butter of access control; almost every product developer gets here - thanks to its simplicity, it has become quite popular and common.<br>Role-based access control is a method of access control that assigns permissions to users based on their role within an organization. For example, an administrator might have more access than a regular user.</p></div></li><li><div><p><a title="https://www.permit.io/blog/what-is-abac" href="https://www.permit.io/blog/what-is-abac">Attribute-based access control </a>(ABAC) is a method that uses attributes (or &quot;properties&quot; of a user or resource) to determine whether a user is authorized to access a particular resource. This is in contrast to other forms of access control, such as role-based access control (RBAC) or discretionary access control (DAC), which use fixed roles or permissions to determine access.<br><br>ABAC allows for more fine-grained and flexible access control, as it allows permissions to be based on multiple attributes and dynamically evaluated. For example, a user might be granted access to a particular resource if they have a certain role and are accessing the resource from a specific location at a specific time of day.</p></div></li><li><div><p><a title="https://www.permit.io/blog/what-is-rebac" href="https://www.permit.io/blog/what-is-rebac">Relationship-based access control (ReBAC)</a> is a method of access control that takes into account the relationships between different users and resources when determining access permissions. This is in contrast to (RBAC), which assigns permissions based on a user&#39;s role within an organization, or discretionary access control (DAC), which assigns permissions based on the user&#39;s individual permissions.<br><br>ReBAC is more powerful than RBAC but can often be more limited when compared to ABAC.<br>ReBAC is perfect for describing groups, hierarchies, and forms of cascading or nested relationships. The most classic example is file systems, where access to a folder implicitly grants access to anything nested under it. </p></div></li></ul><ul><li><div><p><a title="https://www.permit.io/blog/what-is-policy-as-code" href="https://www.permit.io/blog/what-is-policy-as-code">Policy as code:</a> the practice of defining and managing access-control policies using code. This allows policies to be managed and enforced using the same tools and processes that are used for managing and deploying software. This makes it easier to track changes to policies over time, to roll back changes if necessary, and in general, to enjoy the well-thought-through best practices of the world of code - e.g., Gitops.</p></div></li><li><div><p><a title="https://www.permit.io/blog/introduction-to-opa" href="https://www.permit.io/blog/introduction-to-opa"><u>OPA (Open Policy Agent)</u></a>: A popular open-source (CNCF project) policy engine that enables developers to externalize and manage their policies in a uniform and predictable way. OPA provides a high-level declarative language (<a title="https://www.permit.io/blog/implement-rbac-using-opa" href="https://www.permit.io/blog/implement-rbac-using-opa"><u>Rego</u></a>) for specifying policies, as well as an engine for enforcing those policies at runtime.</p></div></li><li><div><p><a title="https://www.permit.io/blog/introduction-to-opal" href="https://www.permit.io/blog/introduction-to-opal"><u>OPAL (Open Policy Administration Layer) </u></a>- is an open-source project to manage multiple instances of OPA in a real-time, event-driven fashion, delivering the policy and data each agent needs (and only those it needs).</p></div></li><li><div><p><a title="https://www.permit.io/blog/policy-engines" href="https://www.permit.io/blog/policy-engines">Google Zanzibar</a>: a white paper published by Google describing how they use ReBAC via a graph-based system to manage permissions at scale for products with high volume usages (more than tens of million users) such as Drive and Youtube. The whitepaper, which didn’t include the source code - unleashed a wave of clones, none of which to date has actually fully implemented the offering.</p></div></li></ul><p>Still confused? Want to learn more about IAM? Join our <a title="https://io.permit.io/permitslack" href="https://io.permit.io/permitslack">Slack community</a>, where there are hundreds of devs building and discussing IAM.</p>]]></content>
        <author>
            <name>Or Weis</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[DARCC]]></title>
        <id>darcc</id>
        <link href="https://www.permit.io/blog/darcc"/>
        <updated>2022-11-12T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Breaking down modern applications we can identify the key layers -DARCC (Dependency, Access-Control, Runtime, Configuration, Container) every developers needs to cover for their applications to stay secure and out of the dark ;-)]]></summary>
        <content type="html"><![CDATA[<p>Breaking down modern applications we can identify the key layers -DARCC (Dependency, Access-Control, Runtime, Configuration, Container) every developers needs to cover for their applications to stay secure and out of the dark ;-)</p><ul><li><div>Dependency - How do you secure your software supply chain?</div></li></ul><ul><li><div>Access-Control - How do you enforce your app&#39;s policies ?</div></li><li><div>Runtime - How do you make sure your code behaves as you expect?</div></li><li><div>Configuration - How do you make sure your application is set and deployed correctly?</div></li><li><div>Container - How do you maintain the right environment to run your app?</div></li></ul><iframe
          width="960"
          height="569"
          frameBorder="0"
          allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
          allowFullScreen
          title="https://docs.google.com/presentation/d/e/2PACX-1vQLDKEJkvw0LIDI_931g1sCukes8kkDhq3e_oe5OC6FfsfUDsnl0puD2nEwO0kABJ9ZyU0oz2Ht-E_l/embed?start=false&loop=false&delayms=3000"
          src="https://docs.google.com/presentation/d/e/2PACX-1vQLDKEJkvw0LIDI_931g1sCukes8kkDhq3e_oe5OC6FfsfUDsnl0puD2nEwO0kABJ9ZyU0oz2Ht-E_l/embed?start=false&loop=false&delayms=3000"
        ></iframe><p><br><br></p><p>Want to dive deeper into DARCC ? :  <a target='_blank' title="https://docs.google.com/presentation/d/10NVDtITZ3HSRlqdWKX5SP-wSqso0hgUGdxooGpDJyhg/edit#slide=id.g126c1ebca6c_0_479" href="https://docs.google.com/presentation/d/10NVDtITZ3HSRlqdWKX5SP-wSqso0hgUGdxooGpDJyhg/edit#slide=id.g126c1ebca6c_0_479">View the slides here</a></p>]]></content>
        <author>
            <name>Or Weis</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Intellyx BrainBlog: Implementing Authorization in your Apps Doesn’t Have to be a Nightmare]]></title>
        <id>intellyx-implementing-authz</id>
        <link href="https://www.permit.io/blog/intellyx-implementing-authz"/>
        <updated>2022-10-13T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[An Intellyx BrainBlog by Jason Bloomberg, for Permit.io]]></summary>
        <content type="html"><![CDATA[<p><em><strong>SCRUM MASTER: Our application is almost ready to go live. One more sprint should do it.</strong></em></p><p><em><strong>DEV TEAM: Hooray!</strong></em></p><p><em><strong>SCRUM MASTER: There’s just one more thing. We need to implement authorization.</strong></em></p><p><em><strong>DEV TEAM: Didn’t we take care of that when we implemented the login screen in sprint #1?</strong></em></p><p><em><strong>SCRUM MASTER: That was authentication. Now we need to set up access by roles – customer, admin, etc. Oh yes, and by attributes as well – only the users who pay for a service can access it, that kind of thing. Think you folks can handle it? You have two weeks. And don’t worry, you’ll get some home-brewed beer at the wrap party if you finish on time.</strong></em></p><p>The scenario above may be oversimplified, but it’s surprising how many organizations give authorization a low priority when building applications. </p><p>The problem is subtly complex – how to handle different types of admins? What to do if someone changes roles? How do attributes and roles combine to decide the proper permissions? Who can manage permissions? The list goes on. </p><p>And to make matters worse, hand-coding authorization can be a nightmare, as every capability in the application may require some sort of custom permissioning. Further complicating matters: authorization may depend upon dynamic data which may come from outside the organization.</p><p>Fortunately, there are simpler, more secure approaches than hand-coding everything. Here’s a closer look.<br></p><h2>The Cloud Native Context for Authorization</h2><p>In <a title="https://www.permit.io/blog/authorization-the-cloud-native-way" href="https://www.permit.io/blog/authorization-the-cloud-native-way"><u>part one of this series</u></a>, I framed the discussion of cloud-native authorization by delineating six core best practices, including a declarative control plane, zero trust, stateless microservices, and more.</p><p>In <a title="https://www.permit.io/blog/homebrewing-permissions-with-os" href="https://www.permit.io/blog/homebrewing-permissions-with-os"><u>the second article</u></a>, my colleague Jason English discussed the challenges of ‘home brewing’ permissions – and how important open-source software and open protocols like Open Policy Agent (OPA) and Open Policy Administration Layer (OPAL) are for implementing flexible permission rules that don’t require ongoing manual rewrites.</p><p>Open-source software and open protocols, however, are only part of the solution to implementing authorization in cloud-native applications. </p><p>Remember, declarative control planes are a core cloud-native best practice. Control planes are abstractions that separate the underlying software implementation from the configurations that drive the behavior of the software.</p><p>Just so with authorization. The software necessary to properly implement authorization infrastructure should ideally support the configuration-centric control plane instead of requiring developers to code permissions into their software directly.<br></p><h2>The Three Aspects of Cloud Native Authorization Configuration</h2><p>Above the control plane – where developers set up authorization in their applications, and admins configure the permissions – is where the full story of cloud-native authorization plays out.</p><p>As with other control planes, there should be a no-code user interface that supports the manual configuration of roles and attributes and the permissions associated with them, as well as other business logic specific to authorization.</p><p>Who is authorized to do what and why, after all, may depend on many factors and may also change over time. Organizations may have arbitrarily complex permissions policies. Supporting the configuration of such policies is straightforward with a no-code capability like Permit.io’s.</p><p>Third, developers need to be able to access underlying authorization infrastructure via APIs. APIs, in fact, enforce the control plane abstraction for permissions as well as declarative control planes while allowing developers to build authorization directly into their application microservices.</p><p>Permit.io’s authorization platform makes incorporating APIs into cloud-native applications straightforward because the behavior of the APIs is transparent. </p><p>Where before, implementing permissions required a few dozen lines of code and references to static elements like ‘ADMIN’ or ‘EDITOR,’ leveraging the Permit.io API requires a single line of code: </p><pre><code>if (await permit.check(user, &quot;close&quot;, `doc:${doc.id}`)) {
	// allowed to close issue
}</code></pre><p>In the example above, <code>permit.check</code> accesses an API that hides its underlying implementation. That code may run in the same application context as the application itself, or for that matter, it may be running on a cloud somewhere.</p><h2>The Power of SaaS-Based Authorization</h2><p>Permit.io runs its authorization infrastructure as a SaaS-based offering, with all the benefits of SaaS, including pay-as-you-go pricing, built-in scale and reliability, and behind-the-scenes maintenance and security.</p><p>Furthermore, this SaaS offering supports APIs, low-code workflow construction, and a GUI control plane dashboard, giving Permit.io customers all the flexibility they require to implement cloud-native authorization in their applications.</p><h2>The Intellyx Take</h2><p>The most familiar approach to implementing application permissions is role-based access control (RBAC), where admins assign permissions and users to roles. Everyone with a particular role thus has the permissions assigned to that role.</p><p>Sometimes RBAC is sufficient – but in many situations, organizations require finer-grained control over permissions. In those situations, relationship-based access control (ReBAC) or attribute-based access control (ABAC) become necessary.</p><p>Development teams looking to roll their own authorization (like the simplistic example at the top of this article) may find RBAC to be relatively straightforward to implement. Before long, however, stakeholders require ABAC, which presents a far more complex, convoluted challenge for the developers.</p><p>Working with an authorization platform like Permit.io, therefore, is essential for keeping those stakeholders happy, shifting developers’ focus away from complex authorization tasks to features unique to their applications so that they can wrap up their work on time and earn that delicious home-brew at the party on Friday. </p><p><em>Copyright © Intellyx LLC. Permit.io is an Intellyx customer. Intellyx retains final editorial control of this article.</em></p>]]></content>
        <author>
            <name>Jason Bloomberg</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[No-code permissions with Kong and Permit.io]]></title>
        <id>no-code-permissions-with-kong-and-permitio</id>
        <link href="https://www.permit.io/blog/no-code-permissions-with-kong-and-permitio"/>
        <updated>2022-09-29T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Kong is a popular API gateway, but managing access to its APIs and services is hard - especially when required advanced permissions models like RBAC/ABAC/ReBAC]]></summary>
        <content type="html"><![CDATA[<h2>Introduction</h2><p>Kong is one of the most popular API gateways out there; but managing access to API and services behind it can be quite a bit of work especially as the application evolves requiring more and more advanced permissions models (<a title="https://www.permit.io/blog/rbac-with-permit" href="https://www.permit.io/blog/rbac-with-permit">RBAC</a>, <a title="https://www.permit.io/blog/what-is-abac" href="https://www.permit.io/blog/what-is-abac">ABAC</a>, <a title="https://www.permit.io/blog/what-is-rebac" href="https://www.permit.io/blog/what-is-rebac">ReBAC</a>, …) <br>Enter Permit - a full stack permissions service, that can empower you to never have to build permissions again.<br>With a recent update - Permit can now seamlessly integrate with Kong Gateway. And you can add permissions to your API within minutes without having to write a single line of code (unless you want to ;-) ).</p><p>If you have Kong Gateway properly configured to relay requests from your users to your backend, you can easily use Permit.io to authorize requests as they go in, with a real time administration layer that has a nice user interface for everybody in your organization but is policy-as-code behind the scenes.</p><h2>What is Authorization?</h2><p>Authorization means answering the question:</p><p>	Can <strong>some_user</strong> do <strong>some_action</strong> on <strong>some_resource</strong>?</p><p>The simplest way to implement permissions (that is, other than dummy permissions such as “allow everyone who is authenticated”) is called Role-Based Access Control, or RBAC. In RBAC, each<strong> user</strong> is assigned one or more<strong> roles</strong>, and<strong> roles</strong> can have permissions to perform <strong>actions</strong> on classes of<strong> resources</strong>. For example, in a policy, we say that:</p><ul><li><div>	Role <strong>admin</strong> can <strong>read</strong>, <strong>write</strong> and <strong>delete</strong> on <strong>repository</strong></div></li><li><div>	Role <strong>power_user </strong>can <strong>read</strong> and <strong>write</strong> on <strong>repository</strong></div></li><li><div>	Role <strong>viewer </strong>can <strong>read</strong> on <strong>repository</strong></div></li></ul><p>And then we define the following facts:</p><ul><li><div>User <strong>annie@example.com</strong> has role<strong> admin</strong></div></li><li><div>User <strong>bill@example.com</strong> has role<strong> power_user</strong></div></li><li><div>User<strong> carol@example.com</strong> has role<strong> viewer</strong></div></li></ul><p>Not shown is that users may have more than one role, in which case they get the sum of their roles’ permissions.</p><p>Then, let’s say bill wants to write to a repo, we’ll ask the question:</p><ul><li><div>Can <strong>bill@example.com </strong>perform <strong>write </strong>on<strong> repository</strong>?</div></li></ul><p>Since <strong>bill@example.com </strong>has the role <strong>power_user </strong>which can <strong>write</strong> on <strong>repository</strong>, the answer is yes, this is allowed.</p><p>Though not shown in this tutorial, <a target='_blank' title="https://www.permit.io/abac" href="https://www.permit.io/abac">Permit.io also supports ABAC</a>.</p><h2>How This Applies to Kong-Based Applications</h2><p>You’re probably wondering how this applies to HTTP requests, which is what Kong sees. To integrate Permit.io, which works with resources and actions, with Kong, which works with HTTP requests built from paths and methods, we use the methods as actions and translate request paths into resource names. These are the defaults (which obviously you can customize):</p><table><tbody><tr><td><p>Path regex</p></td><td><p>Resulting resource</p></td><td><p>Example path</p></td><td><p>Example resource</p></td></tr><tr><td><p>/([^/]+).*</p></td><td><p>[capture group 1]</p></td><td><p>/repository</p></td><td><p>repository</p></td></tr><tr><td><p>/v\d+/([^/]+).*</p></td><td><p>[capture group 1]</p></td><td><p>/v2/repository</p></td><td><p>repository</p></td></tr><tr><td><p>/</p></td><td><p>“index”</p></td><td><p>/</p></td><td><p>index</p></td></tr></tbody></table><p>For example, using the default translation table, consider the following request:</p><p>	POST /v2/repository</p><p>	Authorization: Bearer [bearer token for annie@example.com]</p><p>This will be translated into:</p><p>	Can<strong> annie@example.com</strong> do<strong> post</strong> on<strong> repository</strong>?</p><h2>How to Integrate Permit.io with your Kong-Based Application</h2><p>Since Permit.io uses OPA internally, you can use the standard Kong OPA plugin.</p><p>This guide assumes that you already have Kong configured, and your authentication is done through Kong.</p><p>First, you’ll need to set up your Policy Decision Point, or PDP, next to your Kong Gateway. In the Permit.io architecture, the PDP is a small container that makes authorization decisions. You configure it through Permit.io’s cloud service, but once running it’s completely independent (so it keeps running even if disconnected from the Internet) and can make decisions extremely quickly, on the order of 1-5 ms.</p><p>To run the PDP, you can use the following command:</p><pre><code>docker run \
⁠  -p 7766:7000 \
⁠  --env PDP_API_KEY=your_api_key \
⁠  --env PDP_KONG_INTEGRATION=true \
⁠  permitio/pdp-v2:latest</code></pre><p>To get your API key, go to the <a title="https://app.permit.io" href="https://app.permit.io"><u>Permit.io administration interface</u></a> and click “Copy SDK secret key” in the user menu:</p><img src="https://media.graphassets.com/PlWEjMURNOin6pU58PVQ" alt="image2.png" title="image2.png" width="239" height="260" /><p>Once running, you can configure your runtime instance to authorize requests through the PDP. In your Kong Route configuration, add a plugin:</p><img src="https://media.graphassets.com/Kb1raK31QUqqwFOwAmlw" alt="image3.png" title="image3.png" width="1862" height="595" /><p>In the plugin configuration, set the following values:</p><ul><li><div>“Config.include Consumer In Opa Input” should be checked</div></li><li><div>“Config.Opa Host” = The PDP’s IP address</div></li><li><div>“Config.Opa Path” = “/kong”</div></li><li><div>“Config.Opa Port” = 7766</div></li><li><div>“Config.Opa Protocol” = “http”</div></li></ul><img src="https://media.graphassets.com/sPA6A9DYTQSZwYvYwWZK" alt="image1.png" title="image1.png" width="894" height="743" /><p>Obviously if you changed any of these values in the PDP configuration, they’ll need to be changed to match in Kong’s configuration as well.</p><p>If you need to customize the resource translation table, you can use the following format (shown here is the default table):</p><pre><code>[
	[&quot;/v\\d+/([^/]+).*&quot;, 0],
	[&quot;/([^/]+).*&quot;, 0],
	[&quot;/&quot;, &quot;index&quot;]
]</code></pre><p>Entries are processed in order. In each entry, the first value is a regular expression to match, while the second is the resource name. For the resource name, a string is used as is, while an integer refers to a capture group in the regular expression.</p><p>To override the default table, simply mount the table’s json file at <code>/config/kong_routes.json</code>. The docker run command would be:</p><pre><code>docker run \
  -p 7766:7000 \
  --env PDP_API_KEY=your_api_key \
  --env PDP_KONG_INTEGRATION=true \
  -v /path/to/your/kong_routes.json:/config/kong_routes.json \
  permitio/pdp-v2:latest</code></pre><p>You should now see your http requests being authorized in the PDP’s log, and in the decision logs in <a title="https://app.permit.io/audit-log" href="https://app.permit.io/audit-log"><u>Permit.io’s cloud interface</u></a>. For any denied requests, Kong will return 403s.</p><h2>Summary</h2><p>As you see, Permit.io makes it easy to add permissions to Kong-based applications. You can easily configure Kong Gateway to use Permit’s powerful permission engine to decide whether requests are allowed, and empower non technical people in your organization to manage permissions themselves.</p>]]></content>
        <author>
            <name>Shaul Kremer</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Low-code ABAC: a prerequisite for the Future]]></title>
        <id>announcing-abac</id>
        <link href="https://www.permit.io/blog/announcing-abac"/>
        <updated>2022-09-29T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Announcing Low-code Attribute Based Access Control (ABAC)]]></summary>
        <content type="html"><![CDATA[<p>Today we are excited to share an important milestone in Permit’s product roadmap, and perhaps more than that - a key milestone in how we think about access control: <a title="www.permit.io/abac" href="www.permit.io/abac">Low-code Attribute Based Access Control (ABAC)</a>.</p><p>As applications are becoming more complex, their policies have to follow suit. <br>Policies for billing (e.g. &quot;only users who paid for a feature can use it&quot;), location, time, trust level, quotas, anomaly, fraud, and risk profiles are becoming basic requirements, with these examples just scratching the surface, as even greater complexity awaits just around the corner (think AI agents, Web3, DeFi, IoT, metaverse assets, …).</p><p>Before Permit.io and the concept of permissions-as-a-service, developers were forced to build and rebuild authorization over and over again to meet the constant stream of requirements coming from customers and fellow stakeholders (e.g. product, security, compliance, support). With Permit’s RBAC solution, policy-as-code became as easy as checking a checkbox - generating the needed code for you, wrapping it nicely into Git, and API / UI interfaces.</p><p>We had ABAC in mind from day one, and we supported it via direct code and Gitops. Still, to have complex policies (e.g. ABAC), users had to write code. We recognized that as long as policies remain accessible only through complex R&amp;D work and steep learning curves (e.g. writing Rego code), developers would remain bottlenecks. This results in locking the other stakeholders out of the conversation, and leaving customers thirsty for their modicum of freedom within products- a thirst constantly manifesting as an unending stream of feature requests.</p><p>We knew that when it comes to ABAC, low-code is a must. We can only meet these ever-increasing challenges if we make access controls inclusive and empowering for everyone.</p><p>The secret sauce behind this launch is the understanding that ABAC should be as simple as RBAC (Role Based Access Control) - ABAC should be as simple as assigning a role.  RBAC’s simplicity is why it became the bread and butter of the IAM world. <br>Working on this problem, we refused to relent until we found an elegant and simple solution. The eureka moment came in the form of breaking down ABAC into several independent yet connected systems, each one simple enough for a non-technical user. These systems enable the most complex patterns while converging back into a single source of truth as code managed in Git.</p><p></p><img src="https://media.graphassets.com/0cm1yjcQj243DggaQBpq" alt="1.png" title="1.png" width="905" height="729" /><p><em>A User Set living side by side with a regular role, both using resource sets (large files - i.e. files filtered with a size attribute)</em></p><p>With concepts like User-Sets and Resource-Sets (aka Condition-Sets), the Permit.io ABAC system allows users to transition from RBAC to ABAC smoothly and use complex attributes and conditions on them as if they are RBAC roles. </p><p></p><img src="https://media.graphassets.com/CdYtcQmVSjmByNdjY8Hc" alt="2.png" title="2.png" width="709" height="582" /><p><em>Defining a User Set with two attributes from different sources<br><br></em>With the new ABAC system, developers can customize every little aspect (with API or directly with code), but more importantly - they don’t have to - as the low-code interfaces are both simple and powerful enough to enable the entire team, including non-developers as well as the customers themselves, to work independently on access-control within the bounds set by developers/owners.</p><p>As we launch low-code ABAC support, we are excited about what this means for software and access control, but most importantly, we are excited to see what you build with it.</p><p>Ready to get started with ABAC?  <a title="http://docs.permit.io" href="http://docs.permit.io"><u>Read the docs here</u></a>, and simply <a title="http://app.permit.io" href="http://app.permit.io"><u>try it out directly</u></a></p><p>Got questions? Join our <a title="https://io.permit.io/permitslack" href="https://io.permit.io/permitslack">Slack community</a>, or <a title="Zoom" href="https://calendly.com/permitio">chat with us on Zoom</a>.</p>]]></content>
        <author>
            <name>Or Weis</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[The four mistakes you make building permissions]]></title>
        <id>four-mistakes-you-make-when-building-permissions</id>
        <link href="https://www.permit.io/blog/four-mistakes-you-make-when-building-permissions"/>
        <updated>2022-08-21T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Access control is a must in evey app, yet most developers build and rebuild it time and time again. Why? Usually, they make one of these four crucial mistakes -]]></summary>
        <content type="html"><![CDATA[<p><em>This blog is based on Or Weis&#39; talk </em><a title="https://www.youtube.com/watch?v=Cogf8gAWXK0&t=15s" href="https://www.youtube.com/watch?v=Cogf8gAWXK0&t=15s"><em><strong>&quot;Product Permissions - Common Pitfalls and How Not to Fall For Them&quot;</strong></em></a><em> at Open Security Summit</em>. </p><p>Access control is a must in almost any application, yet most developers end up building and rebuilding it time and time again - forced to refactor with new customer, product, or security demands coming in.<strong> <br><br></strong>Why? Usually, <strong>they make one or more of four crucial mistakes </strong>that prevent them from having a flexible access control layer that can be upgraded without having to rebuild it every time a new product demand comes in.<br><br>Before we dive into these, we first need to acknowledge that <strong>Permissions are hard</strong>, <strong>and they&#39;re becoming harder</strong> as the world moves into cloud-native ecosystems and microservices. Let’s try and understand why - </p><h2>What makes permissions complex?</h2><h3>Moving from monoliths to distributed microservices </h3><p>Back when applications were structured as monoliths, the decision-making process of who connects to what within an application could be baked into one place, usually by using a specific framework such as Spring, Django, or Python.<br><br>When working with <strong>distributed microservices,</strong> especially in a polyglot structure, these solutions are no longer applicable, so you end up having to sprinkle a bit of access control into every little microservice and component you&#39;re building. This creates an issue where <strong>we struggle to upgrade, add capabilities and monitor the code overall as it is replicated between different microservices</strong>.</p><h3>Connecting to 3rd party services </h3><p>It’s not just about the services you provide anymore: The ability to connect your application to 3rd party services (Like authentication, billing, analytics, machine learning agents, or databases) has become a crucial aspect of building any application - this requires us to manage access control for <strong>elements outside our own cloud</strong>. </p><h3>New, complex permission models</h3><p>The policies, rules, and models we want to enforce permissions with are also becoming more complex. Applications often start with an Admin / Non-Admin model and quickly move to increasingly complex models such as <a title="https://www.permit.io/blog/rbac-with-permit" href="https://www.permit.io/blog/rbac-with-permit"><strong>RBAC</strong></a>, <a title="https://www.permit.io/blog/what-is-rebac" href="https://www.permit.io/blog/what-is-rebac"><strong>ReBAC</strong></a>, and <a title="https://www.permit.io/blog/what-is-abac" href="https://www.permit.io/blog/what-is-abac"><strong>ABAC</strong></a>. Our expectations for applications and the different ways we can collaborate within them have never been higher, creating a need for ever-evolving complex policies.  </p><h3>Security and Compliance</h3><p>If back in the day, doing SOC 2, ISO, or meeting GDPR or CCPA standards was out of the ordinary, today, these standards are common for basically any B2B (and often B2C) application.  </p><p>These standards, along with HIPPA and PCI, all have lots of requirements related to <strong>having checks and balances for your application&#39;s access control.</strong></p><p>We can significantly reduce the amount of hardship we need to go through to meet compliance standards by implementing good access control. Having a feature like auditing, combined with visibility into your access control level, which you can share with your auditors, security, and compliance, is expected from almost any solution being built - maybe not on day one, but probably quickly down the road. </p><p>If that&#39;s not enough, there&#39;s a lot of security friction and vulnerabilities surfacing from challenges in building access control. It&#39;s no surprise that<strong> </strong><a title="https://www.permit.io/blog/owasp-2023" href="https://www.permit.io/blog/owasp-2023"><strong>broken access control is the top A1 item on OWASP’s list of vulnerability sources</strong></a>, with the highest occurrence across all the surveys. </p><p>Permissions are not only a problem in how we manage and build things, but it is also <strong>creating security issues in our production</strong>, which we may face as <strong>security incidents</strong>.</p><p>Now that we understand the depth of the problem, let&#39;s jump into the common anti-patterns that people often end up implementing into the access control that they&#39;re building, creating security vulnerabilities.</p><h2>The Antipatterns </h2><h2><strong>1. Mixing ‘Auths’ - Authentication VS Authorization</strong></h2><p></p><img src="https://media.graphassets.com/resize=width:3090,height:1481/9LDi6bQzSmKfCnj8J90W" alt="The IAM Waterfall" title="image 22.png" width="3090" height="1481" /><p><a title="https://www.permit.io/blog/authn-vs-authz" href="https://www.permit.io/blog/authn-vs-authz">Mixing up <strong>authentication </strong>and <strong>authorization</strong></a><strong> </strong>is probably the most common pitfall out there. Despite both belonging to the IAM space, the two are very different. In short - the IAM space consists of three parts:<strong> Identity Management</strong> (IM), <strong>Authentication </strong>(AuthN), and <strong>Authorization </strong>(AuthZ). </p><ul><li><div><p><strong>Identity management</strong> solutions like OKTA and Azure Active Directory are used on the <strong>organization side,</strong> defining different organizational identities and their relationships.</p></div></li></ul><ul><li><div><p><strong>Authentication</strong> is done on the product side, where you <strong>verify identities before allowing them into the product</strong> (Log in). </p></div></li></ul><ul><li><div><p><strong>Authorization </strong>is the layer that lets us<strong> enforce and check permissions</strong> <strong>within the product</strong>. </p></div></li></ul><p>These three steps trickle down into one another, but we must understand their differences.</p><h4><strong>Role translation</strong></h4><p>One source of confusion between identity management, authentication, and authorization stems from their use of <strong>Roles</strong>. The concept of Roles exists through the IAM space, <strong>but the meaning varies in each part</strong>. </p><p>Identity Management Roles indicate a role within an organization (Like “Head of Marketing” or “Member of Security Team”). These roles are drastically different from those used on the application level (Like “Admin,” “Reader,” or “Viewer”). Translating IM organizational roles into application-level Authorization roles is not always a straightforward process, but it is an issue that clearly needs to be addressed.</p><p></p><img src="https://media.graphassets.com/resize=width:654,height:638/J4cYMPpNR4mGz9hYuoqM" alt="Role Translation" title="Group 1.png" width="654" height="638" /><p>The result of this translation (For example - Deciding that our Head of marketing, who is part of the marketing team, should have an editor role for the CMS) <strong>should be saved as part of the JSON web token (JWT) produced by the authentication layer</strong>. <br><br>What else should JWTs be used for? Glad you asked.  </p><p></p><h4><strong>Using JWTs</strong></h4><p>Basically, <strong>the translation of the IM role into an authorization layer role  </strong>(Or - the translation from an organizational role into an application level role) <strong>should be the only thing included in the JWTs. </strong><br><br>Developers often tend to <a title="https://www.permit.io/blog/load-external-data-into-opa" href="https://www.permit.io/blog/load-external-data-into-opa">overuse JWTs</a>, sometimes going as far as storing all the routes that a user should access within them. That is a bad idea for several reasons:</p><ul><li><div><p>Mixing the authentication and authorization layers messes up our code. </p></div></li><li><div><p>Changing roles requires the user to log out and log in again, which can hinder the user experience and overall application performance. </p></div></li><li><div><p>As the JWT is sent for every request with a RESTful API, GraphQL, or any other HTTP-based solution, creating a bloated JWT would significantly slow down the application’s performance. </p></div></li><li><div><p>There is a limit to how much data can be stored within a JWT. If we keep adding more rules, we will eventually run out of storage space. </p></div></li></ul><img src="https://media.graphassets.com/resize=width:517,height:499/oww7p931TvK6R7x05WJV" alt="Using JWTs" title="download.jpg" width="517" height="499" /><p>The best way to avoid this is to have the JWT<strong> only include the claims and scopes for the user&#39;s identity and their relationship within the organization</strong> and keep all other authorization-related information in a separate layer within the application. </p><p>Speaking of creating a separate layer for authorization, the next common mistake devs make is mixing up <strong>application logic</strong> with <strong>authorization logic</strong>. </p><p></p><h2><strong>2. Mixing up App-logic and Authorization</strong></h2><img src="https://media.graphassets.com/resize=width:885,height:426/4CNGyADRqCklXuXIuN1w" alt="Spaghetti " title="badcode.png" width="885" height="426" /><p>When building an application, we have the logic of <strong>what the application is supposed to do</strong>, and we have the logic for <strong>who is allowed to perform which actions within it</strong>. </p><p>The combination of these two logic sets could easily result in us having spaghetti code composed of a mix of unrelated elements. If we will need to upgrade the application or the authorization layer (Which is rather likely to happen at some point), we&#39;ll end up having to cherry-pick different elements of code, trying to figure out which are application related and which are authorization related. </p><p>When these two logic sets are combined, they inevitably grow organically and become increasingly cumbersome, <strong>turning any future effort of separating, editing, updating, or upgrading them into a nightmare</strong>. </p><p>There’s also an issue of performance here - Let’s say our application checks a user&#39;s payment status to approve or deny access to certain features. Checking this every time as part of the application flow could significantly hinder the application’s performance. </p><p>A much better way to approach this issue is to <a title="https://www.permit.io/blog/5-best-practices-for-building-cloud-native-permissions#the-5-best-practices" href="https://www.permit.io/blog/5-best-practices-for-building-cloud-native-permissions#the-5-best-practices"><u><strong>decouple our policy from our code</strong></u></a>. This way, the authorization layer can run in the background and monitor the user’s payment status. Whenever we want to check that status, it will already be available in the authorization layer, eliminating the need to fetch it every time.<br></p><h2><strong>3. Mixing up your Access control layers</strong></h2><p>Every application requires multiple layers of access control - </p><ul><li><div><p><strong>Physical access control</strong>, like having locks on our doors and windows.</p></div></li><li><div><p><strong>Network level access control</strong>, like firewalls, VPNs, and zero trust networks.</p></div></li><li><div><p><strong>Infrastructure level access control</strong>, like limitations on which services can talk to each other.</p></div></li><li><div><p>And lastly, <strong>application level access control</strong>. </p></div></li></ul><p>Each of these layers has <strong>different demands, requirements, policies, and models</strong>. Ideally, we would have a unified interface/back-office where we can view, manage and audit all these different layers. The ability to manage them as code would be even better, as it allows us to manage and run tests on them as part of our source control. </p><p>The main mistake we often see developers making in this aspect is <strong>combining their application-level access control </strong>with a tool that was <strong>built to manage infrastructure access control, like AWS IAM</strong>. </p><p>Initially, this might look like a great idea - AWS IAM is a very powerful tool that can map many things into objects, which is why engineers use it to map their application-level access control. So why is this not a good idea? Let&#39;s look at a specific example. </p><p>We often encounter engineers mapping their application-level access control using SS3 buckets in AWS. Because their data is stored in a bucket anyway, they feel they might as well use the access control for the bucket for the application itself. Although this may sound great on the surface, it&#39;s easy to see when things start to go wrong - </p><p>The moment you’ll want to move to a different cloud or even a different storage layer within the same cloud, there’s a good chance you won&#39;t want to use the buckets anymore - you’ll want to use RDS, Redshift, or Snowflake. Just because the requirements for your application have changed, <strong>you will have to completely refactor your access control because it was coupled into that specific cloud component infrastructure</strong>.</p><p>It can also be a major problem to rely too much on how things are built for these specific components. A lot of people rely on the way you configure the API gateway to do enforcements for your application. Sadly, AWS encourages you to put routes inside the JWT - a practice devs end up adopting as something they can take into production in scale and end up regretting in the long run. <br><br>Ultimately, it&#39;s important to remember that different access layers have different needs. If we ignore these needs, we might regret it later and end up having to refactor large parts of our applications. <br></p><h2><strong>4. Thinking that you can solve it once and for all</strong></h2><p>The last major mistake developers tend to make when thinking about permission building is more of a conceptual one - Thinking they can solve it once and for all. </p><p>Many young companies fall for this misconception and end up rebuilding their access control over and over again instead of developing crucial new features in the application itself. The worst thing about that is that <strong>every time</strong> <strong>they do it, they think this time will be the last</strong>. In reality - if you follow even just some of the anti-patterns we described here, there&#39;s a good chance that every time a new requirement comes in from a customer, partner, security, or compliance, <strong>you just might have to throw out everything you&#39;ve built and start from scratch</strong>. </p><p>The only way to avoid this scenario <strong>is to plan for it</strong>. Building an ever-growing, ever-developing application, you have to assume that you will have to evolve your authorization layer to support more policies and complex roles. You have to assume you will move from RBAC to ABAC or other even more complicated models and provide interfaces on top of them. <br><br>This doesn’t mean you should try and build a perfect, future-proof permission management system from day one - especially if you are working in a startup company. You’ll just never finish. Instead, focus on setting the right groundwork - <strong>if you plan ahead</strong> and <strong>avoid the mistakes we discussed in this post</strong>, you will be able to upgrade your permission layer with much more flexibility - instead of having to rebuild it from scratch every three to six months. </p><p>Most companies go through the same steps - they initially build good schemas for their data layers and authorizations, but gradually, as they move forward, these schemas stop working, and they start facing performance issues. The only way to avoid this is to <strong>decouple your authorization layer from your application’s logic</strong> and <strong>be ready to update it gradually as demands come in</strong>.<br></p><h2><strong>Let&#39;s sum everything up - </strong></h2><p>Whether it&#39;s the <strong>move to distributed microservices from monoliths</strong>, the requirement to <strong>integrate 3rd party services into your application</strong>, the necessity of <strong>using complex permission models</strong>, or the rise of <strong>security and compliance requirements</strong>, permissions have become more complex than ever.</p><p>All of these changes require us to<strong> </strong><a title="https://www.permit.io/blog/5-best-practices-for-building-cloud-native-permissions" href="https://www.permit.io/blog/5-best-practices-for-building-cloud-native-permissions"><u><strong>adopt new best practices</strong></u></a> and <strong>avoid common mistakes </strong>developers make when thinking about authorization: <br><br><strong>Mixing Authentication and Authorization</strong>, especially when it comes to the somewhat confusing translation of organizational roles into application level ones and the correct usage of JWTs, <strong>mixing up application logic with authorization logic</strong>, using tools designed for <strong>infrastructure access control</strong> (like AWS IAM) <strong>to manage application level access control</strong>, and thinking that we can solve our authorization problems once and for all on day one. </p><p>Most importantly, it&#39;s important to understand that developing a good authorization layer in a constantly changing application requires planning ahead and building a flexible solution that can be upgraded without having to rebuild it every time a new product demand comes in.</p><p>Building authorization? Got questions? Come talk to hundreds of developers working on solving their IAM challenges in our <a title="https://io.permit.io/permitslack" href="https://io.permit.io/permitslack"><u>Slack community</u></a>!</p>]]></content>
        <author>
            <name>Daniel Bass</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Intellyx BrainBlog: The Perks and Pitfalls of Homebrewing Permissions with Open Source]]></title>
        <id>homebrewing-permissions-with-os</id>
        <link href="https://www.permit.io/blog/homebrewing-permissions-with-os"/>
        <updated>2022-08-10T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[An Intellyx BrainBlog for Permit.io by Jason English]]></summary>
        <content type="html"><![CDATA[<p>As a young homebrewer, I enjoyed making strange beers that I just couldn’t find in the store. I’d pride myself on finding exotic ingredients and employing unconventional brewing methods. All part of the story as I poured it for my friends.</p><p>Homebrewing beer can be unpredictable, but the cost of failure is rather low.</p><p><em>“Don’t worry, if I messed up this recipe, the worst it can do is leave a bad aftertaste...”</em></p><p>While the stakes for homebrewing permission frameworks may seem high, it’s not an uncommon practice. Conventional identity-oriented access controls provided by IT often don&#39;t support the notion of microservices talking to each other in cloud infrastructure properly. For this reason, many cloud native development projects whip up their own authorization methods to get application work done.</p><p>What are some tips for maximizing the chance of success for do-it-yourself permission efforts while minimizing project overruns and security risks?</p><p></p><h2>Brew your own permissions, with a little help</h2><p>Much of the science of brewing has become common knowledge. With readily available advice and the right ingredients, world-class results are now just a recipe away.</p><p>Cloud native applications are complex, fast-changing, and based largely on open source underpinnings. The biggest IAM and security vendors often have proprietary elements in the mix as a means of market share protection, which encourages developers to take a do-it-yourself approach to permissions.</p><p>Encouragingly, when building cloud native permissions, there are already many proven recipes for success, so developers don’t have to build it all by themselves. </p><p>Cloud native software development leans on open source as a core tenet – and therefore, we can tap into the expertise of a dynamic, fast-growing community of contributors who are driving open source solutions for implementing an authorization layer with advanced permissions that can deal with ephemeral clusters, APIs and remote teams. </p><p>Here are a few important things to look out for in forming your own bill of materials for permissions, a brew-bucket list as it were.</p><h2>Pour in open source policy</h2><p>Identity tools can determine which users can access a system, and <em><strong>authentication</strong></em> is useful for securing the perimeter of an application. Still, cloud native applications have a deep need for stronger <em><strong>authorization </strong></em>to control which actions users/services can take on what resources to get work done.</p><p>It is straightforward to homebrew a single permitted behavior – say, a qualified auditor asking an HR service for an employee’s salary. That’s fine for a prototype, but once there are thousands of permutations of interactions between users and microservices, there will never be enough time to write or update so many individual permissions.</p><p>We need permission rules that are more flexible to avoid manual rewrites. Right on time, the open-source <a title="https://github.com/open-policy-agent/opa" href="https://github.com/open-policy-agent/opa"><u>OPA (Open Policy Agent)</u></a> provides an excellent CNCF-graduated starting point for this, allowing developers to use the declarative <a title="https://www.openpolicyagent.org/docs/latest/policy-language/" href="https://www.openpolicyagent.org/docs/latest/policy-language/"><u>Rego policy language</u></a> to write authorization rules that services of almost any type can make requests against.</p><p></p><h2>Separate rules from implementation</h2><p>In conventional apps, authorization schemes are often associated with the target environments they are running in. For instance, a user’s authorization status could be maintained as a token for the duration of a particular session running in a Chrome browser and accessing an open connection to a particular Linux container or a database. </p><p>In cloud native applications, the statefulness of that user’s session goes out the window, as API calls and data get passed among ephemeral, possibly widely distributed microservices that each perform their own functions as workloads. Since it’s no longer relevant where the physical implementation lives, authorization has to be maintained separately.</p><p>Rather than coding a new rule for every unique implementation, OPA allows ‘policy as code’ that is inherently decoupled, allowing permissions to be written and changed independently from deployment. To the rest of the architecture, the OPA agent is just another microservice that is called on to make decisions on permissions.</p><h2>Layering on an event-driven scale</h2><p>Event-driven architectures (or EDAs) include API layers that can ingest and process streaming data services at scale. Event-driven integration is becoming popular for mission-critical applications where time is of the essence. EDA actions include not just responses to requests (ala REST-style integration) but reactions to asynchronous events.</p><p><a title="https://opal.ac/" href="https://opal.ac/"><u>OPAL</u></a> (or Open Policy Administration Layer) is an open-source project that makes OPA agents event-driven. OPAL listens for any changes to code within the org’s application repository, as well as changes to any connected APIs, third-party services, cloud storage volumes and, databases. If an asynchronous change event occurs, OPAL can drive updated permission policies to sync up any OPA agents in real time.</p><p>Permission policies and the underlying access data for groups of users and systems are portable across applications and tenants – even as underlying microservices, clusters, and APIs are constantly decommissioned and renewed. In a meta-sense, automatically propagating authorization to each ephemeral service extends the dream of dynamic cloud native architecture at the permissions layer.</p><p>Development teams eliminate toil by storing OPAL policies in cloud repositories and merging them with GitOps delivery processes. OPAL can automatically update OPA permissions with each pull request without needing to migrate and potentially expose sensitive user and company data.</p><h2>The Intellyx Take</h2><p>Much like grinding grains for beer or coffee, it’s important to get the granularity right when brewing up a cloud native permissions strategy that depends upon open source software. </p><p>You don’t want to start down a path of setting policies that are too fine-grained, which will require manual intervention for each action and throttle developer productivity. At the same time, you want a centralized plan for open source permissions management that is decoupled from infrastructure and coarse-grained enough to adapt to changes and events.</p><p>In our next chapter of this series, we’ll discuss how some leading companies augment their initial homebrewed cloud native authorization efforts with a SaaS-based policy control platform like Permit.io that has expert practices for managing OPA and OPAL built in.</p><p><em>Copyright ©2022, Intellyx LLC. At the time of writing Permit.io is an Intellyx customer. Intellyx retains final editorial control of this article.</em></p><p></p>]]></content>
        <author>
            <name>Jason English</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[How to Implement Multitenancy in Cloud Computing ]]></title>
        <id>multitenancy-in-cloud</id>
        <link href="https://www.permit.io/blog/multitenancy-in-cloud"/>
        <updated>2022-08-01T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Cloud-based SaaS solutions need multi-tenancy. What is Multitenancy? What we can gain from it? How to easily implement it with two simple layers?]]></summary>
        <content type="html"><![CDATA[<p>Cloud-based SaaS solutions, as well as most other solutions, need multi-tenancy. Let’s quickly review what Multitenancy is, what we can gain from it, and how to easily implement it with two simple layers.<br></p><h2>What is Multitenancy</h2><p>At its core, <strong>multi-tenancy allows every part of the service</strong> (i.e., every microservice) to<strong> cater to multiple customers without deploying separate instances for each</strong>.</p><p>For a SaaS solution to scale affordably, meet customer demands, and be elastic in doing so (i.e., cost-effective in cloud resources), it has to support multi-tenancy.<br><br>A multitenant architecture provides many great and often essential features:</p><ul><li><div><p>Allowing the application to <strong>serve multiple customers at once</strong> while sharing the underlying infrastructure and services</p></div></li><li><div><p>Secure and compliant access separation</p></div></li><li><div><p>Load balancing and scaling</p></div></li></ul><h2>The two layers of Multitenancy</h2><p>At the end of the day, multi-tenancy is easy once you understand it, and it basically requires only two things: <strong>Application level access control</strong> and <strong>managing data schemas</strong>.</p><p>Let&#39;s break it down into two planes:</p><ul><li><div><p><u>The </u><u><strong>data plane</strong></u> is all about how you <strong>transmit</strong>, <strong>store</strong> and <strong>manage</strong> the siloed data (i.e., How the underlying infra avoids mixing up the data of different tenants). Multi-tenancy for the data plane is often implemented as partitions on the data layers - e.g., separate partitions, tables, columns, identifiers, and/or labels on the data storage schema (how you save it in the database) and topics (e.g., Kafka topics), tags, domains, sockets, and/or ports, for the data at transit.</p><img src="https://media.graphassets.com/resize=width:804,height:288/6VryjASXSUedt02yONhO" alt="DB tables" title="1.png" width="804" height="288" /></div></li></ul><p><em>Example of DB tables with simple column-based tenant separation</em><br></p><ul><li><div><p><u>The</u><u><strong> application plane</strong></u><strong> </strong>is about how you silo context and access within the logical layer, i.e., have the same code work for different tenants. Authorization is the component within the application plane implementing multi-tenancy.</p></div></li></ul><img src="https://media.graphassets.com/resize=width:568,height:254/yk22RUsMR3qyKRypLQv6" alt="Application route enforcing multitenancy" title="2.png" width="568" height="254" /><p><em>Example application route enforcing multitenancy with Permit.io’s SDK (</em><a title="https://github.com/permitio/permit-demo-todos-nodejs/blob/8fc58cf62e8c9afe43891ea65f666e71c0875ff7/src/api-with-permit/src/routes/api/boards.ts#L96" href="https://github.com/permitio/permit-demo-todos-nodejs/blob/8fc58cf62e8c9afe43891ea65f666e71c0875ff7/src/api-with-permit/src/routes/api/boards.ts#L96"><u><em>check it out on Github</em></u></a><em>)</em></p><h2>Implementing multi-tenancy</h2><p><strong>An authorization layer </strong>is the fastest and most reliable way to upgrade from a single-tenant application to a multi-tenant one safely. In addition, the authorization layer can implement separation without requiring changes to the services themselves by applying a policy across all relevant services.<br><br>Choosing the right policy model can simplify this transition even further, with classic models like <strong>RBAC + Tenancy</strong>, <strong>ReBAC + Hierarchy</strong> (tenants becoming root-level relationships), or plain vanilla <strong>ABAC</strong> (with tenancy as an attribute).</p><p>The great thing is we don’t need to implement multi-tenancy authorization on our own, and instead can enjoy ready-made open-source tools and services.</p><h2>Implementing multi-tenancy with OPA + OPAL (Open-Source)</h2><p>Open source is a great option to start implementing your authorization layer for multi-tenancy. While there are multiple options, Open Policy Agent (OPA) is among the most promising.<br>OPA acts as an authorization microservice that we can add to our application and use to enforce access with rules written in its proprietary <a title="https://www.permit.io/blog/introduction-to-opa" href="https://www.permit.io/blog/introduction-to-opa"><u>Rego language</u></a>.<br><br>Combining OPA with <a title="https://www.permit.io/blog/introduction-to-opal" href="https://www.permit.io/blog/introduction-to-opal">OPAL (Open Policy Administration Layer)</a> enables us to manage our authorization layer in scale, using Pub/Sub topics to keep our agents up to date with policy (Rego code) and data (JSON documents). The topics, for example, can be our tenant names or IDs, allowing us to sync our agents with changes per tenant. </p><h2>Implementing multi-tenancy with Permit.io (Service)</h2><p>App <a title="https://www.permit.io/blog/authorization-as-a-service" href="https://www.permit.io/blog/authorization-as-a-service">authorization solutions</a> solve the application aspect out of the box and layer easily on-top of the data plane by providing (or correlating according to) unique identifiers that can be used to partition the data plane.<br><br>Permit builds on top of OPA and OPAL, adding management interfaces, including a tenants list,  tenant resource management, and per-tenant user management.</p><img src="https://media.graphassets.com/resize=width:1600,height:628/4eVtPPfmTRyiYHnJ7pjA" alt="Permit.io multitenancy dashboard" title="3.png" width="1600" height="628" /><p><em>Switching between tenants in Permit.io’s dashboard</em></p><h2>To sum things up - </h2><p>Multi-tenancy allows our application to <strong>cater to multiple customers without deploying separate instances for each</strong>. Multi-tenancy enforcement in gist consists of two planes: data and application. One of the best ways to achieve Multi-tenancy is by creating an <strong>authorization layer</strong> that can implement separation without requiring changes to the services themselves. Although you can build your own authorization layer, there are also <strong>open-source</strong> options (Such as OPA + OPAL) and <strong>Services</strong> (Such as Permit.io) that allow you to implement one in your application - making the critical shift into multi-tenancy more accessible.<br><br>Considering multitenancy for your app? Got questions? <a title="https://io.permit.io/permitslack" href="https://io.permit.io/permitslack">Join our Slack community</a> and chat with fellow developers building authorization!</p>]]></content>
        <author>
            <name>Or Weis</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[5 Ways to Improve your AWS IAM Roles and Policies]]></title>
        <id>aws-iam-roles-and-policies</id>
        <link href="https://www.permit.io/blog/aws-iam-roles-and-policies"/>
        <updated>2022-07-24T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Understanding the balance between a good experience for the development team and minimizing security risks - and the best practices for achieving it.]]></summary>
        <content type="html"><![CDATA[<p>IAM Abuse is a real deal, and cases like <a title="https://fortune.com/2018/02/20/tesla-hack-amazon-cloud-cryptocurrency-mining/" href="https://fortune.com/2018/02/20/tesla-hack-amazon-cloud-cryptocurrency-mining/"><u><strong>“Tesla Hackers Hijacked Amazon Cloud Account to Mine Cryptocurrency”</strong></u></a> can be life-threatening for every company using a cloud provider. Taking care of this aspect of cloud account management can be the difference between successfully managing your cloud resources and losing them all.</p><p>As a DevOps Engineer, I personally began learning about AWS Identity and Access Management (IAM) solutions as my first step within the AWS space in general. I’ve been hearing about<strong> the pain of configuring IAM </strong>the right<strong> </strong>way for years now. </p><p><strong>What&#39;s causing this pain? </strong></p><p>That&#39;s a bit tricky. There are two sides to the IAM “coin”:</p><p>On the one hand, <strong>looser IAM policies make it easier for developers to do their jobs</strong>, but <strong>they also</strong> <strong>pose a serious security risk</strong>. On the other hand, while solving the security risks, overly strict IAM rules will make things difficult for developers on a daily basis.</p><p><strong>A careful balance needs to be struck between enabling a good experience for the development team and minimizing security risks. </strong>This fine balance is unique for every company, and finding it and adjusting it over time is the key. </p><p>In this post, I aim to help you better understand this balance and set down <strong>a few best practices for achieving it</strong>. To do so, I’ll include some core scenarios of <strong>using Roles</strong>, <strong>monitoring role usage</strong>, how to use<strong> OIDC (OpenID Connect)</strong> with your Kubernetes or Github, as well as a few other tips. <br><br>Before we dive in, let’s go over some of the basics of managing IAM on AWS.</p><p></p><h2><strong>AWS IAM: A basic introduction</strong></h2><p>With AWS’s Identity and Access Management, we, the developers (and users), can decide what resources a user, a group, or a role can view or change. In other words: <strong>Who</strong> can perform what <strong>Action</strong> on Which <strong>Resource</strong>? We&#39;ll start with talking about the smallest building block of the IAM - AWS Policies:</p><h4><strong>Policy Structure</strong></h4><p>Policy JSON documents are comprised of the following elements:</p><p><strong>Effect</strong> - Allow or Deny access to the resource is decided by Effect (Allow/Deny)</p><p><strong>Action</strong> - A set of service-specific parameters (like “iam: CreateUser”).</p><p><strong>Resource</strong><em> </em>- Resource names (like “arn:aws:s3:::conf-* “)</p><p><strong>Condition</strong> (Optional) - Grant conditions (like “aws: RequestedRegion”: “ap-south-1”)</p><p>Here’s an example of a JSON policy document: </p><pre><code>{
   Version: &quot;2012-10-17&quot;,
   Statement: [
       {
           Effect: &quot;Allow&quot;,
           Action: [
               &quot;route53:ChangeResourceRecordSets&quot;
           ],
           Resource: [
               &quot;arn:aws:route53:::hostedzone/*&quot;
           ]
       },
       {
           Effect: &quot;Allow&quot;,
           Action: [
               &quot;route53:ListHostedZones&quot;,
               &quot;route53:ListResourceRecordSets&quot;
           ],
           Resource: [
               &quot;arn:aws:route53:::hostedzone/*&quot;
           ]
       }
   ]
}</code></pre><p><em>Note: This policy allows changing record sets for all Route53 zones; however, “create” permissions do not entitle the user to “read” or “list,” so I added the ability to list all hosted zones and record sets to the policy.</em></p><h4><strong>Policy Attachment</strong></h4><p>Each policy can be attached to a user, a group, or a role.</p><p>Policies attached to users and groups are quite basic and easy to understand - each AWS user or a group can have many policies (It&#39;s also helpful to note that policies are reusable!), while Groups are simply a bunch of users that will share the same policies. <br><br>The same goes for roles:  A role can have many policies attached to it. What makes roles a bit trickier is that unlike users and groups, which can be accessed via basic authentication or tokens, roles only work with a role assumption mechanism.</p><p></p><h2><strong>AWS IAM: 5 Best Practices</strong></h2><p>As mentioned before, achieving a balance between flexibility and security when managing your IAM solution is crucial in keeping our application secure while enabling infrastructure for our engineers. This can, however, be quite challenging.</p><p>Let’s dig in with some best practices for leveraging the power of IAM and Roles in particular.</p><p></p><h3><strong>1. Assuming Roles - Avoiding Premature Privilege Escalations</strong></h3><p><strong>Roles</strong> are a critical part of AWS IAM because they allow us to <strong>manage permissions between services and resources</strong> and <strong>automate actions </strong>in AWS.</p><p>Roles basically function as a policy administration layer, as many policies can be attached to each role, and roles are assumed by various entities. This extra layer allows us to control and manage our IAM much more efficiently using the tools which AWS IAM provides us: <br><br><strong>&quot;Trust Relationship” </strong>policies allow us to secure who can use the role, <strong>CloudTrail</strong> allows us to monitor who’s assuming which role, and <strong>OIDC</strong> lets us allow 3rd party services delegate AWS permissions. In the next following segments, we will dive into how to use these tools to enhance our organization’s IAM rules and make sure they are secure and flexible. </p><p>In the absence of roles as an extra administrative layer for managing policies, premature privilege and permission escalations are likely to occur. These can manifest as unmanaged policies and users, unmanaged 3rd party services policies, and many more potentially harmful administrative gaps, resulting in serious security breaches for your organization.  </p><p>When talking about assuming roles, we will be using the <strong>AWS Security Token Service</strong> (STS), which is a web service that enables you to request temporary limited-privilege credentials for AWS IAM.<br><br>By using the AWS STS, we can invoke the <em>AssumeRole</em> action that returns a set of temporary security credentials that may be used to access AWS resources you would not normally have access to. To simplify that, we can say that this action places you ‘in the guise’ of the role you choose to assume. So if I choose to &quot;assume&quot; my new &quot;ExampleRole,&quot; the policies contained in &quot;ExampleRole&quot; will simply be delegated to me.</p><p>In order to use the role you created, you must use the STS API to &quot;assume&quot; it.</p><p>Fortunately, most of the 3rd party services like Github, K8s, Terraform, and many more offer an easy way to assume roles, thus making the usage of roles much more flexible and convenient, which is essential when talking about developer experience.</p><p></p><h3>2. <strong>Using Roles in Real-Life Scenarios </strong></h3><p><strong>When </strong>roles should be used is a tricky question. We can better demonstrate the usage of roles by explaining and understanding <strong>Why</strong> roles should be used in the first place. There are several explanations to why we should use roles - we’ll divide them into 4 parts that will also include examples of using roles in the real world.</p><h4><u><strong>Easier Policy Management, Auditing, and Tracking</strong></u></h4><p>⁠Let’s say, for example, that we need to share the ability to <strong>delete EC2 instances</strong>. We can easily create a proper policy and attach it to a user, or even better, to a group. In this made-up scenario, we&#39;ll suppose the demand for deleting EC2 instances is very common. <br><br>The thing is, deleting EC2 instances is a very sensitive permission to have. We can’t just give it to any user. So how can we solve this problem?<br><br>We can create a role called &quot;EC2DeleteRole&quot; (attached with the policy of deleting EC2 instances), and make sure that having this role is the only way you can get this permission.</p><p>We, the IAM administrators, will be able to track and manage our identities&#39; permissions much more effectively by assigning this permission to a specific role. Imagine a situation where we want to remove the EC2 instance ‘delete policy’ from every identity on our AWS account. Rather than going through every identity and deleting this policy, we can simply do it by deleting the “EC2DeleteRole” we created earlier.</p><p>Roles are basically a toolbox for managing policies in a very flexible way, so don’t be afraid to use them!</p><p></p><h4><u><strong>De-Risking Automations and 3rd party services</strong></u></h4><p>Occasionally, we will need to delegate permissions to third-party services or automation to operate on AWS. There are high risks associated with this (Such as<a title="https://www.paloaltonetworks.com/blog/2021/09/cloud-supply-chain-attacks/" href="https://www.paloaltonetworks.com/blog/2021/09/cloud-supply-chain-attacks/"><u> supply-chain attacks</u></a>), which is why we must ensure that all the components of our infrastructure are highly secure so that an attacker cannot gain access to our infrastructure through a weak or unsecured component.</p><p>When it comes to delegating permissions for automation or third-party services, the only available options are providing <strong>authentication tokens</strong> and <strong>passwords </strong>per dedicated user or using <strong>Roles</strong>.<br><br>The option of sharing authentication tokens and passwords is the easiest to implement; just throw in your password as a variable, and that’s it. Sadly this can expose the organization to a lot of maintenance issues and security risks, as <strong>passwords can be accidentally shared or accessed by an unwanted threat</strong>. <br><br>This is where the thin line between flexible and secured IAM is crossed, and we must be sure that both are well implemented without compromise. <br><br>To achieve this, the best option is <strong>to use roles!</strong><br><br>We can easily provide our 3rd party automation or service a role ARN to assume in order to get the permissions it needs. The same goes for managing permissions for infrastructure-as-code tools such as <strong>Terraform</strong>, <strong>Pulumi</strong>, and <strong>Terragrunt</strong> and even more robust systems such as <strong>Kubernetes</strong> or <strong>Hashicorp Nomad</strong>.<br><br>This can be achieved using the <strong>OpenID provider</strong>, which we will discuss further.</p><p></p><h4><u><strong>Delegating permissions between accounts - </strong></u></h4><p>Say our organization has several AWS accounts - one account for each SDLC environment (Development, staging, and production, for example), and for some reason, we are asked to give a service that is located in the staging account, the ability to reach an S3 bucket on our development AWS account.<br><br>Roles enable us to accomplish that, as <strong>roles can be assumed between accounts</strong>.<br><br>When creating a new role, we can choose that the “trusted entity” of this role will be a different AWS account; this way, the role will be assumable by a different account.</p><img src="https://media.graphassets.com/resize=width:752,height:314/Jb5O62JSDOuLuByx7a2A" alt="Trusted Entity" title="unnamed.png" width="752" height="314" /><p>There is only one other option, which is to create a dedicated user and pass the password as a raw variable, which is highly insecure.</p><p></p><h4><u><strong>Service Roles - </strong></u></h4><p>Many AWS services require you to use roles in order to control access. A role that a service assumes to perform actions is called a <strong>Service Role</strong>. When a role serves a specialized purpose for a service, it can be categorized as a service role for EC2 instances or a service-linked role.</p><p>It’s useful to clearly distinguish between internal and external services, as each one of them will require a different set of roles. For example, AWS core services such as Amazon Data Lifecycle Manager will require a specific set of policies in order to operate properly, so we would keep this “Service Role” static as we don’t want to break the service’s operations.<br><br>On the contrary, managing roles for external services such as Kubernetes will require much more maintenance and monitoring from our side, as these kinds of roles are much more dynamic in their needs, which may lead to security issues and potential human error.</p><p>Consider <strong>marking the external services differently than the internal ones</strong> in your cloud architectural design, then design each of them separately. This will help you better understand which roles require more attention, as external service roles may be unsafe for our organization in some cases.</p><p></p><h3>3. <strong>Monitoring role usage using AWS CloudTrail</strong></h3><p>When a large number of roles accumulates, it can be difficult to manage them effectively. In this case, <strong>AWS CloudTrail </strong>can come in handy.<br><br>Imagine a situation where a user gets access to a role that you don’t even remember exists or a scenario when multiple roles have the same policies. IAM and effective permissions on AWS should not be managed that way. </p><p>In order to avoid such scenarios (and worse ones), we can use <strong>AWS CloudTrail</strong>.</p><p>With this great AWS service, we can monitor and capture the activity of our organization’s users and the API usage across AWS regions and accounts on a single centralized interface.<br><br>AWS CloudTrail gives a lot of information about everything related to auditing the cloud activity and monitoring this data, and with that, we can watch for any unwanted activity of role assumptions and much more.</p><p>CloudTrail could be useful when monitoring who is reading secrets from our AWS Secret Manager. There’s no doubt that reading secrets should be a well-monitored action on our account since we want to ensure that only very specific users and groups can read secrets.<br></p><img src="https://media.graphassets.com/resize=width:1200,height:468/0tJp5SVsQcqdbEfdzodh" alt="AWS Secrets" title="unnamed (1).png" width="1200" height="468" /><p><em>We can monitor who’s reading which secret, which role the identity is assuming, its IP, the event time, and much more.</em></p><p><em></em></p><h3>4. <strong>Restrict role assumption with Trust Relationship policies</strong></h3><p><strong>Should all roles be available to everyone?</strong> Clearly not. Roles are important entities that should always be kept safe from potential threats. Every role has a special policy called a “trust relationship policy”. This policy looks very similar to any other, and we can specify who can assume the role using it.</p><pre><code>{
  &quot;Version&quot;: &quot;2012-10-17&quot;,
  &quot;Statement&quot;: [
    {
      &quot;Effect&quot;: &quot;Allow&quot;,
      &quot;Principal&quot;: {
        &quot;AWS&quot;: &quot;arn:aws:iam::111122223333:root&quot;
      },
      &quot;Action&quot;: &quot;sts:AssumeRole&quot;,
      &quot;Condition&quot;: {}
    }
  ]
}</code></pre><p>In the above example, we attached a trust-relationship policy to our role that specifies that only the root user of the &quot;111122223333&quot; AWS account can assume this role, as indicated in the Action statement: &quot;sts:AssumeRole&quot;.</p><p>Trust Relationship policies are like whitelists or blacklists for roles. Imagine a situation where we create a role that has the permission to delete EC2, and <strong>everyone</strong> in the organization can assume this role. Obviously, this is not a good idea, so we must specify which entities are allowed to use this role and which ones aren’t.</p><p></p><h3>5. <strong>Streamlining permissions with 3rd party entities: OpenID Connect</strong></h3><p><u><strong>What is OpenID Connect (OIDC)? <br></strong></u><br>OIDC is an open authentication protocol that profiles and <strong>extends OAuth 2.0 to add an identity layer</strong>. It allows clients to confirm an end user’s identity using authentication by an identity management server. </p><p>The OIDC standard is used by many well-known services to delegate access and authentication securely. Luckily for us, <strong>AWS IAM supports OIDC as a valid identity provider</strong>.<br><br>As we mentioned previously, flexibility is extremely important when talking about IAM, as we want to ensure that our engineers are able to have a frictionless working experience with the infrastructure. Fortunately, using OIDC as an identity provider for AWS makes the authentication for AWS much more flexible and secure, as it allows us to integrate our 3rd party services with AWS IAM seamlessly.</p><p>In my day-to-day usage, I use the OIDC identity provider for <strong>Github Actions</strong>. This gives Github Actions the ability to interact with AWS <strong>without any passwords or tokens</strong>. </p><p></p><img src="https://media.graphassets.com/resize=width:481,height:212/SDUq3oa2RDKkFVLpqvBl" alt="OIDC GitHub Role" title="unnamed (2).png" width="481" height="212" /><p><br>Using <strong>OIDC with Kubernetes</strong> is also great, as it helps integrate K8s’ service accounts with AWS IAM. For example, using OIDC allows us to give our Kubernetes service accounts the ability to assume roles from AWS.</p><p>My favorite live example is configuring ExternalDNS in EKS (Elastic Kubernetes Service powered by AWS) to work with our Route53 DNS records using OIDC integration. In short, ExternalDNS synchronizes exposed Kubernetes Services and Ingresses with DNS providers.</p><p>AWS provides the OpenID Connect Provider Issuer out-of-the-box when creating an EKS cluster, so in order to integrate our Kubernetes cluster with the OIDC, we just need to create the OIDC provider, and the following resources:</p><h4>1.<strong> Kubernetes Service Account</strong></h4><pre><code>apiVersion: v1
kind: ServiceAccount
metadata:
  name: external-dns
  annotations:
    eks.amazonaws.com/role-arn: arn:aws:iam::ACCOUNT-ID:role/IAM-SERVICE-ROLE-NAME
</code></pre><h4>2.<strong> AWS Role with the following trust relationship</strong></h4><pre><code>{
  &quot;Version&quot;: &quot;2012-10-17&quot;,
  &quot;Statement&quot;: [
    {
      &quot;Effect&quot;: &quot;Allow&quot;,
      &quot;Principal&quot;: {
        &quot;Federated&quot;: &quot;arn:aws:iam::${ACCOUNT_ID}:oidc-provider/${OIDC_PROVIDER}&quot;
      },
      &quot;Action&quot;: &quot;sts:AssumeRoleWithWebIdentity&quot;,
      &quot;Condition&quot;: {
        &quot;StringEquals&quot;: {
          &quot;${OIDC_PROVIDER}:aud&quot;: &quot;sts.amazonaws.com&quot;,
          &quot;${OIDC_PROVIDER}:sub&quot;: &quot;system:serviceaccount:my-namespace:my-service-account&quot;
        }
      }
    }
  ]
}</code></pre><p>You can check out more information on Creating an IAM role and policy for your Kubernetes service account; read <a title="https://docs.aws.amazon.com/eks/latest/userguide/create-service-account-iam-policy-and-role.html" href="https://docs.aws.amazon.com/eks/latest/userguide/create-service-account-iam-policy-and-role.html"><u>here</u></a>.</p><p>Not using OIDC may require engineers to use raw passwords and tokens, which are extremely insecure and inflexible, and mostly add a lot of friction to the process.</p><h2><strong>Good IAM is a must</strong></h2><p>Managing IAM for our organization can be a big deal; as we showed above, on the one hand, loose IAM can be a real danger to the whole company and can expose the company to many risks, but on the other hand, IAM policies that are too strict can make our engineer’s lives much harder.</p><p>Following the mentioned best practices, such as <strong>assuming roles</strong>, <strong>using AWS CloudTrail</strong> to monitor users and API activity, restricting role assumptions<strong> using trust relationship policies</strong>, and <strong>using OpenID Connect</strong> as a way to integrate your 3rd parties to AWS, you can make your IAM administration and operations much easier, flexible, and secure. In this age of cloud computing, that’s a must!</p><p>Want to discuss more policy permission models? - hit me up on <a title="https://io.permit.io/permitslack" href="https://io.permit.io/permitslack"><u>Permit’s Slack community</u></a>.</p>]]></content>
        <author>
            <name>Raz Cohen</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Intellyx BrainBlog: Authorization the Cloud Native Way]]></title>
        <id>authorization-the-cloud-native-way</id>
        <link href="https://www.permit.io/blog/authorization-the-cloud-native-way"/>
        <updated>2022-07-19T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[An Intellyx BrainBlog by Jason Bloomberg, for Permit.io]]></summary>
        <content type="html"><![CDATA[<p>Building authorization into software products is becoming an increasingly complex task as both software vendors, and software-centric enterprises shift their efforts toward cloud native computing.</p><p>Gone are the monolithic architectures and perimeter-based security strategies of old. In their place: applications consisting of numerous ephemeral microservices interacting in real-time with third-party SaaS applications and services. </p><p>Furthermore, the cloud is now the center of gravity for such cloud native applications – but on-premises assets remain an important part of the IT landscape, especially for enterprises. And software vendors and enterprises must both consider assets on the edge as well.</p><p>All these characteristics of modern IT impact the challenge of authorization – what permissions do users have on particular applications and services, given those assets are widely distributed and inherently dynamic?</p><p>Fortunately, the best practices of cloud native computing itself – beyond simply Kubernetes best practices – bring clarity to such authorization challenges. Here are the basics.</p><h2><strong>Cloud Native Best Practice #1: Declarative Control Plane</strong></h2><p>Cloud native computing depends upon comprehensive declarative abstractions that enable organizations to configure and control their IT infrastructure automatically as a matter of policy.</p><p>In other words, cloud native computing calls for a control plane that enables organizations to configure and control their entire IT landscape via declarative configurations and automated workflows.</p><p>This control plane decouples policy from code – an essential best practice for supporting authorization in cloud native environments. </p><p>Without this separation, developers end up mixing code for the authorization layer with the application code itself, leading to problematic technical debt that impedes the organization’s ability to support dynamic microservices and in general, expand the functionality of the applications over time.</p><h2>Cloud Native Best Practice #2: Statelessness</h2><p>In the cloud native context, microservices are inherently stateless. Given their fundamentally ephemeral nature, it would slow everything down if individual microservices kept track of the state of anything. </p><p>Instead, Kubernetes abstracts the persistence layer so that microservices can access state information as needed, without the fear of losing information should the microservice go away – and most importantly, without slowing down the behavior of the microservice.</p><p>Traditional approaches to authorization, in contrast, are inherently stateful. Sessions must keep track of the identities of authorized users and the permissions they have during the session.</p><p>Sessions, however, don’t exist as such in a cloud native world. The authorization infrastructure must behave in a fundamentally stateless manner, determining and applying appropriate permissions on the fly for each request.</p><h2>Cloud Native Best Practice #3: Real-Time Behavior</h2><p>Second, only to ephemerality, the most important benefit of microservices’ stateless nature is the ability to execute interactions in real-time.</p><p>‘Real-time’ doesn’t mean simultaneous. Rather, it refers to event-driven behavior that takes place immediately upon the event in question.</p><p>Cloud native authorization layers must therefore be event-driven as well. When applications leverage user invites, role assignments, or access to third-party services or data, such capabilities must take place in real-time.</p><p>In fact, every time an event that affects authorization takes place, the cloud native infrastructure in place must ensure the authorization layer learns about it and remains in sync with both the application and relevant third-party data sources.</p><p>Real-time behavior thus takes place within the context of a stateless architecture by spinning up copies of an authorization microservice as necessary. These microservices then sync up with real-time, event-driven updates to keep their state up to date. </p><h2>Cloud Native Best Practice #4: Zero Trust</h2><p>If we can no longer retain authentication and authorization information as session state, then it follows that every interaction is untrusted. We must go through the authentication and authorization process every time, for every request – an example of what we call zero trust.</p><p>The downside to such zero trust interactions is their performance overhead. Essentially, we must log in and authorize every user every time they click on anything. Won’t that slow everything down?</p><p>Not if we take a cloud native approach to our authentication and authorization technology itself. We must leverage microservices for such functions, as well as lightweight protocols that are fundamentally cloud native in nature in that they take full advantage of the declarative cloud native control plane.</p><h2>Cloud Native Best Practice #5: GitOps</h2><p>GitOps is a set of best practices for deploying and managing code in production, but it is also an important subset of broader cloud native principles for IT generally.</p><p>Cloud native best practices #1 – 4 above require that the development team create a separate microservice to manage permissions, where they can update it as necessary in a real-time, event-driven fashion.</p><p>They must make sure those updates, therefore, also follow cloud native principles – and that’s where GitOps comes in.</p><p>GitOps enables developers to create a pull request for every version change for every microservice, including the ones they use for authorization. </p><p>As developers update their products (including their access control layers), they can push a new commit with new code, leveraging standard GitOps tests and checks before automatically applying the changes to the authorization layer at deployment.</p><h2>Cloud Native Best Practice #6: Hybrid End-to-End</h2><p>The term ‘cloud native’ would suggest that everything is happening in the cloud – but that’s not necessarily the case. In reality, cloud native means we’re extending the core best practices of the cloud (scale, elasticity, ephemerality, etc.) to all of IT – including on-premises and the edge.</p><p>Cloud native authorization, therefore, must work in this hybrid, end-to-end environment, even though each organization will have a different mix of old and new technologies in place. Fortunately, all the practices covered in this article empower organizations to make this requirement a reality. </p><p>As long as we have a comprehensive control plane, event-driven zero-trust interactions, as well as mature, standards-based APIs gluing everything together, then it is finally possible to build a cloud native authorization layer that meets organizations’ needs now and into the future.</p><h2>The Intellyx Take</h2><p>There is more to the cloud native authorization story than what fits in this article – so it’s a good thing it’s the first in a series.</p><p>In the second article in the series, we’ll be discussing the various open-source solutions that can help developers implement a cloud native authorization layer, including the Open Policy Agent (OPA) and the Open Policy Administration Layer (OPAL).</p><p>The third article will talk about using a SaaS solution to streamline permissions instead of having developers build their own – including more details about Permit.io’s SaaS-based cloud native permissions layer.</p><p><em>Copyright © Intellyx LLC. Permit.io is an Intellyx customer. Intellyx retains final editorial control of this article.</em></p>]]></content>
        <author>
            <name>Jason Bloomberg</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[OPAL + OPA VS XACML]]></title>
        <id>opal-opa-vs-xacml</id>
        <link href="https://www.permit.io/blog/opal-opa-vs-xacml"/>
        <updated>2022-05-18T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[A view of OPAL + OPA as an alternative to XACML]]></summary>
        <content type="html"><![CDATA[<h2><strong>Introduction</strong></h2><p>Way back in 2013, various devs were either <a title="https://www.forrester.com/blogs/13-05-07-xacml_is_dead/" href="https://www.forrester.com/blogs/13-05-07-xacml_is_dead/"><u>announcing</u></a> or <a title="https://www.kuppingercole.com/blog/kuppinger/another-dead-body-in-it-or-is-xacml-still-alive" href="https://www.kuppingercole.com/blog/kuppinger/another-dead-body-in-it-or-is-xacml-still-alive"><u>debating</u></a> the death of XACML - yet XACML’s goal to promote a common terminology and interoperability between authorization implementations remains valid, and it still serves as a solid base to describe the structure of authorization architectures.</p><p>The IAM landscape, authorization included, has <a title="https://www.permit.io/blog/authorization-is-changing" href="https://www.permit.io/blog/authorization-is-changing"><u>evolved drastically in the past couple of years</u></a> and allowed for new XACML alternatives to be created. This significant shift was a result of the rising demand for increasingly advanced authorization, which was generated by the growing complexity of applications and their migration to microservices and cloud-native structures. With advancements in technology, the emergence of shift-left and low/no-code developers, and the need for event-driven dynamic authorization - a replacement for XACML had to evolve. </p><p>One such XACML alternative is OPA + OPAL. <a title="https://www.permit.io/blog/introduction-to-opa" href="https://www.permit.io/blog/introduction-to-opa">Open Policy Agent (OPA)</a> is an open-source project created as a general-purpose policy engine to serve any policy enforcement requirements that unifies policy enforcement across the stack without being dependent on implementation details. It can be used with any language and network protocol, supports any data type, and evaluates and returns answers quickly. OPA’s policy rules are written in Rego - a high-level declarative (Datalog-like) language. <br><br>It’s important to note that OPA only provides an alternative to XACML’s PDP (More on that further). OPA is enhanced by<a title="https://www.permit.io/blog/introduction-to-opal" href="https://www.permit.io/blog/introduction-to-opal"> OPAL (Open Policy Administration Layer) </a>- another open-source solution that allows you to easily keep your authorization layer up-to-date in real-time. More information about the project is available <a title="https://www.permit.io/blog/introduction-to-opal" href="https://www.permit.io/blog/introduction-to-opal"><u>here</u></a>. The combination of OPA and OPAL provides a solid alternative for XACML. </p><p>To better understand this alternative, we’ll compare the traditional XACML architecture authorization flow with the one provided by OPA + OPAL and then discuss the differences. It&#39;s important to note that while being a primarily <a title="https://www.permit.io/blog/what-is-abac" href="https://www.permit.io/blog/what-is-abac">Attribute-Based Access Control (ABAC)</a> system XACML can also be used to describe <a title="https://www.permit.io/blog/rbac-with-permit" href="https://www.permit.io/blog/rbac-with-permit">Role-Based Access Control (RBAC)</a> and other models.</p><p></p><h2><strong>A few basic terms to understand the flow:</strong></h2><p>The architecture of XACML consists of a few different modules that make up the process of making authorization decisions. Let’s take a look at those different parts: <br><br><u><strong>PEP - “Policy Enforcement Point”: </strong></u><br>The PEP intercepts a user’s access to a resource, and either grants or denies access to the resource requested by the user. PEPs don&#39;t make the decisions; they enforce them.<br>PEPs can potentially also adjust requests or their results before passing them through (aka data-filtering). Examples of PEPs are in-code control flow (i.e. “if”), middleware, reverse proxies, and API gateways</p><p><u><strong>PDP - “Policy Decision Point”:</strong></u><br>The PDP evaluates authorization requests against relevant policies and a data snapshot aggregated from the distributed data layer and makes an authorization decision. </p><p><u><strong>PAP - “Policy Administration Point”:</strong></u><br>The PAP is in charge of managing all relevant policies to be used by the PDP.</p><p><u><strong>PIP - “Policy Information Point”:</strong></u><u><br></u>The PIP is any data source (Internal or external) that contains attributes that are relevant for making policy decisions. <br><br><u><strong>PRP - “Policy Retrieval Point”:<br></strong></u>The PAP is the main source of policies - it stores all relevant policies to be used by the PDP, and is managed by the PAP (In OPA it&#39;s a bundle-server, and in OPAL this is often a Git repository or an HTTP bundle server). </p><p></p><h2><strong>Traditional XACML Architecture</strong></h2><img src="https://media.graphassets.com/resize=width:655,height:630/0ZA0Z5hwQpSFwoXZbqVm" alt="XACML Architecture" title="Group 2.png" width="655" height="630" /><p>Let’s start by reviewing the architecture of traditional XACML and its authorization flow:</p><ol><li><div><p><strong>Everything starts with a user (or automated entity) interacting with an application. </strong>The user sends a <strong>request</strong> to access and perform an action on any sort of resource within the application. Before being submitted to the application logic, the request passes through the PEP. The PEP is in charge of either granting or denying a user’s request for access to the resource.</p></div></li><li><div><p>The PEP translates the user&#39;s request into an XACML authorization request. It is important to note that one user request can trigger multiple authorization queries (as it interacts with multiple resources).</p></div></li><li><div><p>To know whether the request should be approved or rejected, the PEP sends the authorization request to the PDP.</p></div></li><li><div><p>The PDP makes make authorization decisions based on pre-configured XACML formatted policies.</p></div></li><li><div><p>The policies are stored in the PRP and are managed by the PAP.</p></div></li><li><div><p>If needed - the PDP queries relevant PIPs <strong>per query </strong>for any additional relevant information. </p></div></li><li><div><p>The PDP reaches a decision (Permit / Deny / etc.) and returns it to the PEP.</p></div></li><li><div><p>The user is either granted or denied access to the resource by the PEP, based on the PDP’s decision.<br> </p></div></li></ol><h2><strong>OPA + OPAL Architecture</strong></h2><img src="https://media.graphassets.com/resize=width:656,height:630/KaU8h44BRNSugOFF58N4" alt="OPA + OPAL Architecture" title="Group 4.png" width="656" height="630" /><p><br>While based on similar principles, OPA and OPAL provide a slightly different authorization model with significant benefits:</p><ol><li><div><p>The first step is identical to XACML - the user / automated entity sends a request and it passes through the PEP.</p></div></li><li><div><p>The PEP converts the user&#39;s request into queries for the PDP (In this case - OPA).</p></div></li><li><div><p>The queries are submitted by the PEP to the PDP (OPA) to know whether the request should be approved or rejected. So far so good - here is where things are a bit different. First of all, OPA stores all relevant policies within its cache. Second - the policies are represented as code (In Rego), unlike XACML where they are represented as configuration (as XML schema).</p></div></li><li><div><p>The PAP (In this case - the OPAL Server) serves a dual function. It both functions as a Policy Administration Point and a Policy Information Administration Point. <br><br>4.1 <strong>As a Policy Administration Point</strong> - The OPAL server is in charge of managing all relevant policies and supplying them to OPA, within the PDP.<br><br>Policies are stored as code in a GIT repository (default option, though others exist), which acts as the PRP. The OPAL Server receives policy updates from the PRP and instructs the OPAL clients to update OPAs’ caches accordingly. Every time a change in a policy happens in GIT, it is pulled by the OPAL Server and pushed into OPA’s cache via the OPAL clients which listen to the server (based on topics) and are located next to the OPA instances. By leveraging GIT and policy as code, OPAL allows us to use Gitops best practices (e.g. tests, code-review, benchmarking) <br><br><strong>In this manner, OPA always stays up to date with the latest policy changes in real-time without the need for redeployment.</strong> <br><br>4.2<strong> As a Policy Information Administration Point</strong> - the OPAL server informs the OPAL Client within the PDP on changes to data within the PIPs according to selected topics. With the updates to the client, the server sends instructions on how to query the PIPs, and the OPAL Client fetches the data directly from the PIPs (according to the instructions) and updates OPA with the most recent information. As this process is continuous, <strong>the information stored in the PDP cache is always up to date with the latest data needed to make access decisions in the most accurate way possible</strong>. </p></div></li><li><div><p>The PDP (OPA) reaches a decision (Permit / Deny / etc.) and returns it to the PEP.</p></div></li><li><div><p>Based on the decision made by the PDP (OPA), the PEP either grants or denies the user’s access to the resource. <br></p></div></li></ol><h2>The differences </h2><p>From the differences in the authorization flow between the traditional XACML and OPA+OPAL, we can note three significant benefits which the latter provides:</p><table><tbody><tr><td><p><strong>Component</strong></p></td><td><p><strong>XACML</strong></p></td><td><p><strong>OPA+OPAL</strong></p></td></tr><tr><td><p>Policy</p></td><td><p>XACML configuration</p></td><td><p>Rego code</p></td></tr><tr><td><p>PDP</p></td><td><p></p></td><td><p>OPA (+ OPAL Client)</p></td></tr><tr><td><p>PAP</p></td><td><p></p></td><td><p>OPAL server</p></td></tr><tr><td><p>PRP</p></td><td><p></p></td><td><p>GIT (Or any other policy source)</p></td></tr><tr><td><p>Policy loading</p></td><td><p>As part of the deployment</p></td><td><p>Real-time</p></td></tr><tr><td><p>Data loading</p></td><td><p>As part of a query</p></td><td><p>Real-time</p></td></tr></tbody></table><ol><li><div><p>The OPAL server’s ability to receive updates from GIT (Or any other policy source) keeps OPA up to date with the most recent policies - <strong>allowing us to make policy changes on the fly and have them utilized by the PDP with minimal latency</strong>. Leveraging policy as code within a GIT repository enables the adoption of configuration as code and Gitops in general.</p></div></li><li><div><p>The OPAL server not only manages the policies themselves, but also the PIPs from which additional data is often required to make a policy decision. The OPAL Client constantly listens to changes in relevant PIPs (Internal or external databases) and uses data fetchers to keep OPA’s cache constantly up to date with the latest information needed to reach an authorization decision. Because this is an ongoing process and not done per query, <strong>OPA can have all the relevant information in its cache to make policy decisions even if the PIP is not available</strong> - preventing the PDP from making the authorization decision. </p></div></li><li><div><p>While not evident from the authorization flow which we described, it is important to note that policy in <strong>Rego is much more accessible and easier to read/maintain than in XACML</strong>. Check out this example: (For a more detailed explanation of this example <a title="https://www.permit.io/blog/implement-rbac-using-opa" href="https://www.permit.io/blog/implement-rbac-using-opa"><u>check out this guide</u></a><a target='_blank' title="https://media.graphassets.com/resize=width:1684,height:726/wNvKngm5SZKzJw353WY2" href="https://media.graphassets.com/resize=width:1684,height:726/wNvKngm5SZKzJw353WY2">)<br><br></a></p><img src="https://media.graphassets.com/output=format:webp/resize=width:1684,height:726/wNvKngm5SZKzJw353WY2" alt="Rego VS XACML" title="Screen Shot 2022-05-18 at 19.30.39.png" width="1684" height="726" /></div></li></ol><p><a title="https://media.graphassets.com/resize=width:1684,height:726/wNvKngm5SZKzJw353WY2" href="https://media.graphassets.com/resize=width:1684,height:726/wNvKngm5SZKzJw353WY2"><em>Same policy side to side - Rego and XACML</em></a></p><p><br>The differences between Traditional XACML and OPA+OPAL highlight the drastic changes in the authorization space that occurred in recent years. OPAL’s ability to receive both data and policy updates in real-time allows for the creation of event-driven dynamic authorization. At the same time, OPA provides the ability to define more complex authorization structures fit for microservices and cloud-native structures, and its policy language Rego is easier to read/maintain and provides accessibility to low/no-code developers. <br><br>OPAL is a mature open-source project which is already keeping hundreds of policy agents updated in real-time. You can join <a title="https://io.permit.io/permitslack" href="https://io.permit.io/permitslack"><u>OPAL’s Slack community</u></a> to chat with other devs who use OPAL for their projects, <a title="https://github.com/permitio/opal" href="https://github.com/permitio/opal"><u>contribute to the open-source project</u></a>, or<a title="https://twitter.com/opal_ac" href="https://twitter.com/opal_ac"><u> follow OPAL on Twitter </u></a>for the latest news and updates.</p><p></p>]]></content>
        <author>
            <name>Daniel Bass</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Real-time dynamic authorization - an introduction to OPAL]]></title>
        <id>introduction-to-opal</id>
        <link href="https://www.permit.io/blog/introduction-to-opal"/>
        <updated>2022-04-27T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Intro to OPAL: an open-source administration layer for Open Policy Agent (OPA) that allows you to easily keep your authorization layer up-to-date in real-time]]></summary>
        <content type="html"><![CDATA[<h2><strong>TL;DR</strong></h2><p>OPAL is an <a title="https://github.com/permitio/opal" href="https://github.com/permitio/opal"><u>open-source</u></a> administration layer for <a title="https://www.permit.io/blog/introduction-to-opal" href="https://www.permit.io/blog/introduction-to-opal">Open Policy Agent (OPA)</a> that allows you to easily keep your authorization layer up-to-date in real-time. OPAL detects changes to both policy and policy data and pushes live updates to your agents - bringing open policy up to the speed needed by live applications. </p><p>As your application state changes (whether it&#39;s via your APIs, DBs, git, S3, or 3rd-party SaaS services), OPAL will make sure your services are always in sync with the authorization data and policy they need.</p><h2><strong>⁠The challenge of building authorization </strong></h2><p>Cloud-native / microservice-based products can be quite complicated, and so is building access control and managing permissions for them. Distributed applications and microservices require a lot of authorization points by design and the ever-changing requirements and regulations from various departments constantly challenge every authorization solution. Moreover, even the simplest miscalculation in the authorization layer can lead to devastating consequences for your application in the form of security vulnerabilities and privacy/compliance issues. </p><p>There are <a title="https://www.permit.io/blog/5-best-practices-for-building-cloud-native-permissions" href="https://www.permit.io/blog/5-best-practices-for-building-cloud-native-permissions"><u>several best practices</u></a> for building an authorization layer correctly (and avoiding the need to constantly rebuild it) - the first of which is decoupling policy and code. In short - Having the code of the authorization layer mixed in with the code of your application can result in trouble upgrading, adding capabilities, and monitoring the code as it is replicated between different microservices. Each change would require us to refactor large areas of code that constantly continue to drift further from one another as these microservices develop. </p><p>To avoid this, we recommend creating a separate microservice for authorization that will be used by the other services in order to fulfill their authorization needs. Open Policy Agent (OPA), which is the default policy engine for OPAL, allows you to do just that. You can read more about OPA <a title="https://www.permit.io/blog/introduction-to-opa" href="https://www.permit.io/blog/introduction-to-opa"><u>here</u></a>. </p><p>Another best practice, which OPA alone does not fulfill, is making your authorization layer event-driven.</p><img src="https://media.graphassets.com/resize=width:1022,height:786/kVBTeY47TQit7jQtelze" alt="XACML Architecture & Flow" title="XACML_Architecture_&_Flow.png" width="1022" height="786" /><p></p><h2><strong>Why event-driven?</strong></h2><p>Almost all modern applications rely on abilities such as user invites, role assignment, or the usage of 3rd party data sources. All of these abilities have one thing in common: <strong>They have to be managed in a real-time fashion</strong>. Every time an event that affects authorization happens, we need it to be pushed into our authorization layer ASAP so it can stay in sync with the application, any relevant 3rd party data service, or changes in policy. </p><p>Here’s an example - Say you want to control who has access to a specific feature in your application based on a user’s payment status. If the user paid for the feature - they have access. This scenario creates three main challenges:</p><ol><li><div><p>The data about the payment status of users (As well as various other types of data relevant to making authorization decisions) often resides in a database external to your organization, or a 3rd party service like Stripe or PayPal. You need your authorization layer to be aware of any relevant changes in these databases and make decisions based on the most up-to-date information available. To achieve this, we’d need something that listens to changes in the data sources relevant to us, and pulls them into our authorization layer so it can make the most accurate, relevant, and up-to-date decisions.</p></div></li><li><div><p>Delays in updates to the authorization snapshot can create consistency problems. Consider this example - a request is being handled by two microservices in the same chain. The first microservice can consider the request in one state (e.g. This user is not a paying user), while the following microservice considers the request in another state. This can cause the overall request to fall into an undefined state.</p></div></li><li><div><p>Different microservices need different subsets of policy and data, just keeping track of the needs of each one can be challenging without an event stream to guide us.  </p></div></li></ol><p>Being a common problem, large organizations such as Netflix and Pinterest who rely on OPA as their policy engine were required to create their own solutions, building multiple administration layers on top of OPA. Manish Mehta, a senior security officer from Netflix, shared <a title="https://youtu.be/R6tUNpRpdnY?t=915" href="https://youtu.be/R6tUNpRpdnY?t=915"><u>Netflix’s permissions design in a talk at KubeCon</u></a>. Unfortunately, these giants haven’t open-sourced their solutions; but their work did inspire the creation of OPAL.<br></p><img src="https://media.graphassets.com/resize=width:1600,height:786/q5IX9RCBR4S23PzBs9kS" alt="How Netflix uses OPA in permissions enforcement talk at KubeCon, 2017." title="unnamed.png" width="1600" height="786" /><p>How Netflix uses OPA in permissions enforcement talk at KubeCon, 2017.</p><p></p><h2><strong>How OPAL helps solve these challenges: </strong></h2><p>OPAL is an open-source solution that helps us solve these two challenges by providing two significant features: </p><ul><li><div><p>The ability to track a <strong>designated policy repository</strong> (Such as GitHub, GitLab, Bitbucket) for changes (by either setting a webhook or web polling every X seconds), thus serving as a PAP (Policy Administration Point) and propagating these changes into OPA (The PDP - Policy Decision Point in this case) thus always keeping it up to date.</p></div></li><li><div><p>The ability to track <strong>any relevant data source</strong> (API, Database, external service) for updates via REST API, and fetch up-to-date data back into OPA. </p></div></li></ul><p>These two features make sure that OPA is always up to date with both the latest policy information and the latest data - allowing it to always make the most accurate and relevant authorization decisions.  </p><p>OPAL’s ability to solve these challenges led to its adoption by a number of leading organizations such as Tesla, Zapier, and Accenture.</p><p></p><h2><strong>How does it work? A little deep dive into OPAL’s architecture:</strong></h2><img src="https://media.graphassets.com/resize=width:1997,height:945/nRVOMAOOQqGz4mAeoecw" alt="OPAL’s architecture" title="68747470733a2f2f692e6962622e636f2f43766d583872522f73696d706c69666965642d6469616772616d2d686967686c696768742e706e67 (1).png" width="1997" height="945" /><p><br>OPAL consists of two main components: the <strong>OPAL Server </strong>and the <strong>OPAL Client</strong>. </p><p><strong>The OPAL Server</strong> is responsible for two things:</p><ul><li><div><p>It tracks a designated policy repository for changes via webhook or polling for policy updates and pushes these changes to the OPAL Client. </p></div></li><li><div><p>It tracks all relevant data sources for changes via webhook, signals the OPAL Client about any changes via WebSocket, and provides it with information on where the data is located. </p></div></li></ul><p>In both of these cases, the OPAL server creates a pub/sub channel that the OPAL client(s) can subscribe to with topics they need to track. As soon as there’s a change, the OPAL server notifies the subscribed clients. <br></p><p><strong>The OPAL client </strong>is deployed alongside OPA and provides real-time updates of all relevant data and policy from the OPAL Server to OPA, so it also has a dual function:</p><ul><li><div><p><strong>Policy changes</strong>: Whenever there is a relevant policy update in the policy repository, it is pulled by the client from the server, and propagated into OPA. </p></div></li><li><div><p><strong>Data updates</strong>: Whenever there’s a relevant data update in a topic that the OPAL client is registered to, the OPAL server will push an update to the OPAL client with information on where to pull the newly updated data from. The client will then reach out to fetch the latest relevant data with the help of<a title="https://docs.opal.ac/tutorials/write_your_own_fetch_provider/" href="https://docs.opal.ac/tutorials/write_your_own_fetch_provider/"> <strong>OPAL Data Fetchers</strong></a>.</p></div></li></ul><p>OPAL Data Fetchers are configured to grab updates from a specific data source. A data fetcher has two main methods: `fetch()`, which is in charge of querying the data source, and `process()` to filter the data and convert it to JSON format, OPA’s format. The OPAL Data fetchers retrieve any relevant data from their designated data source and propagate it to OPA. <br><br>Another important feature of the OPAL client is its ability to only subscribe to the specific data it needs. If your application requires large amounts of data to support authorization logic, the OPAL client can subscribe only to the specific parts needed for that specific agent - this provides benefits both in terms of security (By keeping access to data on a “need-to-know” basis) and manageability. </p><p>This way, OPA can make policy decisions based on the most recent policies and data. A deeper dive into OPAL’s architecture and communication flows is available in <a title="https://github.com/permitio/opal/blob/master/docs/architecture.md" href="https://github.com/permitio/opal/blob/master/docs/architecture.md"><u>OPAL’s documentation</u></a>. </p><p><strong>Keeping OPA up to date in real-time is crucial</strong>, especially when dealing with authorization at the application level. By using OPAL we enhance OPA’s authorization capabilities with two major abilities:</p><ul><li><div><p><strong>Updating our policies in real-time</strong>, and having our authorization decisions made on the most up-to-date policies available. </p></div></li><li><div><p><strong>Pulling relevant data from any source</strong>, thus being able to make authorization decisions based on data from any Database or service. </p></div></li></ul><h2><strong>Help us grow - </strong></h2><p>OPAL is an ongoing open-source project which is already keeping hundreds of policy agents updated in real-time. You can join <a title="https://io.permit.io/permitslack" href="https://io.permit.io/permitslack"><u>OPAL’s Slack community</u></a> to chat with other devs who use OPAL for their projects, <a title="https://github.com/permitio/opal" href="https://github.com/permitio/opal"><u>contribute to the open-source project</u></a>, or<a title="https://twitter.com/opal_ac" href="https://twitter.com/opal_ac"><u> follow OPAL on Twitter </u></a>for the latest news and updates.</p>]]></content>
        <author>
            <name>Daniel Bass</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Load external data into OPA - The Good, The Bad, and The Ugly]]></title>
        <id>load-external-data-into-opa</id>
        <link href="https://www.permit.io/blog/load-external-data-into-opa"/>
        <updated>2022-04-04T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[A guide to figuring out which data fetching method is best for you, with full knowledge of each method’s ‘Good, Bad, and Ugly’ aspects.]]></summary>
        <content type="html"><![CDATA[<p>There are several ways to create a data fetching mechanism for <a title="https://www.permit.io/blog/introduction-to-opa" href="https://www.permit.io/blog/introduction-to-opa">Open Policy Agent (OPA)</a> - each of them has its pros and cons. To make sense of these different methods, I&#39;ve decided to create this guide that will help you figure out which data fetching method would be best for you, with full knowledge of each method’s ‘good, bad, and ugly’ aspects. </p><h2>TL;DR - </h2><h3>The methods that we are going to review are:</h3><ol><li><div><p><a title="#1" href="#1">Including data in JWT tokens</a></p></div></li><li><div><p><a title="#2" href="#2">Overload input for OPA within the query</a></p></div></li><li><div><p><a title="#3" href="#3">Polling for data using Bundles</a></p></div></li><li><div><p><a title="#4" href="#4">Pushing data into OPA using the API</a></p></div></li><li><div><p><a title="#5" href="#5">Pulling data using OPA during Policy Evaluation</a></p></div></li><li><div><p><a title="#6" href="#6">OPAL (Open Policy Administration Layer)</a></p></div></li></ol><p>Before we dive into details, let’s first cover some basics - </p><p></p><h2>What is OPA </h2><p>Authorization is becoming increasingly complicated - applications are getting bigger and require handling more users than ever before, policies are becoming more complex and dependent on multiple factors (Like a client’s location, time of the action, user roles, and relations to resources).</p><p>This is where OPA (Open Policy Agent) comes in - OPA is a great open-source tool that allows us to evaluate complicated policies. It’s fast, part of the CNCF (Which means it adheres to CNCF’s guidelines and standards), and is used for handling permissions in some of the largest companies in the world (e.g. Netflix, Pinterest, and others). You can check out an introduction to OPA <a title="https://www.permit.io/blog/introduction-to-opa" href="https://www.permit.io/blog/introduction-to-opa"><u>here</u></a>. <br></p><h3>How OPA Works with Data</h3><p>Managing policies with OPA often requires relevant contextual data - Information about the user, the resource they are trying to access, etc. Without this information, OPA will not be able to make the right decisions when it comes to deciding on policies. </p><p>For example - a policy that states “Only paying users can access this feature” requires OPA to have information on:</p><ul><li><div><p>Who my users are</p></div></li><li><div><p>Which one of them is a paying user, and which isn’t</p></div></li></ul><p>A policy that states “Users in the application can only access their own photos, or those of their children” requires OPA to know:<br></p><ul><li><div><p>Who are the application’s users</p></div></li><li><div><p>Which user is a parent, which user is a child, and which user relates to who</p></div></li><li><div><p>Which photo belongs to each user</p></div></li></ul><p>Having access to this contextual data is thus critical for OPA to be able to make its decisions. <br><br><strong>The bottom-line question is - how can we bring this data into OPA, and which way is the most effective to do so? </strong><br></p><h2>The data fetching mechanism: Basic requirements </h2><p>Before we dive into the different methods of fetching data for OPA, let’s agree on a couple of basic guidelines for how this data fetching mechanism should work:</p><ol><li><div><p>It&#39;s necessary to be able to handle data about policies on a large scale</p></div></li><li><div><p>Because data can come from many sources, thus getting very complex very quickly, we want this mechanism to be as easily manageable as possible.</p></div></li><li><div><p>The data fetching mechanism needs to be operational in real-time (This is a crucial component that will allow us to avoid a <a title="https://storage.googleapis.com/pub-tools-public-publication-data/pdf/41f08f03da59f5518802898f68730e247e23c331.pdf" href="https://storage.googleapis.com/pub-tools-public-publication-data/pdf/41f08f03da59f5518802898f68730e247e23c331.pdf"><u>&quot;New enemy attack&quot;</u></a> - a situation where a user with revoked permission can still access sensitive data because the permissions have not been updated in time between the different parts of the system).</p></div></li><li><div><p>It should be easy to maintain because the need for access control is here to stay and is likely to evolve in the future.</p></div></li></ol><p>Now that we&#39;ve established some basic requirements, let’s dive into the various data fetching mechanisms we can utilize to solve our issue in the most efficient way.</p><p></p><p>Let’s dive in!</p><p></p><h2><a id="1" title="#1" href="#1">1. Including data in JWT tokens:</a></h2><img src="https://media.graphassets.com/resize=width:654,height:630/n7P0tgcTnm2IfWuphTGm" alt="Including data in JWT tokens" title="1.png" width="654" height="630" /><p><br><a title="https://tools.ietf.org/html/rfc7519" href="https://tools.ietf.org/html/rfc7519">JSON Web Tokens (JWT)</a> allow you to securely transmit signed JSON data between software systems and are usually produced during the authentication process. JWTs can be sent to OPA as inputs thus enabling OPA to make decisions about a Policy query.</p><p>For example, this is what a <a title="https://jwt.io/#debugger-io?token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwicm9sZXMiOlsiYWRtaW4iXSwicmVsYXRlZF9pbWFnZXMiOlsiaW1hZ2UxLnBuZyIsImltYWdlMi5wbmciXSwiaWF0IjoxNTE2MjM5MDIyfQ.Qkur5-lKPBMhZLqgl-BjkZzyjiHVSoq1p1C36vUiuQU" href="https://jwt.io/#debugger-io?token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwicm9sZXMiOlsiYWRtaW4iXSwicmVsYXRlZF9pbWFnZXMiOlsiaW1hZ2UxLnBuZyIsImltYWdlMi5wbmciXSwiaWF0IjoxNTE2MjM5MDIyfQ.Qkur5-lKPBMhZLqgl-BjkZzyjiHVSoq1p1C36vUiuQU"><u>JWT with authorization data looks like</u></a>:</p><img src="https://media.graphassets.com/resize=width:591,height:617/XXImGfMASy2JqNFXDuFh" alt="JWT Token Example" title="example 1.png" width="591" height="617" /><p>The first part is the algorithm for the secure signing, and in the middle, we can see the roles and related images for our authorization.</p><p><u>The good:</u></p><p>JWTs are an easy-to-use well-known technology that you probably already utilize in your system (as part of the authentication layer).</p><p><u>The bad:</u></p><p>JWTs have a size limit - not everything can be decoded into a JWT, while it looks OK in the example presented above, if a user <a title="https://jwt.io/#debugger-io?token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwicm9sZXMiOlsiYWRtaW4iXSwicmVsYXRlZF9pbWFnZXMiOlsiaW1hZ2UwLnBuZyIsImltYWdlMS5wbmciLCJpbWFnZTIucG5nIiwiaW1hZ2UzLnBuZyIsImltYWdlNC5wbmciLCJpbWFnZTUucG5nIiwiaW1hZ2U2LnBuZyIsImltYWdlNy5wbmciLCJpbWFnZTgucG5nIiwiaW1hZ2U5LnBuZyIsImltYWdlMTAucG5nIiwiaW1hZ2UxMS5wbmciLCJpbWFnZTEyLnBuZyIsImltYWdlMTMucG5nIiwiaW1hZ2UxNC5wbmciLCJpbWFnZTE1LnBuZyIsImltYWdlMTYucG5nIiwiaW1hZ2UxNy5wbmciLCJpbWFnZTE4LnBuZyIsImltYWdlMTkucG5nIiwiaW1hZ2UyMC5wbmciLCJpbWFnZTIxLnBuZyIsImltYWdlMjIucG5nIiwiaW1hZ2UyMy5wbmciLCJpbWFnZTI0LnBuZyIsImltYWdlMjUucG5nIiwiaW1hZ2UyNi5wbmciLCJpbWFnZTI3LnBuZyIsImltYWdlMjgucG5nIiwiaW1hZ2UyOS5wbmciLCJpbWFnZTMwLnBuZyIsImltYWdlMzEucG5nIiwiaW1hZ2UzMi5wbmciLCJpbWFnZTMzLnBuZyIsImltYWdlMzQucG5nIiwiaW1hZ2UzNS5wbmciLCJpbWFnZTM2LnBuZyIsImltYWdlMzcucG5nIiwiaW1hZ2UzOC5wbmciLCJpbWFnZTM5LnBuZyIsImltYWdlNDAucG5nIiwiaW1hZ2U0MS5wbmciLCJpbWFnZTQyLnBuZyIsImltYWdlNDMucG5nIiwiaW1hZ2U0NC5wbmciLCJpbWFnZTQ1LnBuZyIsImltYWdlNDYucG5nIiwiaW1hZ2U0Ny5wbmciLCJpbWFnZTQ4LnBuZyIsImltYWdlNDkucG5nIiwiaW1hZ2U1MC5wbmciLCJpbWFnZTUxLnBuZyIsImltYWdlNTIucG5nIiwiaW1hZ2U1My5wbmciLCJpbWFnZTU0LnBuZyIsImltYWdlNTUucG5nIiwiaW1hZ2U1Ni5wbmciLCJpbWFnZTU3LnBuZyIsImltYWdlNTgucG5nIiwiaW1hZ2U1OS5wbmciLCJpbWFnZTYwLnBuZyIsImltYWdlNjEucG5nIiwiaW1hZ2U2Mi5wbmciLCJpbWFnZTYzLnBuZyIsImltYWdlNjQucG5nIiwiaW1hZ2U2NS5wbmciLCJpbWFnZTY2LnBuZyIsImltYWdlNjcucG5nIiwiaW1hZ2U2OC5wbmciLCJpbWFnZTY5LnBuZyIsImltYWdlNzAucG5nIiwiaW1hZ2U3MS5wbmciLCJpbWFnZTcyLnBuZyIsImltYWdlNzMucG5nIiwiaW1hZ2U3NC5wbmciLCJpbWFnZTc1LnBuZyIsImltYWdlNzYucG5nIiwiaW1hZ2U3Ny5wbmciLCJpbWFnZTc4LnBuZyIsImltYWdlNzkucG5nIiwiaW1hZ2U4MC5wbmciLCJpbWFnZTgxLnBuZyIsImltYWdlODIucG5nIiwiaW1hZ2U4My5wbmciLCJpbWFnZTg0LnBuZyIsImltYWdlODUucG5nIiwiaW1hZ2U4Ni5wbmciLCJpbWFnZTg3LnBuZyIsImltYWdlODgucG5nIiwiaW1hZ2U4OS5wbmciLCJpbWFnZTkwLnBuZyIsImltYWdlOTEucG5nIiwiaW1hZ2U5Mi5wbmciLCJpbWFnZTkzLnBuZyIsImltYWdlOTQucG5nIiwiaW1hZ2U5NS5wbmciLCJpbWFnZTk2LnBuZyIsImltYWdlOTcucG5nIiwiaW1hZ2U5OC5wbmciLCJpbWFnZTk5LnBuZyIsImltYWdlMTAwLnBuZyIsImltYWdlMTAxLnBuZyIsImltYWdlMTAyLnBuZyIsImltYWdlMTAzLnBuZyIsImltYWdlMTA0LnBuZyIsImltYWdlMTA1LnBuZyIsImltYWdlMTA2LnBuZyIsImltYWdlMTA3LnBuZyIsImltYWdlMTA4LnBuZyIsImltYWdlMTA5LnBuZyIsImltYWdlMTEwLnBuZyIsImltYWdlMTExLnBuZyIsImltYWdlMTEyLnBuZyIsImltYWdlMTEzLnBuZyIsImltYWdlMTE0LnBuZyIsImltYWdlMTE1LnBuZyIsImltYWdlMTE2LnBuZyIsImltYWdlMTE3LnBuZyIsImltYWdlMTE4LnBuZyIsImltYWdlMTE5LnBuZyIsImltYWdlMTIwLnBuZyIsImltYWdlMTIxLnBuZyIsImltYWdlMTIyLnBuZyIsImltYWdlMTIzLnBuZyIsImltYWdlMTI0LnBuZyIsImltYWdlMTI1LnBuZyIsImltYWdlMTI2LnBuZyIsImltYWdlMTI3LnBuZyIsImltYWdlMTI4LnBuZyIsImltYWdlMTI5LnBuZyIsImltYWdlMTMwLnBuZyIsImltYWdlMTMxLnBuZyIsImltYWdlMTMyLnBuZyIsImltYWdlMTMzLnBuZyIsImltYWdlMTM0LnBuZyIsImltYWdlMTM1LnBuZyIsImltYWdlMTM2LnBuZyIsImltYWdlMTM3LnBuZyIsImltYWdlMTM4LnBuZyIsImltYWdlMTM5LnBuZyIsImltYWdlMTQwLnBuZyIsImltYWdlMTQxLnBuZyIsImltYWdlMTQyLnBuZyIsImltYWdlMTQzLnBuZyIsImltYWdlMTQ0LnBuZyIsImltYWdlMTQ1LnBuZyIsImltYWdlMTQ2LnBuZyIsImltYWdlMTQ3LnBuZyIsImltYWdlMTQ4LnBuZyIsImltYWdlMTQ5LnBuZyIsImltYWdlMTUwLnBuZyIsImltYWdlMTUxLnBuZyIsImltYWdlMTUyLnBuZyIsImltYWdlMTUzLnBuZyIsImltYWdlMTU0LnBuZyIsImltYWdlMTU1LnBuZyIsImltYWdlMTU2LnBuZyIsImltYWdlMTU3LnBuZyIsImltYWdlMTU4LnBuZyIsImltYWdlMTU5LnBuZyIsImltYWdlMTYwLnBuZyIsImltYWdlMTYxLnBuZyIsImltYWdlMTYyLnBuZyIsImltYWdlMTYzLnBuZyIsImltYWdlMTY0LnBuZyIsImltYWdlMTY1LnBuZyIsImltYWdlMTY2LnBuZyIsImltYWdlMTY3LnBuZyIsImltYWdlMTY4LnBuZyIsImltYWdlMTY5LnBuZyIsImltYWdlMTcwLnBuZyIsImltYWdlMTcxLnBuZyIsImltYWdlMTcyLnBuZyIsImltYWdlMTczLnBuZyIsImltYWdlMTc0LnBuZyIsImltYWdlMTc1LnBuZyIsImltYWdlMTc2LnBuZyIsImltYWdlMTc3LnBuZyIsImltYWdlMTc4LnBuZyIsImltYWdlMTc5LnBuZyIsImltYWdlMTgwLnBuZyIsImltYWdlMTgxLnBuZyIsImltYWdlMTgyLnBuZyIsImltYWdlMTgzLnBuZyIsImltYWdlMTg0LnBuZyIsImltYWdlMTg1LnBuZyIsImltYWdlMTg2LnBuZyIsImltYWdlMTg3LnBuZyIsImltYWdlMTg4LnBuZyIsImltYWdlMTg5LnBuZyIsImltYWdlMTkwLnBuZyIsImltYWdlMTkxLnBuZyIsImltYWdlMTkyLnBuZyIsImltYWdlMTkzLnBuZyIsImltYWdlMTk0LnBuZyIsImltYWdlMTk1LnBuZyIsImltYWdlMTk2LnBuZyIsImltYWdlMTk3LnBuZyIsImltYWdlMTk4LnBuZyIsImltYWdlMTk5LnBuZyIsImltYWdlMjAwLnBuZyIsImltYWdlMjAxLnBuZyIsImltYWdlMjAyLnBuZyIsImltYWdlMjAzLnBuZyIsImltYWdlMjA0LnBuZyIsImltYWdlMjA1LnBuZyIsImltYWdlMjA2LnBuZyIsImltYWdlMjA3LnBuZyIsImltYWdlMjA4LnBuZyIsImltYWdlMjA5LnBuZyIsImltYWdlMjEwLnBuZyIsImltYWdlMjExLnBuZyIsImltYWdlMjEyLnBuZyIsImltYWdlMjEzLnBuZyIsImltYWdlMjE0LnBuZyIsImltYWdlMjE1LnBuZyIsImltYWdlMjE2LnBuZyIsImltYWdlMjE3LnBuZyIsImltYWdlMjE4LnBuZyIsImltYWdlMjE5LnBuZyIsImltYWdlMjIwLnBuZyIsImltYWdlMjIxLnBuZyIsImltYWdlMjIyLnBuZyIsImltYWdlMjIzLnBuZyIsImltYWdlMjI0LnBuZyIsImltYWdlMjI1LnBuZyIsImltYWdlMjI2LnBuZyIsImltYWdlMjI3LnBuZyIsImltYWdlMjI4LnBuZyIsImltYWdlMjI5LnBuZyIsImltYWdlMjMwLnBuZyIsImltYWdlMjMxLnBuZyIsImltYWdlMjMyLnBuZyIsImltYWdlMjMzLnBuZyIsImltYWdlMjM0LnBuZyIsImltYWdlMjM1LnBuZyIsImltYWdlMjM2LnBuZyIsImltYWdlMjM3LnBuZyIsImltYWdlMjM4LnBuZyIsImltYWdlMjM5LnBuZyIsImltYWdlMjQwLnBuZyIsImltYWdlMjQxLnBuZyIsImltYWdlMjQyLnBuZyIsImltYWdlMjQzLnBuZyIsImltYWdlMjQ0LnBuZyIsImltYWdlMjQ1LnBuZyIsImltYWdlMjQ2LnBuZyIsImltYWdlMjQ3LnBuZyIsImltYWdlMjQ4LnBuZyIsImltYWdlMjQ5LnBuZyIsImltYWdlMjUwLnBuZyIsImltYWdlMjUxLnBuZyIsImltYWdlMjUyLnBuZyIsImltYWdlMjUzLnBuZyIsImltYWdlMjU0LnBuZyIsImltYWdlMjU1LnBuZyIsImltYWdlMjU2LnBuZyIsImltYWdlMjU3LnBuZyIsImltYWdlMjU4LnBuZyIsImltYWdlMjU5LnBuZyIsImltYWdlMjYwLnBuZyIsImltYWdlMjYxLnBuZyIsImltYWdlMjYyLnBuZyIsImltYWdlMjYzLnBuZyIsImltYWdlMjY0LnBuZyIsImltYWdlMjY1LnBuZyIsImltYWdlMjY2LnBuZyIsImltYWdlMjY3LnBuZyIsImltYWdlMjY4LnBuZyIsImltYWdlMjY5LnBuZyIsImltYWdlMjcwLnBuZyIsImltYWdlMjcxLnBuZyIsImltYWdlMjcyLnBuZyIsImltYWdlMjczLnBuZyIsImltYWdlMjc0LnBuZyIsImltYWdlMjc1LnBuZyIsImltYWdlMjc2LnBuZyIsImltYWdlMjc3LnBuZyIsImltYWdlMjc4LnBuZyIsImltYWdlMjc5LnBuZyIsImltYWdlMjgwLnBuZyIsImltYWdlMjgxLnBuZyIsImltYWdlMjgyLnBuZyIsImltYWdlMjgzLnBuZyIsImltYWdlMjg0LnBuZyIsImltYWdlMjg1LnBuZyIsImltYWdlMjg2LnBuZyIsImltYWdlMjg3LnBuZyIsImltYWdlMjg4LnBuZyIsImltYWdlMjg5LnBuZyIsImltYWdlMjkwLnBuZyIsImltYWdlMjkxLnBuZyIsImltYWdlMjkyLnBuZyIsImltYWdlMjkzLnBuZyIsImltYWdlMjk0LnBuZyIsImltYWdlMjk1LnBuZyIsImltYWdlMjk2LnBuZyIsImltYWdlMjk3LnBuZyIsImltYWdlMjk4LnBuZyIsImltYWdlMjk5LnBuZyIsImltYWdlMzAwLnBuZyIsImltYWdlMzAxLnBuZyIsImltYWdlMzAyLnBuZyIsImltYWdlMzAzLnBuZyIsImltYWdlMzA0LnBuZyIsImltYWdlMzA1LnBuZyIsImltYWdlMzA2LnBuZyIsImltYWdlMzA3LnBuZyIsImltYWdlMzA4LnBuZyIsImltYWdlMzA5LnBuZyIsImltYWdlMzEwLnBuZyIsImltYWdlMzExLnBuZyIsImltYWdlMzEyLnBuZyIsImltYWdlMzEzLnBuZyIsImltYWdlMzE0LnBuZyIsImltYWdlMzE1LnBuZyIsImltYWdlMzE2LnBuZyIsImltYWdlMzE3LnBuZyIsImltYWdlMzE4LnBuZyIsImltYWdlMzE5LnBuZyIsImltYWdlMzIwLnBuZyIsImltYWdlMzIxLnBuZyIsImltYWdlMzIyLnBuZyIsImltYWdlMzIzLnBuZyIsImltYWdlMzI0LnBuZyIsImltYWdlMzI1LnBuZyIsImltYWdlMzI2LnBuZyIsImltYWdlMzI3LnBuZyIsImltYWdlMzI4LnBuZyIsImltYWdlMzI5LnBuZyIsImltYWdlMzMwLnBuZyIsImltYWdlMzMxLnBuZyIsImltYWdlMzMyLnBuZyIsImltYWdlMzMzLnBuZyIsImltYWdlMzM0LnBuZyIsImltYWdlMzM1LnBuZyIsImltYWdlMzM2LnBuZyIsImltYWdlMzM3LnBuZyIsImltYWdlMzM4LnBuZyIsImltYWdlMzM5LnBuZyIsImltYWdlMzQwLnBuZyIsImltYWdlMzQxLnBuZyIsImltYWdlMzQyLnBuZyIsImltYWdlMzQzLnBuZyIsImltYWdlMzQ0LnBuZyIsImltYWdlMzQ1LnBuZyIsImltYWdlMzQ2LnBuZyIsImltYWdlMzQ3LnBuZyIsImltYWdlMzQ4LnBuZyIsImltYWdlMzQ5LnBuZyIsImltYWdlMzUwLnBuZyIsImltYWdlMzUxLnBuZyIsImltYWdlMzUyLnBuZyIsImltYWdlMzUzLnBuZyIsImltYWdlMzU0LnBuZyIsImltYWdlMzU1LnBuZyIsImltYWdlMzU2LnBuZyIsImltYWdlMzU3LnBuZyIsImltYWdlMzU4LnBuZyIsImltYWdlMzU5LnBuZyIsImltYWdlMzYwLnBuZyIsImltYWdlMzYxLnBuZyIsImltYWdlMzYyLnBuZyIsImltYWdlMzYzLnBuZyIsImltYWdlMzY0LnBuZyIsImltYWdlMzY1LnBuZyIsImltYWdlMzY2LnBuZyIsImltYWdlMzY3LnBuZyIsImltYWdlMzY4LnBuZyIsImltYWdlMzY5LnBuZyIsImltYWdlMzcwLnBuZyIsImltYWdlMzcxLnBuZyIsImltYWdlMzcyLnBuZyIsImltYWdlMzczLnBuZyIsImltYWdlMzc0LnBuZyIsImltYWdlMzc1LnBuZyIsImltYWdlMzc2LnBuZyIsImltYWdlMzc3LnBuZyIsImltYWdlMzc4LnBuZyIsImltYWdlMzc5LnBuZyIsImltYWdlMzgwLnBuZyIsImltYWdlMzgxLnBuZyIsImltYWdlMzgyLnBuZyIsImltYWdlMzgzLnBuZyIsImltYWdlMzg0LnBuZyIsImltYWdlMzg1LnBuZyIsImltYWdlMzg2LnBuZyIsImltYWdlMzg3LnBuZyIsImltYWdlMzg4LnBuZyIsImltYWdlMzg5LnBuZyIsImltYWdlMzkwLnBuZyIsImltYWdlMzkxLnBuZyIsImltYWdlMzkyLnBuZyIsImltYWdlMzkzLnBuZyIsImltYWdlMzk0LnBuZyIsImltYWdlMzk1LnBuZyIsImltYWdlMzk2LnBuZyIsImltYWdlMzk3LnBuZyIsImltYWdlMzk4LnBuZyIsImltYWdlMzk5LnBuZyIsImltYWdlNDAwLnBuZyIsImltYWdlNDAxLnBuZyIsImltYWdlNDAyLnBuZyIsImltYWdlNDAzLnBuZyIsImltYWdlNDA0LnBuZyIsImltYWdlNDA1LnBuZyIsImltYWdlNDA2LnBuZyIsImltYWdlNDA3LnBuZyIsImltYWdlNDA4LnBuZyIsImltYWdlNDA5LnBuZyIsImltYWdlNDEwLnBuZyIsImltYWdlNDExLnBuZyIsImltYWdlNDEyLnBuZyIsImltYWdlNDEzLnBuZyIsImltYWdlNDE0LnBuZyIsImltYWdlNDE1LnBuZyIsImltYWdlNDE2LnBuZyIsImltYWdlNDE3LnBuZyIsImltYWdlNDE4LnBuZyIsImltYWdlNDE5LnBuZyIsImltYWdlNDIwLnBuZyIsImltYWdlNDIxLnBuZyIsImltYWdlNDIyLnBuZyIsImltYWdlNDIzLnBuZyIsImltYWdlNDI0LnBuZyIsImltYWdlNDI1LnBuZyIsImltYWdlNDI2LnBuZyIsImltYWdlNDI3LnBuZyIsImltYWdlNDI4LnBuZyIsImltYWdlNDI5LnBuZyIsImltYWdlNDMwLnBuZyIsImltYWdlNDMxLnBuZyIsImltYWdlNDMyLnBuZyIsImltYWdlNDMzLnBuZyIsImltYWdlNDM0LnBuZyIsImltYWdlNDM1LnBuZyIsImltYWdlNDM2LnBuZyIsImltYWdlNDM3LnBuZyIsImltYWdlNDM4LnBuZyIsImltYWdlNDM5LnBuZyIsImltYWdlNDQwLnBuZyIsImltYWdlNDQxLnBuZyIsImltYWdlNDQyLnBuZyIsImltYWdlNDQzLnBuZyIsImltYWdlNDQ0LnBuZyIsImltYWdlNDQ1LnBuZyIsImltYWdlNDQ2LnBuZyIsImltYWdlNDQ3LnBuZyIsImltYWdlNDQ4LnBuZyIsImltYWdlNDQ5LnBuZyIsImltYWdlNDUwLnBuZyIsImltYWdlNDUxLnBuZyIsImltYWdlNDUyLnBuZyIsImltYWdlNDUzLnBuZyIsImltYWdlNDU0LnBuZyIsImltYWdlNDU1LnBuZyIsImltYWdlNDU2LnBuZyIsImltYWdlNDU3LnBuZyIsImltYWdlNDU4LnBuZyIsImltYWdlNDU5LnBuZyIsImltYWdlNDYwLnBuZyIsImltYWdlNDYxLnBuZyIsImltYWdlNDYyLnBuZyIsImltYWdlNDYzLnBuZyIsImltYWdlNDY0LnBuZyIsImltYWdlNDY1LnBuZyIsImltYWdlNDY2LnBuZyIsImltYWdlNDY3LnBuZyIsImltYWdlNDY4LnBuZyIsImltYWdlNDY5LnBuZyIsImltYWdlNDcwLnBuZyIsImltYWdlNDcxLnBuZyIsImltYWdlNDcyLnBuZyIsImltYWdlNDczLnBuZyIsImltYWdlNDc0LnBuZyIsImltYWdlNDc1LnBuZyIsImltYWdlNDc2LnBuZyIsImltYWdlNDc3LnBuZyIsImltYWdlNDc4LnBuZyIsImltYWdlNDc5LnBuZyIsImltYWdlNDgwLnBuZyIsImltYWdlNDgxLnBuZyIsImltYWdlNDgyLnBuZyIsImltYWdlNDgzLnBuZyIsImltYWdlNDg0LnBuZyIsImltYWdlNDg1LnBuZyIsImltYWdlNDg2LnBuZyIsImltYWdlNDg3LnBuZyIsImltYWdlNDg4LnBuZyIsImltYWdlNDg5LnBuZyIsImltYWdlNDkwLnBuZyIsImltYWdlNDkxLnBuZyIsImltYWdlNDkyLnBuZyIsImltYWdlNDkzLnBuZyIsImltYWdlNDk0LnBuZyIsImltYWdlNDk1LnBuZyIsImltYWdlNDk2LnBuZyIsImltYWdlNDk3LnBuZyIsImltYWdlNDk4LnBuZyIsImltYWdlNDk5LnBuZyIsImltYWdlNTAwLnBuZyIsImltYWdlNTAxLnBuZyIsImltYWdlNTAyLnBuZyIsImltYWdlNTAzLnBuZyIsImltYWdlNTA0LnBuZyIsImltYWdlNTA1LnBuZyIsImltYWdlNTA2LnBuZyIsImltYWdlNTA3LnBuZyIsImltYWdlNTA4LnBuZyIsImltYWdlNTA5LnBuZyIsImltYWdlNTEwLnBuZyIsImltYWdlNTExLnBuZyIsImltYWdlNTEyLnBuZyIsImltYWdlNTEzLnBuZyIsImltYWdlNTE0LnBuZyIsImltYWdlNTE1LnBuZyIsImltYWdlNTE2LnBuZyIsImltYWdlNTE3LnBuZyIsImltYWdlNTE4LnBuZyIsImltYWdlNTE5LnBuZyIsImltYWdlNTIwLnBuZyIsImltYWdlNTIxLnBuZyIsImltYWdlNTIyLnBuZyIsImltYWdlNTIzLnBuZyIsImltYWdlNTI0LnBuZyIsImltYWdlNTI1LnBuZyIsImltYWdlNTI2LnBuZyIsImltYWdlNTI3LnBuZyIsImltYWdlNTI4LnBuZyIsImltYWdlNTI5LnBuZyIsImltYWdlNTMwLnBuZyIsImltYWdlNTMxLnBuZyIsImltYWdlNTMyLnBuZyIsImltYWdlNTMzLnBuZyIsImltYWdlNTM0LnBuZyIsImltYWdlNTM1LnBuZyIsImltYWdlNTM2LnBuZyIsImltYWdlNTM3LnBuZyIsImltYWdlNTM4LnBuZyIsImltYWdlNTM5LnBuZyIsImltYWdlNTQwLnBuZyIsImltYWdlNTQxLnBuZyIsImltYWdlNTQyLnBuZyIsImltYWdlNTQzLnBuZyIsImltYWdlNTQ0LnBuZyIsImltYWdlNTQ1LnBuZyIsImltYWdlNTQ2LnBuZyIsImltYWdlNTQ3LnBuZyIsImltYWdlNTQ4LnBuZyIsImltYWdlNTQ5LnBuZyIsImltYWdlNTUwLnBuZyIsImltYWdlNTUxLnBuZyIsImltYWdlNTUyLnBuZyIsImltYWdlNTUzLnBuZyIsImltYWdlNTU0LnBuZyIsImltYWdlNTU1LnBuZyIsImltYWdlNTU2LnBuZyIsImltYWdlNTU3LnBuZyIsImltYWdlNTU4LnBuZyIsImltYWdlNTU5LnBuZyIsImltYWdlNTYwLnBuZyIsImltYWdlNTYxLnBuZyIsImltYWdlNTYyLnBuZyIsImltYWdlNTYzLnBuZyIsImltYWdlNTY0LnBuZyIsImltYWdlNTY1LnBuZyIsImltYWdlNTY2LnBuZyIsImltYWdlNTY3LnBuZyIsImltYWdlNTY4LnBuZyIsImltYWdlNTY5LnBuZyIsImltYWdlNTcwLnBuZyIsImltYWdlNTcxLnBuZyIsImltYWdlNTcyLnBuZyIsImltYWdlNTczLnBuZyIsImltYWdlNTc0LnBuZyIsImltYWdlNTc1LnBuZyIsImltYWdlNTc2LnBuZyIsImltYWdlNTc3LnBuZyIsImltYWdlNTc4LnBuZyIsImltYWdlNTc5LnBuZyIsImltYWdlNTgwLnBuZyIsImltYWdlNTgxLnBuZyIsImltYWdlNTgyLnBuZyIsImltYWdlNTgzLnBuZyIsImltYWdlNTg0LnBuZyIsImltYWdlNTg1LnBuZyIsImltYWdlNTg2LnBuZyIsImltYWdlNTg3LnBuZyIsImltYWdlNTg4LnBuZyIsImltYWdlNTg5LnBuZyIsImltYWdlNTkwLnBuZyIsImltYWdlNTkxLnBuZyIsImltYWdlNTkyLnBuZyIsImltYWdlNTkzLnBuZyIsImltYWdlNTk0LnBuZyIsImltYWdlNTk1LnBuZyIsImltYWdlNTk2LnBuZyIsImltYWdlNTk3LnBuZyIsImltYWdlNTk4LnBuZyIsImltYWdlNTk5LnBuZyIsImltYWdlNjAwLnBuZyIsImltYWdlNjAxLnBuZyIsImltYWdlNjAyLnBuZyIsImltYWdlNjAzLnBuZyIsImltYWdlNjA0LnBuZyIsImltYWdlNjA1LnBuZyIsImltYWdlNjA2LnBuZyIsImltYWdlNjA3LnBuZyIsImltYWdlNjA4LnBuZyIsImltYWdlNjA5LnBuZyIsImltYWdlNjEwLnBuZyIsImltYWdlNjExLnBuZyIsImltYWdlNjEyLnBuZyIsImltYWdlNjEzLnBuZyIsImltYWdlNjE0LnBuZyIsImltYWdlNjE1LnBuZyIsImltYWdlNjE2LnBuZyIsImltYWdlNjE3LnBuZyIsImltYWdlNjE4LnBuZyIsImltYWdlNjE5LnBuZyIsImltYWdlNjIwLnBuZyIsImltYWdlNjIxLnBuZyIsImltYWdlNjIyLnBuZyIsImltYWdlNjIzLnBuZyIsImltYWdlNjI0LnBuZyIsImltYWdlNjI1LnBuZyIsImltYWdlNjI2LnBuZyIsImltYWdlNjI3LnBuZyIsImltYWdlNjI4LnBuZyIsImltYWdlNjI5LnBuZyIsImltYWdlNjMwLnBuZyIsImltYWdlNjMxLnBuZyIsImltYWdlNjMyLnBuZyIsImltYWdlNjMzLnBuZyIsImltYWdlNjM0LnBuZyIsImltYWdlNjM1LnBuZyIsImltYWdlNjM2LnBuZyIsImltYWdlNjM3LnBuZyIsImltYWdlNjM4LnBuZyIsImltYWdlNjM5LnBuZyIsImltYWdlNjQwLnBuZyIsImltYWdlNjQxLnBuZyIsImltYWdlNjQyLnBuZyIsImltYWdlNjQzLnBuZyIsImltYWdlNjQ0LnBuZyIsImltYWdlNjQ1LnBuZyIsImltYWdlNjQ2LnBuZyIsImltYWdlNjQ3LnBuZyIsImltYWdlNjQ4LnBuZyIsImltYWdlNjQ5LnBuZyIsImltYWdlNjUwLnBuZyIsImltYWdlNjUxLnBuZyIsImltYWdlNjUyLnBuZyIsImltYWdlNjUzLnBuZyIsImltYWdlNjU0LnBuZyIsImltYWdlNjU1LnBuZyIsImltYWdlNjU2LnBuZyIsImltYWdlNjU3LnBuZyIsImltYWdlNjU4LnBuZyIsImltYWdlNjU5LnBuZyIsImltYWdlNjYwLnBuZyIsImltYWdlNjYxLnBuZyIsImltYWdlNjYyLnBuZyIsImltYWdlNjYzLnBuZyIsImltYWdlNjY0LnBuZyIsImltYWdlNjY1LnBuZyIsImltYWdlNjY2LnBuZyIsImltYWdlNjY3LnBuZyIsImltYWdlNjY4LnBuZyIsImltYWdlNjY5LnBuZyIsImltYWdlNjcwLnBuZyIsImltYWdlNjcxLnBuZyIsImltYWdlNjcyLnBuZyIsImltYWdlNjczLnBuZyIsImltYWdlNjc0LnBuZyIsImltYWdlNjc1LnBuZyIsImltYWdlNjc2LnBuZyIsImltYWdlNjc3LnBuZyIsImltYWdlNjc4LnBuZyIsImltYWdlNjc5LnBuZyIsImltYWdlNjgwLnBuZyIsImltYWdlNjgxLnBuZyIsImltYWdlNjgyLnBuZyIsImltYWdlNjgzLnBuZyIsImltYWdlNjg0LnBuZyIsImltYWdlNjg1LnBuZyIsImltYWdlNjg2LnBuZyIsImltYWdlNjg3LnBuZyIsImltYWdlNjg4LnBuZyIsImltYWdlNjg5LnBuZyIsImltYWdlNjkwLnBuZyIsImltYWdlNjkxLnBuZyIsImltYWdlNjkyLnBuZyIsImltYWdlNjkzLnBuZyIsImltYWdlNjk0LnBuZyIsImltYWdlNjk1LnBuZyIsImltYWdlNjk2LnBuZyIsImltYWdlNjk3LnBuZyIsImltYWdlNjk4LnBuZyIsImltYWdlNjk5LnBuZyIsImltYWdlNzAwLnBuZyIsImltYWdlNzAxLnBuZyIsImltYWdlNzAyLnBuZyIsImltYWdlNzAzLnBuZyIsImltYWdlNzA0LnBuZyIsImltYWdlNzA1LnBuZyIsImltYWdlNzA2LnBuZyIsImltYWdlNzA3LnBuZyIsImltYWdlNzA4LnBuZyIsImltYWdlNzA5LnBuZyIsImltYWdlNzEwLnBuZyIsImltYWdlNzExLnBuZyIsImltYWdlNzEyLnBuZyIsImltYWdlNzEzLnBuZyIsImltYWdlNzE0LnBuZyIsImltYWdlNzE1LnBuZyIsImltYWdlNzE2LnBuZyIsImltYWdlNzE3LnBuZyIsImltYWdlNzE4LnBuZyIsImltYWdlNzE5LnBuZyIsImltYWdlNzIwLnBuZyIsImltYWdlNzIxLnBuZyIsImltYWdlNzIyLnBuZyIsImltYWdlNzIzLnBuZyIsImltYWdlNzI0LnBuZyIsImltYWdlNzI1LnBuZyIsImltYWdlNzI2LnBuZyIsImltYWdlNzI3LnBuZyIsImltYWdlNzI4LnBuZyIsImltYWdlNzI5LnBuZyIsImltYWdlNzMwLnBuZyIsImltYWdlNzMxLnBuZyIsImltYWdlNzMyLnBuZyIsImltYWdlNzMzLnBuZyIsImltYWdlNzM0LnBuZyIsImltYWdlNzM1LnBuZyIsImltYWdlNzM2LnBuZyIsImltYWdlNzM3LnBuZyIsImltYWdlNzM4LnBuZyIsImltYWdlNzM5LnBuZyIsImltYWdlNzQwLnBuZyIsImltYWdlNzQxLnBuZyIsImltYWdlNzQyLnBuZyIsImltYWdlNzQzLnBuZyIsImltYWdlNzQ0LnBuZyIsImltYWdlNzQ1LnBuZyIsImltYWdlNzQ2LnBuZyIsImltYWdlNzQ3LnBuZyIsImltYWdlNzQ4LnBuZyIsImltYWdlNzQ5LnBuZyIsImltYWdlNzUwLnBuZyIsImltYWdlNzUxLnBuZyIsImltYWdlNzUyLnBuZyIsImltYWdlNzUzLnBuZyIsImltYWdlNzU0LnBuZyIsImltYWdlNzU1LnBuZyIsImltYWdlNzU2LnBuZyIsImltYWdlNzU3LnBuZyIsImltYWdlNzU4LnBuZyIsImltYWdlNzU5LnBuZyIsImltYWdlNzYwLnBuZyIsImltYWdlNzYxLnBuZyIsImltYWdlNzYyLnBuZyIsImltYWdlNzYzLnBuZyIsImltYWdlNzY0LnBuZyIsImltYWdlNzY1LnBuZyIsImltYWdlNzY2LnBuZyIsImltYWdlNzY3LnBuZyIsImltYWdlNzY4LnBuZyIsImltYWdlNzY5LnBuZyIsImltYWdlNzcwLnBuZyIsImltYWdlNzcxLnBuZyIsImltYWdlNzcyLnBuZyIsImltYWdlNzczLnBuZyIsImltYWdlNzc0LnBuZyIsImltYWdlNzc1LnBuZyIsImltYWdlNzc2LnBuZyIsImltYWdlNzc3LnBuZyIsImltYWdlNzc4LnBuZyIsImltYWdlNzc5LnBuZyIsImltYWdlNzgwLnBuZyIsImltYWdlNzgxLnBuZyIsImltYWdlNzgyLnBuZyIsImltYWdlNzgzLnBuZyIsImltYWdlNzg0LnBuZyIsImltYWdlNzg1LnBuZyIsImltYWdlNzg2LnBuZyIsImltYWdlNzg3LnBuZyIsImltYWdlNzg4LnBuZyIsImltYWdlNzg5LnBuZyIsImltYWdlNzkwLnBuZyIsImltYWdlNzkxLnBuZyIsImltYWdlNzkyLnBuZyIsImltYWdlNzkzLnBuZyIsImltYWdlNzk0LnBuZyIsImltYWdlNzk1LnBuZyIsImltYWdlNzk2LnBuZyIsImltYWdlNzk3LnBuZyIsImltYWdlNzk4LnBuZyIsImltYWdlNzk5LnBuZyIsImltYWdlODAwLnBuZyIsImltYWdlODAxLnBuZyIsImltYWdlODAyLnBuZyIsImltYWdlODAzLnBuZyIsImltYWdlODA0LnBuZyIsImltYWdlODA1LnBuZyIsImltYWdlODA2LnBuZyIsImltYWdlODA3LnBuZyIsImltYWdlODA4LnBuZyIsImltYWdlODA5LnBuZyIsImltYWdlODEwLnBuZyIsImltYWdlODExLnBuZyIsImltYWdlODEyLnBuZyIsImltYWdlODEzLnBuZyIsImltYWdlODE0LnBuZyIsImltYWdlODE1LnBuZyIsImltYWdlODE2LnBuZyIsImltYWdlODE3LnBuZyIsImltYWdlODE4LnBuZyIsImltYWdlODE5LnBuZyIsImltYWdlODIwLnBuZyIsImltYWdlODIxLnBuZyIsImltYWdlODIyLnBuZyIsImltYWdlODIzLnBuZyIsImltYWdlODI0LnBuZyIsImltYWdlODI1LnBuZyIsImltYWdlODI2LnBuZyIsImltYWdlODI3LnBuZyIsImltYWdlODI4LnBuZyIsImltYWdlODI5LnBuZyIsImltYWdlODMwLnBuZyIsImltYWdlODMxLnBuZyIsImltYWdlODMyLnBuZyIsImltYWdlODMzLnBuZyIsImltYWdlODM0LnBuZyIsImltYWdlODM1LnBuZyIsImltYWdlODM2LnBuZyIsImltYWdlODM3LnBuZyIsImltYWdlODM4LnBuZyIsImltYWdlODM5LnBuZyIsImltYWdlODQwLnBuZyIsImltYWdlODQxLnBuZyIsImltYWdlODQyLnBuZyIsImltYWdlODQzLnBuZyIsImltYWdlODQ0LnBuZyIsImltYWdlODQ1LnBuZyIsImltYWdlODQ2LnBuZyIsImltYWdlODQ3LnBuZyIsImltYWdlODQ4LnBuZyIsImltYWdlODQ5LnBuZyIsImltYWdlODUwLnBuZyIsImltYWdlODUxLnBuZyIsImltYWdlODUyLnBuZyIsImltYWdlODUzLnBuZyIsImltYWdlODU0LnBuZyIsImltYWdlODU1LnBuZyIsImltYWdlODU2LnBuZyIsImltYWdlODU3LnBuZyIsImltYWdlODU4LnBuZyIsImltYWdlODU5LnBuZyIsImltYWdlODYwLnBuZyIsImltYWdlODYxLnBuZyIsImltYWdlODYyLnBuZyIsImltYWdlODYzLnBuZyIsImltYWdlODY0LnBuZyIsImltYWdlODY1LnBuZyIsImltYWdlODY2LnBuZyIsImltYWdlODY3LnBuZyIsImltYWdlODY4LnBuZyIsImltYWdlODY5LnBuZyIsImltYWdlODcwLnBuZyIsImltYWdlODcxLnBuZyIsImltYWdlODcyLnBuZyIsImltYWdlODczLnBuZyIsImltYWdlODc0LnBuZyIsImltYWdlODc1LnBuZyIsImltYWdlODc2LnBuZyIsImltYWdlODc3LnBuZyIsImltYWdlODc4LnBuZyIsImltYWdlODc5LnBuZyIsImltYWdlODgwLnBuZyIsImltYWdlODgxLnBuZyIsImltYWdlODgyLnBuZyIsImltYWdlODgzLnBuZyIsImltYWdlODg0LnBuZyIsImltYWdlODg1LnBuZyIsImltYWdlODg2LnBuZyIsImltYWdlODg3LnBuZyIsImltYWdlODg4LnBuZyIsImltYWdlODg5LnBuZyIsImltYWdlODkwLnBuZyIsImltYWdlODkxLnBuZyIsImltYWdlODkyLnBuZyIsImltYWdlODkzLnBuZyIsImltYWdlODk0LnBuZyIsImltYWdlODk1LnBuZyIsImltYWdlODk2LnBuZyIsImltYWdlODk3LnBuZyIsImltYWdlODk4LnBuZyIsImltYWdlODk5LnBuZyIsImltYWdlOTAwLnBuZyIsImltYWdlOTAxLnBuZyIsImltYWdlOTAyLnBuZyIsImltYWdlOTAzLnBuZyIsImltYWdlOTA0LnBuZyIsImltYWdlOTA1LnBuZyIsImltYWdlOTA2LnBuZyIsImltYWdlOTA3LnBuZyIsImltYWdlOTA4LnBuZyIsImltYWdlOTA5LnBuZyIsImltYWdlOTEwLnBuZyIsImltYWdlOTExLnBuZyIsImltYWdlOTEyLnBuZyIsImltYWdlOTEzLnBuZyIsImltYWdlOTE0LnBuZyIsImltYWdlOTE1LnBuZyIsImltYWdlOTE2LnBuZyIsImltYWdlOTE3LnBuZyIsImltYWdlOTE4LnBuZyIsImltYWdlOTE5LnBuZyIsImltYWdlOTIwLnBuZyIsImltYWdlOTIxLnBuZyIsImltYWdlOTIyLnBuZyIsImltYWdlOTIzLnBuZyIsImltYWdlOTI0LnBuZyIsImltYWdlOTI1LnBuZyIsImltYWdlOTI2LnBuZyIsImltYWdlOTI3LnBuZyIsImltYWdlOTI4LnBuZyIsImltYWdlOTI5LnBuZyIsImltYWdlOTMwLnBuZyIsImltYWdlOTMxLnBuZyIsImltYWdlOTMyLnBuZyIsImltYWdlOTMzLnBuZyIsImltYWdlOTM0LnBuZyIsImltYWdlOTM1LnBuZyIsImltYWdlOTM2LnBuZyIsImltYWdlOTM3LnBuZyIsImltYWdlOTM4LnBuZyIsImltYWdlOTM5LnBuZyIsImltYWdlOTQwLnBuZyIsImltYWdlOTQxLnBuZyIsImltYWdlOTQyLnBuZyIsImltYWdlOTQzLnBuZyIsImltYWdlOTQ0LnBuZyIsImltYWdlOTQ1LnBuZyIsImltYWdlOTQ2LnBuZyIsImltYWdlOTQ3LnBuZyIsImltYWdlOTQ4LnBuZyIsImltYWdlOTQ5LnBuZyIsImltYWdlOTUwLnBuZyIsImltYWdlOTUxLnBuZyIsImltYWdlOTUyLnBuZyIsImltYWdlOTUzLnBuZyIsImltYWdlOTU0LnBuZyIsImltYWdlOTU1LnBuZyIsImltYWdlOTU2LnBuZyIsImltYWdlOTU3LnBuZyIsImltYWdlOTU4LnBuZyIsImltYWdlOTU5LnBuZyIsImltYWdlOTYwLnBuZyIsImltYWdlOTYxLnBuZyIsImltYWdlOTYyLnBuZyIsImltYWdlOTYzLnBuZyIsImltYWdlOTY0LnBuZyIsImltYWdlOTY1LnBuZyIsImltYWdlOTY2LnBuZyIsImltYWdlOTY3LnBuZyIsImltYWdlOTY4LnBuZyIsImltYWdlOTY5LnBuZyIsImltYWdlOTcwLnBuZyIsImltYWdlOTcxLnBuZyIsImltYWdlOTcyLnBuZyIsImltYWdlOTczLnBuZyIsImltYWdlOTc0LnBuZyIsImltYWdlOTc1LnBuZyIsImltYWdlOTc2LnBuZyIsImltYWdlOTc3LnBuZyIsImltYWdlOTc4LnBuZyIsImltYWdlOTc5LnBuZyIsImltYWdlOTgwLnBuZyIsImltYWdlOTgxLnBuZyIsImltYWdlOTgyLnBuZyIsImltYWdlOTgzLnBuZyIsImltYWdlOTg0LnBuZyIsImltYWdlOTg1LnBuZyIsImltYWdlOTg2LnBuZyIsImltYWdlOTg3LnBuZyIsImltYWdlOTg4LnBuZyIsImltYWdlOTg5LnBuZyIsImltYWdlOTkwLnBuZyIsImltYWdlOTkxLnBuZyIsImltYWdlOTkyLnBuZyIsImltYWdlOTkzLnBuZyIsImltYWdlOTk0LnBuZyIsImltYWdlOTk1LnBuZyIsImltYWdlOTk2LnBuZyIsImltYWdlOTk3LnBuZyIsImltYWdlOTk4LnBuZyIsImltYWdlOTk5LnBuZyJdLCJpYXQiOjE1MTYyMzkwMjJ9.KGrocKdxHn_ZCkgfl5SAbKxCm8tbqVOBslU_x3SrYAg" href="https://jwt.io/#debugger-io?token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwicm9sZXMiOlsiYWRtaW4iXSwicmVsYXRlZF9pbWFnZXMiOlsiaW1hZ2UwLnBuZyIsImltYWdlMS5wbmciLCJpbWFnZTIucG5nIiwiaW1hZ2UzLnBuZyIsImltYWdlNC5wbmciLCJpbWFnZTUucG5nIiwiaW1hZ2U2LnBuZyIsImltYWdlNy5wbmciLCJpbWFnZTgucG5nIiwiaW1hZ2U5LnBuZyIsImltYWdlMTAucG5nIiwiaW1hZ2UxMS5wbmciLCJpbWFnZTEyLnBuZyIsImltYWdlMTMucG5nIiwiaW1hZ2UxNC5wbmciLCJpbWFnZTE1LnBuZyIsImltYWdlMTYucG5nIiwiaW1hZ2UxNy5wbmciLCJpbWFnZTE4LnBuZyIsImltYWdlMTkucG5nIiwiaW1hZ2UyMC5wbmciLCJpbWFnZTIxLnBuZyIsImltYWdlMjIucG5nIiwiaW1hZ2UyMy5wbmciLCJpbWFnZTI0LnBuZyIsImltYWdlMjUucG5nIiwiaW1hZ2UyNi5wbmciLCJpbWFnZTI3LnBuZyIsImltYWdlMjgucG5nIiwiaW1hZ2UyOS5wbmciLCJpbWFnZTMwLnBuZyIsImltYWdlMzEucG5nIiwiaW1hZ2UzMi5wbmciLCJpbWFnZTMzLnBuZyIsImltYWdlMzQucG5nIiwiaW1hZ2UzNS5wbmciLCJpbWFnZTM2LnBuZyIsImltYWdlMzcucG5nIiwiaW1hZ2UzOC5wbmciLCJpbWFnZTM5LnBuZyIsImltYWdlNDAucG5nIiwiaW1hZ2U0MS5wbmciLCJpbWFnZTQyLnBuZyIsImltYWdlNDMucG5nIiwiaW1hZ2U0NC5wbmciLCJpbWFnZTQ1LnBuZyIsImltYWdlNDYucG5nIiwiaW1hZ2U0Ny5wbmciLCJpbWFnZTQ4LnBuZyIsImltYWdlNDkucG5nIiwiaW1hZ2U1MC5wbmciLCJpbWFnZTUxLnBuZyIsImltYWdlNTIucG5nIiwiaW1hZ2U1My5wbmciLCJpbWFnZTU0LnBuZyIsImltYWdlNTUucG5nIiwiaW1hZ2U1Ni5wbmciLCJpbWFnZTU3LnBuZyIsImltYWdlNTgucG5nIiwiaW1hZ2U1OS5wbmciLCJpbWFnZTYwLnBuZyIsImltYWdlNjEucG5nIiwiaW1hZ2U2Mi5wbmciLCJpbWFnZTYzLnBuZyIsImltYWdlNjQucG5nIiwiaW1hZ2U2NS5wbmciLCJpbWFnZTY2LnBuZyIsImltYWdlNjcucG5nIiwiaW1hZ2U2OC5wbmciLCJpbWFnZTY5LnBuZyIsImltYWdlNzAucG5nIiwiaW1hZ2U3MS5wbmciLCJpbWFnZTcyLnBuZyIsImltYWdlNzMucG5nIiwiaW1hZ2U3NC5wbmciLCJpbWFnZTc1LnBuZyIsImltYWdlNzYucG5nIiwiaW1hZ2U3Ny5wbmciLCJpbWFnZTc4LnBuZyIsImltYWdlNzkucG5nIiwiaW1hZ2U4MC5wbmciLCJpbWFnZTgxLnBuZyIsImltYWdlODIucG5nIiwiaW1hZ2U4My5wbmciLCJpbWFnZTg0LnBuZyIsImltYWdlODUucG5nIiwiaW1hZ2U4Ni5wbmciLCJpbWFnZTg3LnBuZyIsImltYWdlODgucG5nIiwiaW1hZ2U4OS5wbmciLCJpbWFnZTkwLnBuZyIsImltYWdlOTEucG5nIiwiaW1hZ2U5Mi5wbmciLCJpbWFnZTkzLnBuZyIsImltYWdlOTQucG5nIiwiaW1hZ2U5NS5wbmciLCJpbWFnZTk2LnBuZyIsImltYWdlOTcucG5nIiwiaW1hZ2U5OC5wbmciLCJpbWFnZTk5LnBuZyIsImltYWdlMTAwLnBuZyIsImltYWdlMTAxLnBuZyIsImltYWdlMTAyLnBuZyIsImltYWdlMTAzLnBuZyIsImltYWdlMTA0LnBuZyIsImltYWdlMTA1LnBuZyIsImltYWdlMTA2LnBuZyIsImltYWdlMTA3LnBuZyIsImltYWdlMTA4LnBuZyIsImltYWdlMTA5LnBuZyIsImltYWdlMTEwLnBuZyIsImltYWdlMTExLnBuZyIsImltYWdlMTEyLnBuZyIsImltYWdlMTEzLnBuZyIsImltYWdlMTE0LnBuZyIsImltYWdlMTE1LnBuZyIsImltYWdlMTE2LnBuZyIsImltYWdlMTE3LnBuZyIsImltYWdlMTE4LnBuZyIsImltYWdlMTE5LnBuZyIsImltYWdlMTIwLnBuZyIsImltYWdlMTIxLnBuZyIsImltYWdlMTIyLnBuZyIsImltYWdlMTIzLnBuZyIsImltYWdlMTI0LnBuZyIsImltYWdlMTI1LnBuZyIsImltYWdlMTI2LnBuZyIsImltYWdlMTI3LnBuZyIsImltYWdlMTI4LnBuZyIsImltYWdlMTI5LnBuZyIsImltYWdlMTMwLnBuZyIsImltYWdlMTMxLnBuZyIsImltYWdlMTMyLnBuZyIsImltYWdlMTMzLnBuZyIsImltYWdlMTM0LnBuZyIsImltYWdlMTM1LnBuZyIsImltYWdlMTM2LnBuZyIsImltYWdlMTM3LnBuZyIsImltYWdlMTM4LnBuZyIsImltYWdlMTM5LnBuZyIsImltYWdlMTQwLnBuZyIsImltYWdlMTQxLnBuZyIsImltYWdlMTQyLnBuZyIsImltYWdlMTQzLnBuZyIsImltYWdlMTQ0LnBuZyIsImltYWdlMTQ1LnBuZyIsImltYWdlMTQ2LnBuZyIsImltYWdlMTQ3LnBuZyIsImltYWdlMTQ4LnBuZyIsImltYWdlMTQ5LnBuZyIsImltYWdlMTUwLnBuZyIsImltYWdlMTUxLnBuZyIsImltYWdlMTUyLnBuZyIsImltYWdlMTUzLnBuZyIsImltYWdlMTU0LnBuZyIsImltYWdlMTU1LnBuZyIsImltYWdlMTU2LnBuZyIsImltYWdlMTU3LnBuZyIsImltYWdlMTU4LnBuZyIsImltYWdlMTU5LnBuZyIsImltYWdlMTYwLnBuZyIsImltYWdlMTYxLnBuZyIsImltYWdlMTYyLnBuZyIsImltYWdlMTYzLnBuZyIsImltYWdlMTY0LnBuZyIsImltYWdlMTY1LnBuZyIsImltYWdlMTY2LnBuZyIsImltYWdlMTY3LnBuZyIsImltYWdlMTY4LnBuZyIsImltYWdlMTY5LnBuZyIsImltYWdlMTcwLnBuZyIsImltYWdlMTcxLnBuZyIsImltYWdlMTcyLnBuZyIsImltYWdlMTczLnBuZyIsImltYWdlMTc0LnBuZyIsImltYWdlMTc1LnBuZyIsImltYWdlMTc2LnBuZyIsImltYWdlMTc3LnBuZyIsImltYWdlMTc4LnBuZyIsImltYWdlMTc5LnBuZyIsImltYWdlMTgwLnBuZyIsImltYWdlMTgxLnBuZyIsImltYWdlMTgyLnBuZyIsImltYWdlMTgzLnBuZyIsImltYWdlMTg0LnBuZyIsImltYWdlMTg1LnBuZyIsImltYWdlMTg2LnBuZyIsImltYWdlMTg3LnBuZyIsImltYWdlMTg4LnBuZyIsImltYWdlMTg5LnBuZyIsImltYWdlMTkwLnBuZyIsImltYWdlMTkxLnBuZyIsImltYWdlMTkyLnBuZyIsImltYWdlMTkzLnBuZyIsImltYWdlMTk0LnBuZyIsImltYWdlMTk1LnBuZyIsImltYWdlMTk2LnBuZyIsImltYWdlMTk3LnBuZyIsImltYWdlMTk4LnBuZyIsImltYWdlMTk5LnBuZyIsImltYWdlMjAwLnBuZyIsImltYWdlMjAxLnBuZyIsImltYWdlMjAyLnBuZyIsImltYWdlMjAzLnBuZyIsImltYWdlMjA0LnBuZyIsImltYWdlMjA1LnBuZyIsImltYWdlMjA2LnBuZyIsImltYWdlMjA3LnBuZyIsImltYWdlMjA4LnBuZyIsImltYWdlMjA5LnBuZyIsImltYWdlMjEwLnBuZyIsImltYWdlMjExLnBuZyIsImltYWdlMjEyLnBuZyIsImltYWdlMjEzLnBuZyIsImltYWdlMjE0LnBuZyIsImltYWdlMjE1LnBuZyIsImltYWdlMjE2LnBuZyIsImltYWdlMjE3LnBuZyIsImltYWdlMjE4LnBuZyIsImltYWdlMjE5LnBuZyIsImltYWdlMjIwLnBuZyIsImltYWdlMjIxLnBuZyIsImltYWdlMjIyLnBuZyIsImltYWdlMjIzLnBuZyIsImltYWdlMjI0LnBuZyIsImltYWdlMjI1LnBuZyIsImltYWdlMjI2LnBuZyIsImltYWdlMjI3LnBuZyIsImltYWdlMjI4LnBuZyIsImltYWdlMjI5LnBuZyIsImltYWdlMjMwLnBuZyIsImltYWdlMjMxLnBuZyIsImltYWdlMjMyLnBuZyIsImltYWdlMjMzLnBuZyIsImltYWdlMjM0LnBuZyIsImltYWdlMjM1LnBuZyIsImltYWdlMjM2LnBuZyIsImltYWdlMjM3LnBuZyIsImltYWdlMjM4LnBuZyIsImltYWdlMjM5LnBuZyIsImltYWdlMjQwLnBuZyIsImltYWdlMjQxLnBuZyIsImltYWdlMjQyLnBuZyIsImltYWdlMjQzLnBuZyIsImltYWdlMjQ0LnBuZyIsImltYWdlMjQ1LnBuZyIsImltYWdlMjQ2LnBuZyIsImltYWdlMjQ3LnBuZyIsImltYWdlMjQ4LnBuZyIsImltYWdlMjQ5LnBuZyIsImltYWdlMjUwLnBuZyIsImltYWdlMjUxLnBuZyIsImltYWdlMjUyLnBuZyIsImltYWdlMjUzLnBuZyIsImltYWdlMjU0LnBuZyIsImltYWdlMjU1LnBuZyIsImltYWdlMjU2LnBuZyIsImltYWdlMjU3LnBuZyIsImltYWdlMjU4LnBuZyIsImltYWdlMjU5LnBuZyIsImltYWdlMjYwLnBuZyIsImltYWdlMjYxLnBuZyIsImltYWdlMjYyLnBuZyIsImltYWdlMjYzLnBuZyIsImltYWdlMjY0LnBuZyIsImltYWdlMjY1LnBuZyIsImltYWdlMjY2LnBuZyIsImltYWdlMjY3LnBuZyIsImltYWdlMjY4LnBuZyIsImltYWdlMjY5LnBuZyIsImltYWdlMjcwLnBuZyIsImltYWdlMjcxLnBuZyIsImltYWdlMjcyLnBuZyIsImltYWdlMjczLnBuZyIsImltYWdlMjc0LnBuZyIsImltYWdlMjc1LnBuZyIsImltYWdlMjc2LnBuZyIsImltYWdlMjc3LnBuZyIsImltYWdlMjc4LnBuZyIsImltYWdlMjc5LnBuZyIsImltYWdlMjgwLnBuZyIsImltYWdlMjgxLnBuZyIsImltYWdlMjgyLnBuZyIsImltYWdlMjgzLnBuZyIsImltYWdlMjg0LnBuZyIsImltYWdlMjg1LnBuZyIsImltYWdlMjg2LnBuZyIsImltYWdlMjg3LnBuZyIsImltYWdlMjg4LnBuZyIsImltYWdlMjg5LnBuZyIsImltYWdlMjkwLnBuZyIsImltYWdlMjkxLnBuZyIsImltYWdlMjkyLnBuZyIsImltYWdlMjkzLnBuZyIsImltYWdlMjk0LnBuZyIsImltYWdlMjk1LnBuZyIsImltYWdlMjk2LnBuZyIsImltYWdlMjk3LnBuZyIsImltYWdlMjk4LnBuZyIsImltYWdlMjk5LnBuZyIsImltYWdlMzAwLnBuZyIsImltYWdlMzAxLnBuZyIsImltYWdlMzAyLnBuZyIsImltYWdlMzAzLnBuZyIsImltYWdlMzA0LnBuZyIsImltYWdlMzA1LnBuZyIsImltYWdlMzA2LnBuZyIsImltYWdlMzA3LnBuZyIsImltYWdlMzA4LnBuZyIsImltYWdlMzA5LnBuZyIsImltYWdlMzEwLnBuZyIsImltYWdlMzExLnBuZyIsImltYWdlMzEyLnBuZyIsImltYWdlMzEzLnBuZyIsImltYWdlMzE0LnBuZyIsImltYWdlMzE1LnBuZyIsImltYWdlMzE2LnBuZyIsImltYWdlMzE3LnBuZyIsImltYWdlMzE4LnBuZyIsImltYWdlMzE5LnBuZyIsImltYWdlMzIwLnBuZyIsImltYWdlMzIxLnBuZyIsImltYWdlMzIyLnBuZyIsImltYWdlMzIzLnBuZyIsImltYWdlMzI0LnBuZyIsImltYWdlMzI1LnBuZyIsImltYWdlMzI2LnBuZyIsImltYWdlMzI3LnBuZyIsImltYWdlMzI4LnBuZyIsImltYWdlMzI5LnBuZyIsImltYWdlMzMwLnBuZyIsImltYWdlMzMxLnBuZyIsImltYWdlMzMyLnBuZyIsImltYWdlMzMzLnBuZyIsImltYWdlMzM0LnBuZyIsImltYWdlMzM1LnBuZyIsImltYWdlMzM2LnBuZyIsImltYWdlMzM3LnBuZyIsImltYWdlMzM4LnBuZyIsImltYWdlMzM5LnBuZyIsImltYWdlMzQwLnBuZyIsImltYWdlMzQxLnBuZyIsImltYWdlMzQyLnBuZyIsImltYWdlMzQzLnBuZyIsImltYWdlMzQ0LnBuZyIsImltYWdlMzQ1LnBuZyIsImltYWdlMzQ2LnBuZyIsImltYWdlMzQ3LnBuZyIsImltYWdlMzQ4LnBuZyIsImltYWdlMzQ5LnBuZyIsImltYWdlMzUwLnBuZyIsImltYWdlMzUxLnBuZyIsImltYWdlMzUyLnBuZyIsImltYWdlMzUzLnBuZyIsImltYWdlMzU0LnBuZyIsImltYWdlMzU1LnBuZyIsImltYWdlMzU2LnBuZyIsImltYWdlMzU3LnBuZyIsImltYWdlMzU4LnBuZyIsImltYWdlMzU5LnBuZyIsImltYWdlMzYwLnBuZyIsImltYWdlMzYxLnBuZyIsImltYWdlMzYyLnBuZyIsImltYWdlMzYzLnBuZyIsImltYWdlMzY0LnBuZyIsImltYWdlMzY1LnBuZyIsImltYWdlMzY2LnBuZyIsImltYWdlMzY3LnBuZyIsImltYWdlMzY4LnBuZyIsImltYWdlMzY5LnBuZyIsImltYWdlMzcwLnBuZyIsImltYWdlMzcxLnBuZyIsImltYWdlMzcyLnBuZyIsImltYWdlMzczLnBuZyIsImltYWdlMzc0LnBuZyIsImltYWdlMzc1LnBuZyIsImltYWdlMzc2LnBuZyIsImltYWdlMzc3LnBuZyIsImltYWdlMzc4LnBuZyIsImltYWdlMzc5LnBuZyIsImltYWdlMzgwLnBuZyIsImltYWdlMzgxLnBuZyIsImltYWdlMzgyLnBuZyIsImltYWdlMzgzLnBuZyIsImltYWdlMzg0LnBuZyIsImltYWdlMzg1LnBuZyIsImltYWdlMzg2LnBuZyIsImltYWdlMzg3LnBuZyIsImltYWdlMzg4LnBuZyIsImltYWdlMzg5LnBuZyIsImltYWdlMzkwLnBuZyIsImltYWdlMzkxLnBuZyIsImltYWdlMzkyLnBuZyIsImltYWdlMzkzLnBuZyIsImltYWdlMzk0LnBuZyIsImltYWdlMzk1LnBuZyIsImltYWdlMzk2LnBuZyIsImltYWdlMzk3LnBuZyIsImltYWdlMzk4LnBuZyIsImltYWdlMzk5LnBuZyIsImltYWdlNDAwLnBuZyIsImltYWdlNDAxLnBuZyIsImltYWdlNDAyLnBuZyIsImltYWdlNDAzLnBuZyIsImltYWdlNDA0LnBuZyIsImltYWdlNDA1LnBuZyIsImltYWdlNDA2LnBuZyIsImltYWdlNDA3LnBuZyIsImltYWdlNDA4LnBuZyIsImltYWdlNDA5LnBuZyIsImltYWdlNDEwLnBuZyIsImltYWdlNDExLnBuZyIsImltYWdlNDEyLnBuZyIsImltYWdlNDEzLnBuZyIsImltYWdlNDE0LnBuZyIsImltYWdlNDE1LnBuZyIsImltYWdlNDE2LnBuZyIsImltYWdlNDE3LnBuZyIsImltYWdlNDE4LnBuZyIsImltYWdlNDE5LnBuZyIsImltYWdlNDIwLnBuZyIsImltYWdlNDIxLnBuZyIsImltYWdlNDIyLnBuZyIsImltYWdlNDIzLnBuZyIsImltYWdlNDI0LnBuZyIsImltYWdlNDI1LnBuZyIsImltYWdlNDI2LnBuZyIsImltYWdlNDI3LnBuZyIsImltYWdlNDI4LnBuZyIsImltYWdlNDI5LnBuZyIsImltYWdlNDMwLnBuZyIsImltYWdlNDMxLnBuZyIsImltYWdlNDMyLnBuZyIsImltYWdlNDMzLnBuZyIsImltYWdlNDM0LnBuZyIsImltYWdlNDM1LnBuZyIsImltYWdlNDM2LnBuZyIsImltYWdlNDM3LnBuZyIsImltYWdlNDM4LnBuZyIsImltYWdlNDM5LnBuZyIsImltYWdlNDQwLnBuZyIsImltYWdlNDQxLnBuZyIsImltYWdlNDQyLnBuZyIsImltYWdlNDQzLnBuZyIsImltYWdlNDQ0LnBuZyIsImltYWdlNDQ1LnBuZyIsImltYWdlNDQ2LnBuZyIsImltYWdlNDQ3LnBuZyIsImltYWdlNDQ4LnBuZyIsImltYWdlNDQ5LnBuZyIsImltYWdlNDUwLnBuZyIsImltYWdlNDUxLnBuZyIsImltYWdlNDUyLnBuZyIsImltYWdlNDUzLnBuZyIsImltYWdlNDU0LnBuZyIsImltYWdlNDU1LnBuZyIsImltYWdlNDU2LnBuZyIsImltYWdlNDU3LnBuZyIsImltYWdlNDU4LnBuZyIsImltYWdlNDU5LnBuZyIsImltYWdlNDYwLnBuZyIsImltYWdlNDYxLnBuZyIsImltYWdlNDYyLnBuZyIsImltYWdlNDYzLnBuZyIsImltYWdlNDY0LnBuZyIsImltYWdlNDY1LnBuZyIsImltYWdlNDY2LnBuZyIsImltYWdlNDY3LnBuZyIsImltYWdlNDY4LnBuZyIsImltYWdlNDY5LnBuZyIsImltYWdlNDcwLnBuZyIsImltYWdlNDcxLnBuZyIsImltYWdlNDcyLnBuZyIsImltYWdlNDczLnBuZyIsImltYWdlNDc0LnBuZyIsImltYWdlNDc1LnBuZyIsImltYWdlNDc2LnBuZyIsImltYWdlNDc3LnBuZyIsImltYWdlNDc4LnBuZyIsImltYWdlNDc5LnBuZyIsImltYWdlNDgwLnBuZyIsImltYWdlNDgxLnBuZyIsImltYWdlNDgyLnBuZyIsImltYWdlNDgzLnBuZyIsImltYWdlNDg0LnBuZyIsImltYWdlNDg1LnBuZyIsImltYWdlNDg2LnBuZyIsImltYWdlNDg3LnBuZyIsImltYWdlNDg4LnBuZyIsImltYWdlNDg5LnBuZyIsImltYWdlNDkwLnBuZyIsImltYWdlNDkxLnBuZyIsImltYWdlNDkyLnBuZyIsImltYWdlNDkzLnBuZyIsImltYWdlNDk0LnBuZyIsImltYWdlNDk1LnBuZyIsImltYWdlNDk2LnBuZyIsImltYWdlNDk3LnBuZyIsImltYWdlNDk4LnBuZyIsImltYWdlNDk5LnBuZyIsImltYWdlNTAwLnBuZyIsImltYWdlNTAxLnBuZyIsImltYWdlNTAyLnBuZyIsImltYWdlNTAzLnBuZyIsImltYWdlNTA0LnBuZyIsImltYWdlNTA1LnBuZyIsImltYWdlNTA2LnBuZyIsImltYWdlNTA3LnBuZyIsImltYWdlNTA4LnBuZyIsImltYWdlNTA5LnBuZyIsImltYWdlNTEwLnBuZyIsImltYWdlNTExLnBuZyIsImltYWdlNTEyLnBuZyIsImltYWdlNTEzLnBuZyIsImltYWdlNTE0LnBuZyIsImltYWdlNTE1LnBuZyIsImltYWdlNTE2LnBuZyIsImltYWdlNTE3LnBuZyIsImltYWdlNTE4LnBuZyIsImltYWdlNTE5LnBuZyIsImltYWdlNTIwLnBuZyIsImltYWdlNTIxLnBuZyIsImltYWdlNTIyLnBuZyIsImltYWdlNTIzLnBuZyIsImltYWdlNTI0LnBuZyIsImltYWdlNTI1LnBuZyIsImltYWdlNTI2LnBuZyIsImltYWdlNTI3LnBuZyIsImltYWdlNTI4LnBuZyIsImltYWdlNTI5LnBuZyIsImltYWdlNTMwLnBuZyIsImltYWdlNTMxLnBuZyIsImltYWdlNTMyLnBuZyIsImltYWdlNTMzLnBuZyIsImltYWdlNTM0LnBuZyIsImltYWdlNTM1LnBuZyIsImltYWdlNTM2LnBuZyIsImltYWdlNTM3LnBuZyIsImltYWdlNTM4LnBuZyIsImltYWdlNTM5LnBuZyIsImltYWdlNTQwLnBuZyIsImltYWdlNTQxLnBuZyIsImltYWdlNTQyLnBuZyIsImltYWdlNTQzLnBuZyIsImltYWdlNTQ0LnBuZyIsImltYWdlNTQ1LnBuZyIsImltYWdlNTQ2LnBuZyIsImltYWdlNTQ3LnBuZyIsImltYWdlNTQ4LnBuZyIsImltYWdlNTQ5LnBuZyIsImltYWdlNTUwLnBuZyIsImltYWdlNTUxLnBuZyIsImltYWdlNTUyLnBuZyIsImltYWdlNTUzLnBuZyIsImltYWdlNTU0LnBuZyIsImltYWdlNTU1LnBuZyIsImltYWdlNTU2LnBuZyIsImltYWdlNTU3LnBuZyIsImltYWdlNTU4LnBuZyIsImltYWdlNTU5LnBuZyIsImltYWdlNTYwLnBuZyIsImltYWdlNTYxLnBuZyIsImltYWdlNTYyLnBuZyIsImltYWdlNTYzLnBuZyIsImltYWdlNTY0LnBuZyIsImltYWdlNTY1LnBuZyIsImltYWdlNTY2LnBuZyIsImltYWdlNTY3LnBuZyIsImltYWdlNTY4LnBuZyIsImltYWdlNTY5LnBuZyIsImltYWdlNTcwLnBuZyIsImltYWdlNTcxLnBuZyIsImltYWdlNTcyLnBuZyIsImltYWdlNTczLnBuZyIsImltYWdlNTc0LnBuZyIsImltYWdlNTc1LnBuZyIsImltYWdlNTc2LnBuZyIsImltYWdlNTc3LnBuZyIsImltYWdlNTc4LnBuZyIsImltYWdlNTc5LnBuZyIsImltYWdlNTgwLnBuZyIsImltYWdlNTgxLnBuZyIsImltYWdlNTgyLnBuZyIsImltYWdlNTgzLnBuZyIsImltYWdlNTg0LnBuZyIsImltYWdlNTg1LnBuZyIsImltYWdlNTg2LnBuZyIsImltYWdlNTg3LnBuZyIsImltYWdlNTg4LnBuZyIsImltYWdlNTg5LnBuZyIsImltYWdlNTkwLnBuZyIsImltYWdlNTkxLnBuZyIsImltYWdlNTkyLnBuZyIsImltYWdlNTkzLnBuZyIsImltYWdlNTk0LnBuZyIsImltYWdlNTk1LnBuZyIsImltYWdlNTk2LnBuZyIsImltYWdlNTk3LnBuZyIsImltYWdlNTk4LnBuZyIsImltYWdlNTk5LnBuZyIsImltYWdlNjAwLnBuZyIsImltYWdlNjAxLnBuZyIsImltYWdlNjAyLnBuZyIsImltYWdlNjAzLnBuZyIsImltYWdlNjA0LnBuZyIsImltYWdlNjA1LnBuZyIsImltYWdlNjA2LnBuZyIsImltYWdlNjA3LnBuZyIsImltYWdlNjA4LnBuZyIsImltYWdlNjA5LnBuZyIsImltYWdlNjEwLnBuZyIsImltYWdlNjExLnBuZyIsImltYWdlNjEyLnBuZyIsImltYWdlNjEzLnBuZyIsImltYWdlNjE0LnBuZyIsImltYWdlNjE1LnBuZyIsImltYWdlNjE2LnBuZyIsImltYWdlNjE3LnBuZyIsImltYWdlNjE4LnBuZyIsImltYWdlNjE5LnBuZyIsImltYWdlNjIwLnBuZyIsImltYWdlNjIxLnBuZyIsImltYWdlNjIyLnBuZyIsImltYWdlNjIzLnBuZyIsImltYWdlNjI0LnBuZyIsImltYWdlNjI1LnBuZyIsImltYWdlNjI2LnBuZyIsImltYWdlNjI3LnBuZyIsImltYWdlNjI4LnBuZyIsImltYWdlNjI5LnBuZyIsImltYWdlNjMwLnBuZyIsImltYWdlNjMxLnBuZyIsImltYWdlNjMyLnBuZyIsImltYWdlNjMzLnBuZyIsImltYWdlNjM0LnBuZyIsImltYWdlNjM1LnBuZyIsImltYWdlNjM2LnBuZyIsImltYWdlNjM3LnBuZyIsImltYWdlNjM4LnBuZyIsImltYWdlNjM5LnBuZyIsImltYWdlNjQwLnBuZyIsImltYWdlNjQxLnBuZyIsImltYWdlNjQyLnBuZyIsImltYWdlNjQzLnBuZyIsImltYWdlNjQ0LnBuZyIsImltYWdlNjQ1LnBuZyIsImltYWdlNjQ2LnBuZyIsImltYWdlNjQ3LnBuZyIsImltYWdlNjQ4LnBuZyIsImltYWdlNjQ5LnBuZyIsImltYWdlNjUwLnBuZyIsImltYWdlNjUxLnBuZyIsImltYWdlNjUyLnBuZyIsImltYWdlNjUzLnBuZyIsImltYWdlNjU0LnBuZyIsImltYWdlNjU1LnBuZyIsImltYWdlNjU2LnBuZyIsImltYWdlNjU3LnBuZyIsImltYWdlNjU4LnBuZyIsImltYWdlNjU5LnBuZyIsImltYWdlNjYwLnBuZyIsImltYWdlNjYxLnBuZyIsImltYWdlNjYyLnBuZyIsImltYWdlNjYzLnBuZyIsImltYWdlNjY0LnBuZyIsImltYWdlNjY1LnBuZyIsImltYWdlNjY2LnBuZyIsImltYWdlNjY3LnBuZyIsImltYWdlNjY4LnBuZyIsImltYWdlNjY5LnBuZyIsImltYWdlNjcwLnBuZyIsImltYWdlNjcxLnBuZyIsImltYWdlNjcyLnBuZyIsImltYWdlNjczLnBuZyIsImltYWdlNjc0LnBuZyIsImltYWdlNjc1LnBuZyIsImltYWdlNjc2LnBuZyIsImltYWdlNjc3LnBuZyIsImltYWdlNjc4LnBuZyIsImltYWdlNjc5LnBuZyIsImltYWdlNjgwLnBuZyIsImltYWdlNjgxLnBuZyIsImltYWdlNjgyLnBuZyIsImltYWdlNjgzLnBuZyIsImltYWdlNjg0LnBuZyIsImltYWdlNjg1LnBuZyIsImltYWdlNjg2LnBuZyIsImltYWdlNjg3LnBuZyIsImltYWdlNjg4LnBuZyIsImltYWdlNjg5LnBuZyIsImltYWdlNjkwLnBuZyIsImltYWdlNjkxLnBuZyIsImltYWdlNjkyLnBuZyIsImltYWdlNjkzLnBuZyIsImltYWdlNjk0LnBuZyIsImltYWdlNjk1LnBuZyIsImltYWdlNjk2LnBuZyIsImltYWdlNjk3LnBuZyIsImltYWdlNjk4LnBuZyIsImltYWdlNjk5LnBuZyIsImltYWdlNzAwLnBuZyIsImltYWdlNzAxLnBuZyIsImltYWdlNzAyLnBuZyIsImltYWdlNzAzLnBuZyIsImltYWdlNzA0LnBuZyIsImltYWdlNzA1LnBuZyIsImltYWdlNzA2LnBuZyIsImltYWdlNzA3LnBuZyIsImltYWdlNzA4LnBuZyIsImltYWdlNzA5LnBuZyIsImltYWdlNzEwLnBuZyIsImltYWdlNzExLnBuZyIsImltYWdlNzEyLnBuZyIsImltYWdlNzEzLnBuZyIsImltYWdlNzE0LnBuZyIsImltYWdlNzE1LnBuZyIsImltYWdlNzE2LnBuZyIsImltYWdlNzE3LnBuZyIsImltYWdlNzE4LnBuZyIsImltYWdlNzE5LnBuZyIsImltYWdlNzIwLnBuZyIsImltYWdlNzIxLnBuZyIsImltYWdlNzIyLnBuZyIsImltYWdlNzIzLnBuZyIsImltYWdlNzI0LnBuZyIsImltYWdlNzI1LnBuZyIsImltYWdlNzI2LnBuZyIsImltYWdlNzI3LnBuZyIsImltYWdlNzI4LnBuZyIsImltYWdlNzI5LnBuZyIsImltYWdlNzMwLnBuZyIsImltYWdlNzMxLnBuZyIsImltYWdlNzMyLnBuZyIsImltYWdlNzMzLnBuZyIsImltYWdlNzM0LnBuZyIsImltYWdlNzM1LnBuZyIsImltYWdlNzM2LnBuZyIsImltYWdlNzM3LnBuZyIsImltYWdlNzM4LnBuZyIsImltYWdlNzM5LnBuZyIsImltYWdlNzQwLnBuZyIsImltYWdlNzQxLnBuZyIsImltYWdlNzQyLnBuZyIsImltYWdlNzQzLnBuZyIsImltYWdlNzQ0LnBuZyIsImltYWdlNzQ1LnBuZyIsImltYWdlNzQ2LnBuZyIsImltYWdlNzQ3LnBuZyIsImltYWdlNzQ4LnBuZyIsImltYWdlNzQ5LnBuZyIsImltYWdlNzUwLnBuZyIsImltYWdlNzUxLnBuZyIsImltYWdlNzUyLnBuZyIsImltYWdlNzUzLnBuZyIsImltYWdlNzU0LnBuZyIsImltYWdlNzU1LnBuZyIsImltYWdlNzU2LnBuZyIsImltYWdlNzU3LnBuZyIsImltYWdlNzU4LnBuZyIsImltYWdlNzU5LnBuZyIsImltYWdlNzYwLnBuZyIsImltYWdlNzYxLnBuZyIsImltYWdlNzYyLnBuZyIsImltYWdlNzYzLnBuZyIsImltYWdlNzY0LnBuZyIsImltYWdlNzY1LnBuZyIsImltYWdlNzY2LnBuZyIsImltYWdlNzY3LnBuZyIsImltYWdlNzY4LnBuZyIsImltYWdlNzY5LnBuZyIsImltYWdlNzcwLnBuZyIsImltYWdlNzcxLnBuZyIsImltYWdlNzcyLnBuZyIsImltYWdlNzczLnBuZyIsImltYWdlNzc0LnBuZyIsImltYWdlNzc1LnBuZyIsImltYWdlNzc2LnBuZyIsImltYWdlNzc3LnBuZyIsImltYWdlNzc4LnBuZyIsImltYWdlNzc5LnBuZyIsImltYWdlNzgwLnBuZyIsImltYWdlNzgxLnBuZyIsImltYWdlNzgyLnBuZyIsImltYWdlNzgzLnBuZyIsImltYWdlNzg0LnBuZyIsImltYWdlNzg1LnBuZyIsImltYWdlNzg2LnBuZyIsImltYWdlNzg3LnBuZyIsImltYWdlNzg4LnBuZyIsImltYWdlNzg5LnBuZyIsImltYWdlNzkwLnBuZyIsImltYWdlNzkxLnBuZyIsImltYWdlNzkyLnBuZyIsImltYWdlNzkzLnBuZyIsImltYWdlNzk0LnBuZyIsImltYWdlNzk1LnBuZyIsImltYWdlNzk2LnBuZyIsImltYWdlNzk3LnBuZyIsImltYWdlNzk4LnBuZyIsImltYWdlNzk5LnBuZyIsImltYWdlODAwLnBuZyIsImltYWdlODAxLnBuZyIsImltYWdlODAyLnBuZyIsImltYWdlODAzLnBuZyIsImltYWdlODA0LnBuZyIsImltYWdlODA1LnBuZyIsImltYWdlODA2LnBuZyIsImltYWdlODA3LnBuZyIsImltYWdlODA4LnBuZyIsImltYWdlODA5LnBuZyIsImltYWdlODEwLnBuZyIsImltYWdlODExLnBuZyIsImltYWdlODEyLnBuZyIsImltYWdlODEzLnBuZyIsImltYWdlODE0LnBuZyIsImltYWdlODE1LnBuZyIsImltYWdlODE2LnBuZyIsImltYWdlODE3LnBuZyIsImltYWdlODE4LnBuZyIsImltYWdlODE5LnBuZyIsImltYWdlODIwLnBuZyIsImltYWdlODIxLnBuZyIsImltYWdlODIyLnBuZyIsImltYWdlODIzLnBuZyIsImltYWdlODI0LnBuZyIsImltYWdlODI1LnBuZyIsImltYWdlODI2LnBuZyIsImltYWdlODI3LnBuZyIsImltYWdlODI4LnBuZyIsImltYWdlODI5LnBuZyIsImltYWdlODMwLnBuZyIsImltYWdlODMxLnBuZyIsImltYWdlODMyLnBuZyIsImltYWdlODMzLnBuZyIsImltYWdlODM0LnBuZyIsImltYWdlODM1LnBuZyIsImltYWdlODM2LnBuZyIsImltYWdlODM3LnBuZyIsImltYWdlODM4LnBuZyIsImltYWdlODM5LnBuZyIsImltYWdlODQwLnBuZyIsImltYWdlODQxLnBuZyIsImltYWdlODQyLnBuZyIsImltYWdlODQzLnBuZyIsImltYWdlODQ0LnBuZyIsImltYWdlODQ1LnBuZyIsImltYWdlODQ2LnBuZyIsImltYWdlODQ3LnBuZyIsImltYWdlODQ4LnBuZyIsImltYWdlODQ5LnBuZyIsImltYWdlODUwLnBuZyIsImltYWdlODUxLnBuZyIsImltYWdlODUyLnBuZyIsImltYWdlODUzLnBuZyIsImltYWdlODU0LnBuZyIsImltYWdlODU1LnBuZyIsImltYWdlODU2LnBuZyIsImltYWdlODU3LnBuZyIsImltYWdlODU4LnBuZyIsImltYWdlODU5LnBuZyIsImltYWdlODYwLnBuZyIsImltYWdlODYxLnBuZyIsImltYWdlODYyLnBuZyIsImltYWdlODYzLnBuZyIsImltYWdlODY0LnBuZyIsImltYWdlODY1LnBuZyIsImltYWdlODY2LnBuZyIsImltYWdlODY3LnBuZyIsImltYWdlODY4LnBuZyIsImltYWdlODY5LnBuZyIsImltYWdlODcwLnBuZyIsImltYWdlODcxLnBuZyIsImltYWdlODcyLnBuZyIsImltYWdlODczLnBuZyIsImltYWdlODc0LnBuZyIsImltYWdlODc1LnBuZyIsImltYWdlODc2LnBuZyIsImltYWdlODc3LnBuZyIsImltYWdlODc4LnBuZyIsImltYWdlODc5LnBuZyIsImltYWdlODgwLnBuZyIsImltYWdlODgxLnBuZyIsImltYWdlODgyLnBuZyIsImltYWdlODgzLnBuZyIsImltYWdlODg0LnBuZyIsImltYWdlODg1LnBuZyIsImltYWdlODg2LnBuZyIsImltYWdlODg3LnBuZyIsImltYWdlODg4LnBuZyIsImltYWdlODg5LnBuZyIsImltYWdlODkwLnBuZyIsImltYWdlODkxLnBuZyIsImltYWdlODkyLnBuZyIsImltYWdlODkzLnBuZyIsImltYWdlODk0LnBuZyIsImltYWdlODk1LnBuZyIsImltYWdlODk2LnBuZyIsImltYWdlODk3LnBuZyIsImltYWdlODk4LnBuZyIsImltYWdlODk5LnBuZyIsImltYWdlOTAwLnBuZyIsImltYWdlOTAxLnBuZyIsImltYWdlOTAyLnBuZyIsImltYWdlOTAzLnBuZyIsImltYWdlOTA0LnBuZyIsImltYWdlOTA1LnBuZyIsImltYWdlOTA2LnBuZyIsImltYWdlOTA3LnBuZyIsImltYWdlOTA4LnBuZyIsImltYWdlOTA5LnBuZyIsImltYWdlOTEwLnBuZyIsImltYWdlOTExLnBuZyIsImltYWdlOTEyLnBuZyIsImltYWdlOTEzLnBuZyIsImltYWdlOTE0LnBuZyIsImltYWdlOTE1LnBuZyIsImltYWdlOTE2LnBuZyIsImltYWdlOTE3LnBuZyIsImltYWdlOTE4LnBuZyIsImltYWdlOTE5LnBuZyIsImltYWdlOTIwLnBuZyIsImltYWdlOTIxLnBuZyIsImltYWdlOTIyLnBuZyIsImltYWdlOTIzLnBuZyIsImltYWdlOTI0LnBuZyIsImltYWdlOTI1LnBuZyIsImltYWdlOTI2LnBuZyIsImltYWdlOTI3LnBuZyIsImltYWdlOTI4LnBuZyIsImltYWdlOTI5LnBuZyIsImltYWdlOTMwLnBuZyIsImltYWdlOTMxLnBuZyIsImltYWdlOTMyLnBuZyIsImltYWdlOTMzLnBuZyIsImltYWdlOTM0LnBuZyIsImltYWdlOTM1LnBuZyIsImltYWdlOTM2LnBuZyIsImltYWdlOTM3LnBuZyIsImltYWdlOTM4LnBuZyIsImltYWdlOTM5LnBuZyIsImltYWdlOTQwLnBuZyIsImltYWdlOTQxLnBuZyIsImltYWdlOTQyLnBuZyIsImltYWdlOTQzLnBuZyIsImltYWdlOTQ0LnBuZyIsImltYWdlOTQ1LnBuZyIsImltYWdlOTQ2LnBuZyIsImltYWdlOTQ3LnBuZyIsImltYWdlOTQ4LnBuZyIsImltYWdlOTQ5LnBuZyIsImltYWdlOTUwLnBuZyIsImltYWdlOTUxLnBuZyIsImltYWdlOTUyLnBuZyIsImltYWdlOTUzLnBuZyIsImltYWdlOTU0LnBuZyIsImltYWdlOTU1LnBuZyIsImltYWdlOTU2LnBuZyIsImltYWdlOTU3LnBuZyIsImltYWdlOTU4LnBuZyIsImltYWdlOTU5LnBuZyIsImltYWdlOTYwLnBuZyIsImltYWdlOTYxLnBuZyIsImltYWdlOTYyLnBuZyIsImltYWdlOTYzLnBuZyIsImltYWdlOTY0LnBuZyIsImltYWdlOTY1LnBuZyIsImltYWdlOTY2LnBuZyIsImltYWdlOTY3LnBuZyIsImltYWdlOTY4LnBuZyIsImltYWdlOTY5LnBuZyIsImltYWdlOTcwLnBuZyIsImltYWdlOTcxLnBuZyIsImltYWdlOTcyLnBuZyIsImltYWdlOTczLnBuZyIsImltYWdlOTc0LnBuZyIsImltYWdlOTc1LnBuZyIsImltYWdlOTc2LnBuZyIsImltYWdlOTc3LnBuZyIsImltYWdlOTc4LnBuZyIsImltYWdlOTc5LnBuZyIsImltYWdlOTgwLnBuZyIsImltYWdlOTgxLnBuZyIsImltYWdlOTgyLnBuZyIsImltYWdlOTgzLnBuZyIsImltYWdlOTg0LnBuZyIsImltYWdlOTg1LnBuZyIsImltYWdlOTg2LnBuZyIsImltYWdlOTg3LnBuZyIsImltYWdlOTg4LnBuZyIsImltYWdlOTg5LnBuZyIsImltYWdlOTkwLnBuZyIsImltYWdlOTkxLnBuZyIsImltYWdlOTkyLnBuZyIsImltYWdlOTkzLnBuZyIsImltYWdlOTk0LnBuZyIsImltYWdlOTk1LnBuZyIsImltYWdlOTk2LnBuZyIsImltYWdlOTk3LnBuZyIsImltYWdlOTk4LnBuZyIsImltYWdlOTk5LnBuZyJdLCJpYXQiOjE1MTYyMzkwMjJ9.KGrocKdxHn_ZCkgfl5SAbKxCm8tbqVOBslU_x3SrYAg"><u>has 1000 files</u></a> the JWT length changes from 239 characters to 20,057 - and that’s considering a simple file name. With the full path, it’s even longer. Additionally, a JWT created during the authentication phase doesn’t include all the necessary information required to make the policy decision -  especially if you are using a vendor like Auth0 to authenticate. In addition, storing data in JWTs means we have to refresh the token (read as login/logout) every time we want to update the data. </p><p><u>The ugly:</u></p><p>You might think it’s a good idea to start with JWTs because you don’t have a lot of data - as time goes by the amount of data grows exponentially, and the situation easily spirals out of control, with an enormous amount of JWTs floating around in each request. </p><p><u>Bottom-line:</u></p><p>JWTs are ideal for simple identity-related data, and in general, it’s best to think of the claims and data in the JWT as hints about identity (given by the Identity-Management and Authentication layers) rather than verbatim data for authorization.</p><p></p><h2><a id="2" title="#2" href="#2">2. Overload input for OPA within the query:</a></h2><p></p><img src="https://media.graphassets.com/resize=width:654,height:630/3RwiRdgQSuiUruCuC7w3" alt="Overload input for OPA within the query:" title="2.png" width="654" height="630" /><p>Another option is to attach input for every policy query to OPA, adding the relevant data to it.  </p><p>It will look something like this in python pseudocode wrapping OPA:</p><pre><code>def delete_image(user_id, image_id):
	policy_json_data = {}
	policy_json_data[“user_roles”] = get_user_roles(user_id) # returns list of roles like [“editor”]
	policy_json_data[”user_images”] = get_user_images(user_id) # returns list of images [“img.png”]

# sends request that looks like this:
# localhost:8181 -i -d ‘{&quot;roles&quot;: [&quot;pro&quot;], &quot;related_images&quot;: [&quot;image0.png&quot;, &quot;image1.png&quot;], image_id: “image2.png”}’ -H &#39;Content-Type: application/json&#39;
# and returns true / false
	permitted = check_opa_policy(policy_json_data, “delete”, image_id) 
	if not permitted:
		raise(AuthorizationError)</code></pre><p><u>The good:</u></p><p>Using this method is simple, and it ensures that only the relevant data is cherry-picked for each query sent, thus avoiding loading/storing a lot of data in OPA. </p><p><u>The bad:</u></p><p>This method prevents us from following one of the most important best practices in building authorization - decoupling policy and code. As our code now has to take on the responsibility of tailoring the data for OPA. Having policy and code mixed together in one layer creates a situation where we struggle to upgrade, add capabilities and monitor the code overall as it is replicated between different microservices. Each change would require us to refactor large areas of code that only drift further from one another as these microservices develop.</p><p><u>The ugly:</u></p><p>Having so much code repetition is an antithesis to the <a title="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself"><u>DRY</u></a> principle - creating a multitude of complications and difficulties as our application evolves. Considering the example code above for instance, a very similar code will be written to delete_image, update_image, and get_image.</p><p><u>Bottom-line:<br></u>In general, it is best to leave this method for simple cases or to augment more advanced cases with cherry-picking.</p><p></p><h2><a id="3" title="#3" href="#3">3. Polling for data using Bundles</a></h2><img src="https://media.graphassets.com/resize=width:654,height:630/cmxcNwES26dWq2wL7Mhg" alt="Polling for data using Bundles" title="3.png" width="654" height="630" /><p>The bundle feature periodically checks and downloads policy bundles from a centralized server, which can include both data and policies. An example of a simple way to implement this solution would be running an Nginx container that serves the bundle files and configuring OPA to fetch data from it (using s3 buckets is also a common pattern). The configuration for OPA will be as follows: </p><pre><code>services:
  nginx:
    url: https://my-nginx.example.com
    credentials:
      bearer:
        token: dGVzdGluZzp0ZXN0aW5n
        scheme: Basic

bundles:
  authz:
    service: nginx
    resource: /bundle.tar.gz</code></pre><p><u></u></p><p><u>The good:</u></p><p>It allows you to load large amounts of data (much larger than the 2 previous methods), it has a delta bundle feature that lets you sync only new data (but not policy), it lets you have one source of truth, and it is more readable than JWTs. </p><p><u>The bad:</u></p><p>Using bundles doesn’t cut it when we have data that changes rapidly, as it requires triggering a full policy update for every small change - Making this a very inefficient process.</p><p><u>The ugly:</u></p><p>Even with the new delta bundle feature, you still need to manage and create the bundles on your own, and it works with polling which isn’t real-time.<br><br>In addition, being dependent on a polling interval means you have to choose between rapid polling which can result in high costs or slow polling which can lead to delays and risk of inconsistency.</p><p><u>The bottom line:</u></p><p>For cases where updates to data mainly come as part of the CI/CD cycle, bundles are a great option.  Bundles can also work well for static or rather static applications. For modern dynamic applications, this option might be too slow/inefficient on its own. </p><p></p><h2><a id="4" title="#4" href="#4">4. Pushing data into OPA using the API</a></h2><img src="https://media.graphassets.com/resize=width:654,height:630/XT3GqaPzQMifKccMBTq3" alt="Pushing data into OPA using the API" title="4.png" width="654" height="630" /><p>You can also push policy data into OPA with an API request - this approach is similar in most aspects to the bundle API, except it allows you to optimize for update latency and network traffic. It will look something like this in python pseudo-code:</p><pre><code>def send_user_update_to_opa():
	requests.put(f”{opa_url}/users”, params={users: [user1,user2]})

def callback_on_new_user():
	all_users = get_all_users()
	send_update_to_opa(all_users)</code></pre><p>In this example, we are updating the user list of OPA for each callback on new user creation.</p><p><u>The good:</u></p><p>This way you don’t need to load the entire bundle at every update, you can also update part of it, which is much more performant in terms of memory and network usage - as well as giving you more control of how you manage distributed data into OPA.</p><p><u>The bad:</u></p><p>Applying this method to import new kinds of data from different data sources is going to require a continuous effort of writing enormous amounts of code.</p><p><u>The ugly:</u></p><p>This method requires continuous maintenance - you can’t just set it up and forget about it. If left abandoned, this code will very quickly become obsolete. </p><p><u>The bottom line: </u></p><p>Great way to load data into OPA in a dynamic fashion, but requires a lot of development and administration in all but very simple cases.</p><p></p><h2><a id="5" title="#5" href="#5">5. Pulling data using OPA during Policy Evaluation</a></h2><img src="https://media.graphassets.com/pwwjpmEdRTaSOlKUHX6q" alt="5.png" title="5.png" width="654" height="630" /><p><br>OPA includes a function (`http.send()`) that allows it to reach out to external HTTP servers during evaluation and request additional data. It will look something like this in Rego pseudo-code:</p><pre><code>default allow = false
 
allow = true {
    input.method == &quot;GET&quot;
    input.path = [&quot;getSalary&quot;, user]
    managers := http.send(get_managers_url)
    managers := managers[input.user][_]
    contains(managers, user)
}</code></pre><p>You can see the call to <strong>http.send(get_managers_url) </strong>that returns the list of the managers to help evaluate the policy. Similarly, you can embed more functions into OPA as a plugin to fetch data as part of a query from other sources.</p><p><u>The good:</u></p><p>This is a solid option to use when you have a very large volume of data that is required to make permission decisions, and you cannot load it all into OPA.</p><p><u>The bad:</u></p><p>Using this method puts a strain on OPA as it always comes with network latency that slows all of your policy evaluations. Additionally, this method is prone to network errors.  </p><p><u>The ugly:</u></p><p>Error handling with rego isn’t simple at all, and relying on this feature can lead to some <a title="https://github.com/open-policy-agent/opa/pull/2763" href="https://github.com/open-policy-agent/opa/pull/2763"><u>frustrating results</u></a>. While OPA and Rego can be used to evaluate policies very quickly, you may want to avoid adding more logic than you need.</p><p><u>The bottom line: </u></p><p>This is a great way to load data into OPA in a highly dynamic way without writing a lot of code. That being said, this solution is not applicable when the relevant data requires parsing or edge case handling, which Rego lacks. </p><p></p><h2><a id="6" title="#6" href="#6">6. OPAL (Open Policy Administration Layer):</a></h2><img src="https://media.graphassets.com/oll5D8GYQ3u1eoKuk0gX" alt="6.png" title="6.png" width="654" height="630" /><p><a title="https://www.permit.io/blog/introduction-to-opal" href="https://www.permit.io/blog/introduction-to-opal">OPAL </a>is <a title="https://github.com/permitio/opal" href="https://github.com/permitio/opal">an open-source project</a> for administering authorization and access control for OPA. OPAL responds to policy and data changes, pushes live updates to OPA agents, and thus brings open policy up to the speed needed by live applications.</p><p>To run OPAL with OPA you can simply <a target='_blank' title="https://docs.opal.ac/getting-started/running-opal/overview" href="https://docs.opal.ac/getting-started/running-opal/overview"><u>use the Docker example</u></a>. Send an <a target='_blank' title="https://docs.opal.ac/tutorials/trigger_data_updates" href="https://docs.opal.ac/tutorials/trigger_data_updates"><u>update to OPAL on every change in your data</u></a> or connect your data source&#39;s webhook with OPAL and let OPAL stream the updates to OPA.</p><p><u>The good:</u></p><p>OPAL includes live updates and Git tracking (GitOps) and saves you the hassle of having to write all the code by yourself, like in the ‘Pushing Data with API’ option.</p><p><u>The bad:</u></p><p>OPAL is a fairly new library. It might take some time to learn and some work to integrate into your project.</p><p><br><u>The ugly:</u></p><p>First of all, OPAL is beautiful (But being one of the contributors to this open source project I might be biased). That being said, the architecture can be a bit more complicated than bundle server/JWTs, so you might need to take your time and make sure you understand it.</p><p><u>The bottom line:</u></p><p>OPAL is inspired by the way companies like Netflix work with OPA, but it requires some work to set up. Simple applications will do better with one of the other methods, but for full modern applications, OPAL is probably the more robust/reliable option. </p><p></p><h2>Conclusion</h2><p>There are various methods to build data fetching mechanisms - each of them having their own pros and cons. <br><br>Some of these methods (Including data in JWT tokens and using Overload input for OPA within the query) could only prove useful in simple cases, some (Polling for data using Bundles) lack effectiveness in dynamic applications. Pushing data with API is a good solution to load data into OPA in a dynamic fashion while requiring a lot of development and administration, and Pulling data using OPA during Policy Evaluation is not applicable when the relevant data requires parsing or edge case handling. OPAL has the advantage of being a more robust/reliable solution, but it requires you to adopt new open-source-based technology.</p><p>The most important thing to take from this review is understanding the complexities and challenges of building data fetching mechanisms correctly, and understanding that every method has its pros and cons. <br><br>Still not sure which method is the right one for you and your architecture? Need someone to brainstorm with? Don’t be shy - reach out to us on our <a title="https://io.permit.io/permitslack" href="https://io.permit.io/permitslack">Slack community</a>.</p>]]></content>
        <author>
            <name>Oded Ben David</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[What is ABAC? Implementation Methods & Code Examples]]></title>
        <id>what-is-abac</id>
        <link href="https://www.permit.io/blog/what-is-abac"/>
        <updated>2022-03-13T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[What is Attribute Based Access Control, when should it be used, how can you implement it in your application, and how can you provide a UI for managing it?]]></summary>
        <content type="html"><![CDATA[<p>When building an application, there is one crucial thing we have to make sure of: <br>The <strong>right people</strong> have the <strong>right access</strong> to the <strong>right assets</strong>. This is what <a title="https://www.permit.io/blog/what-is-authorization" href="https://www.permit.io/blog/what-is-authorization"><u><strong>authorization</strong></u></a><strong> </strong>is all about.  There are different authorization models (RBAC, ABAC, ReBAC, etc.) and different ways to implement them. </p><p>We have already <a title="https://www.permit.io/blog/rbac-with-permit" href="https://www.permit.io/blog/rbac-with-permit">written about <strong>Role-Based Access Control (RBAC)</strong></a>, and how it can be implemented using <a title="https://www.permit.io/blog/implement-rbac-using-opa" href="https://www.permit.io/blog/implement-rbac-using-opa"><u>Open Policy Agent (OPA)</u></a> and <a title="https://www.permit.io/" href="https://www.permit.io/"><u>Permit.io</u></a>. This time, we will dive deeper into the waters with <strong>Attribute Based Access Control (ABAC)</strong>.</p><h2>What is ABAC</h2><p>While RBAC is an authorization model that determines access based on <strong>predefined roles</strong> (Like Admin, Editor, and Viewer, for example), Attribute-Based Access Control (ABAC) is all about - <br>You guessed it, <strong>attributes</strong>. </p><p>ABAC is an authorization model that determines access based on <strong>conditions applied to attributes </strong>(or characteristics), rather than <strong>roles</strong>, allowing the definition of fine-grained complex access-control rules.  </p><p>Sounds complex? Let’s look at an example:</p><p></p><h2>ABAC Example</h2><p>Here’s a rather simple example of an ABAC policy in simple English - </p><p><strong>Employees </strong>that are <strong>based within the European Union</strong> can perform <strong>any action</strong> on a <strong>GDPR Protected Document</strong>.</p><p>Let’s dive into this - the policy, as any authorization policy, can be divided into three parts:</p><p><strong>Who </strong>can perform which <strong>Action </strong>on which <strong>Resource</strong> </p><p>In this example, the question ‘Who?’ can be answered by:</p><ol><li><div><p>Employees - a <strong>Role </strong></p></div></li><li><div><p>Based in the European Union - a <strong>User Attribute</strong></p></div></li></ol><p>The same goes for the Resource: </p><ol><li><div><p>Document - a <strong>Resource</strong></p></div></li><li><div><p>GDPR Protection - a <strong>Resource Attribute</strong></p></div></li></ol><img src="https://media.graphassets.com/lcH1kds3TUGzRavt3FsT" alt="Group 67691.png" title="Group 67691.png" width="1600" height="455" /><p>Now that we&#39;ve reviewed a simple example, let’s get into why you should (Or shouldn’t!) choose ABAC as the policy model for your application. </p><h2>ABAC Pros</h2><p>Generally, ABAC provides you with <strong>highly granular</strong> policy creation.</p><p>It provides a complex and detailed authorization method, with the ability to factor in a great number of variables, such as a user’s role, security clearance, time of access, location of the data, current organizational threat levels, resource creation date or ownership, data sensitivity, and many more. </p><p>Each of these provides a wider, more detailed spectrum of parameters for deciding on a user’s range of access.</p><p></p><h2>ABAC Cons</h2><p>While providing you with the capability for creating highly granular authorization policies - ABAC is not for everyone. ABAC requires more processing power and time and can be harder to design and implement. Additionally, the challenge of getting all the relevant attribute data into your decision point in time can be daunting as well (though this can be elevated by tools like <a title="https://github.com/permitio/opal" href="https://github.com/permitio/opal"><u>OPAL</u></a>).</p><p>RBAC provides a simple solution for determining authorization, which is usually sufficient for most organizations. In some cases, when a more in-depth approach to authorization is required, ABAC may be the best option.</p><p></p><h2>ABAC vs RBAC</h2><p>ABAC and RBAC are two of the most common authorization policy models. So how should you decide between them? In short - the choice between the two depends on the needs of your organization, and the application you are building. </p><p>RBAC provides a rather simple solution for determining authorization - Only a person with the role of X can perform action Y on resource Z. It’s simple, and is usually sufficient for most organizations.</p><p>ABAC provides a more in-depth approach, allowing you to add attributes into the mix and create much more granular access control. That being said, ABAC can require more processing power and time - so it&#39;s important to strike a balance, so your authorization policy is neither too simplistic nor too complex.</p><p>In many cases, <strong>RBAC and ABAC can be used together hierarchically</strong>, with broad access enforced by RBAC protocols and more complex access managed by ABAC. <br><br>Organizations often start by implementing their own RBAC, and then gradually evolve it into ABAC as additional attributes are required. When dynamic data points such as time, location, billing status, and current behavior come into effect - <strong>ABAC is unavoidable</strong>.</p><p>A more detailed overview of <a title="https://www.permit.io/blog/rbac-vs-abac" href="https://www.permit.io/blog/rbac-vs-abac">RBAC vs ABAC</a> is available here. </p><h2>Implementing ABAC</h2><p>Before we deal with implementing ABAC, we need to address two important challenges with implementing authorization policies in general -</p><ol><li><div><p>Each service in your application must be configured with its own set of policies manually. This can quite a hassle - as the number of policies, users, and services grows, updating the policies in each relevant service can become very tedious and time-consuming. Considering the fact that policies change all the time - they have to be at least somewhat fluid. </p></div></li><li><div><p>Mixing the code of the authorization layer into the application code is a bad idea <a title="https://www.permit.io/blog/5-best-practices-for-building-cloud-native-permissions#the-5-best-practices" href="https://www.permit.io/blog/5-best-practices-for-building-cloud-native-permissions#the-5-best-practices"><u>for several reasons</u></a>. In general, this can make it difficult to upgrade, add capabilities, and monitor the code as it is replicated between different microservices. Each change would require us to refactor large areas of code that only drift further from one another as these microservices develop. </p></div></li></ol><p>Both of these issues can be solved by <strong>creating a separate microservice for authorization</strong>, and thus<strong> decoupling our policy from our code</strong>. Controlling access management centrally through a separate authorization service allows you to offer it as a service to every system that needs to check whether a user can or cannot access its resources. This can be done by using <a title="https://www.permit.io/blog/introduction-to-opa" href="https://www.permit.io/blog/introduction-to-opa"><u>Open Policy Agent (OPA)</u></a>. </p><p>Let’s review a quick example of how an ABAC policy would be expressed with OPA.</p><p></p><h2>ABAC Example with OPA</h2><p>Using OPA’s Rego policy language, the example ABAC policy that we created above would look like this (<a title="https://play.openpolicyagent.org/p/AUxMrODE5c" href="https://play.openpolicyagent.org/p/AUxMrODE5c"><u>Try it out in the OPA playground</u></a>):</p><pre><code>package abac

# User attributes
user_attributes := {
    &quot;User1&quot;: {&quot;location&quot;: &quot;EU&quot;, &quot;title&quot;: &quot;employee&quot;},
    &quot;User2&quot;: {&quot;location&quot;: &quot;US&quot;, &quot;title&quot;: &quot;employee&quot;},
    &quot;User3&quot;: {&quot;location&quot;: &quot;EU&quot;, &quot;title&quot;: &quot;manager&quot;}
}
# Document attributes
document_attributes := {
    &quot;Doc1&quot;: {&quot;classification&quot;: &quot;GDPR Protected&quot;},
    &quot;Doc2&quot;: {&quot;classification&quot;: &quot;Non-sensitive&quot;}
}
# Default deny
default allow = false
# EU employees can perform any action on GDPR Protected Document
allow {
    # Lookup the user&#39;s attributes
    user := user_attributes[input.user]
    # Check that the user is an employee
    user.title == &quot;employee&quot;
    # Check that the employee is based in the EU
    user.location == &quot;EU&quot;
    # Check that the document is GDPR Protected
    document_attributes[input.document].classification == &quot;GDPR Protected&quot;
}
# Allow any employee to access non-GDPR-protected documents
allow {
    # Lookup the user&#39;s attributes
    user := user_attributes[input.user]
    # Check that the user is an employee
    user.title == &quot;employee&quot;
    # Lookup the document&#39;s attributes
    document := document_attributes[input.document]
    # Check that the document is not GDPR Protected
    document.classification = &quot;Non-sensitive&quot;
}
</code></pre><p>To learn more about implementing ABAC with OPA’s Rego, <a title="https://www.permit.io/blog/implement-abac-using-opa" href="https://www.permit.io/blog/implement-abac-using-opa"><u>check out this guide</u></a>. </p><p></p><h2>When is OPA not enough?</h2><p>While OPA provides us with the ability to <strong>unify all policies in one server</strong>, <strong>take on the role of policy decision-making and enforcement from the service</strong>, and <strong>manage policy as code</strong>, it lacks several key functionalities, most importantly:<br><br>The ability to create, manage and enforce ABAC Rego policies in a way <strong>anyone in your organization can use</strong>.<br><br>Rego is a powerful language, but not an easy one to learn, let alone master. Being a derivative of Datalog, it can prove as a struggle even for skilled engineers.<br><br>Normally, creating and managing your application’s authorization policies could only be done through <strong>complex R&amp;D work and steep learning curves</strong> (e.g. writing Rego code). This creates a situation where <strong>developers become bottlenecks</strong> in your app’s permission management, other <strong>stakeholders are locked out of the conversation</strong>, and your <strong>customers are left without the flexibility</strong> they require. All of these manifest as an<strong> unending stream of feature requests</strong>.</p><p>The solution is implementing and managing your RBAC and ABAC policies <strong>with a simple no-code UI</strong> which makes permission management accessible to other stakeholders. </p><p>That’s what Permit is here for - </p><p></p><h2>Permit - a UI for managing ABAC</h2><p>Permit provides developers with a permission management solution that makes policy-as-code as easy as checking a checkbox - generating the needed code for you, and wrapping it nicely into Git, and API / UI interfaces. </p><p>Here’s what our example ABAC policy would look like within Permit’s UI: </p><img src="https://media.graphassets.com/gz4QHlVGQAirOxXGY8us" alt="pasted image 0.png" title="pasted image 0.png" width="832" height="270" /><p>In the UI, selecting which user has access to a resource is as simple as checking a box. <br><br>Let’s review the basic steps of creating this policy within Permit’s UI:<br></p><ol><li><div><p>Create a <strong>User Role</strong> titled “Employee”<br></p><img src="https://media.graphassets.com/KPXnNg56SWaaCuCv9beo" alt="pasted image 0 (1).png" title="pasted image 0 (1).png" width="592" height="453" /><p></p></div></li><li><div><p>Create a <strong>“location” attribute</strong> with a string type<br></p><img src="https://media.graphassets.com/PhtHT0q0RGGDTBeEUdkd" alt="pasted image 0 (2).png" title="pasted image 0 (2).png" width="595" height="540" /><p></p></div></li></ol><p>3. Create a “<strong>User Set</strong>” titled “EU_Employees”, for which the conditions are:</p><ul><li><div>“user.location” = “EU”</div></li></ul><ul><li><div><p>“user.roles” contains “Employee”<br></p></div></li></ul><img src="https://media.graphassets.com/RdtoXZ18RySGMghheSk4" alt="pasted image 0 (3).png" title="pasted image 0 (3).png" width="595" height="620" /><p><br>4. Create a <strong>resource </strong>titled “document1” and add a boolean attribute to it called “GDPR” <br></p><img src="https://media.graphassets.com/UtMKZeeDSL6YSrG3KfRh" alt="pasted image 0 (4).png" title="pasted image 0 (4).png" width="593" height="720" /><p><br>5. Finally, create two “<strong>Resource Sets</strong>”: </p><ul><li><div><p>One titled “GDPR_DOC” with the condition of resource.GDPR = True</p></div></li><li><div><p>One titled “NON_GDPR_DOC” with the condition of resource.GDPR = False</p></div></li></ul><img src="https://media.graphassets.com/NJaCFc5ETIKIfvzde8ZO" alt="pasted image 0 (5).png" title="pasted image 0 (5).png" width="591" height="643" /><p></p><p>6. Once everything is set up, enforcing access control is as simple as checking a few boxes:<br></p><img src="https://media.graphassets.com/B91NMeX5R66d8yhWZEtM" alt="pasted image 0 (6).png" title="pasted image 0 (6).png" width="848" height="340" /><p>Permit’s concepts of User-Sets and Resource-Sets (aka Condition-Sets), allow users to manage complex ABAC systems with ease without having to write a single line of code. The UI generates Rego code into a Git repository of your choice, which you can edit, add to, and manage however you like. Striking a crucial balance between developer and customer needs.<br></p><img src="https://media.graphassets.com/zJ6pu0kRXqzyst9AcAke" alt="Group 67690 (2).png" title="Group 67690 (2).png" width="1600" height="792" /><p>This structure also allows you to transition from RBAC to ABAC smoothly and use complex attributes and conditions on them as if they were RBAC roles. </p><p>An in-depth tutorial on setting up ABAC policies with the Permit UI is available here: <br><br><a title="https://www.youtube.com/watch?v=QCsWlsjEE5A" href="https://www.youtube.com/watch?v=QCsWlsjEE5A"><u>Easily create ABAC policies with the Permit UI - Tutorial</u></a><br></p><h2>What wev&#39;e learned</h2><p>Let’s go over everything we learned about ABAC: </p><ul><li><div><p>ABAC is an authorization model that determines access based on <strong>attributes</strong>, allowing the definition of fine-grained complex access-control rules.</p></div></li><li><div><p>ABAC provides you with <strong>highly granular</strong> policy creation, but it can be harder to design and implement. </p></div></li><li><div><p>RBAC provides a <strong>rather simple solution</strong> for determining authorization which is usually sufficient for most organizations. ABAC provides <strong>a more in-depth approach</strong>, allowing you to add attributes into the mix.</p></div></li><li><div><p><strong>RBAC and ABAC can be used together hierarchically</strong>, with broad access enforced by RBAC protocols and more complex access managed by ABAC.</p></div></li><li><div><p>As each service in your application must be configured with its own set of policies manually, updating the policies in each relevant service can become very tedious and time-consuming. To avoid this, we can create <strong>a</strong> <strong>separate microservice for authorization using OPA.</strong></p></div></li><li><div><p>While OPA provides us with the ability to unify all policies in one server, take on the role of policy decision-making and enforcement from the service, and manage policy as code, <strong>it lacks the ability to create, manage and enforce ABAC Rego policies in a way anyone in your organization can use</strong>.</p></div></li><li><div><p>Permit’s <strong>no code UI</strong> <a title="https://www.permit.io/abac" href="https://www.permit.io/abac">allows you to <strong>create both RBAC and ABAC policies</strong></a>, and include other stakeholders in the permission management process, preventing developers from becoming bottlenecks. It also allows a smooth transition between the two using complex attributes and conditions as if they are RBAC roles. </p></div></li></ul><p>Want to learn more about Authorization? Join our <a title="https://io.permit.io/permitslack" href="https://io.permit.io/permitslack"><u>Slack community</u></a>, where there are hundreds of devs building and implementing authorization.</p>]]></content>
        <author>
            <name>Daniel Bass</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[An intro to Open Policy Agent (OPA)]]></title>
        <id>introduction-to-opa</id>
        <link href="https://www.permit.io/blog/introduction-to-opa"/>
        <updated>2022-03-07T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[How to Build The Right App Authorization Solution - An Intro to Open Policy Agent]]></summary>
        <content type="html"><![CDATA[<h2>How to Build The Right App Authorization Solution</h2><h2>The TL;DR</h2><p>Determining user access to digital assets is a critical aspect of building applications due to many privacy and security requirements. </p><p>Authorization solutions need to answer a simple question: <br><br>Can X (users, services) perform the action they are trying to complete? (i.e., Can the requesting user access a resource?)</p><p>While a simple question, the answer to it can be quite complex - Providing a reliable technical solution in the form of a good authorization service (That won’t need rewriting every several months) can be challenging, especially in a cloud environment.</p><p>In this article, we will:</p><ul><li><div><p>Cover a few methods for implementing an authorization layer, their advantages, and disadvantages.</p></div></li><li><div><p>Introduce <a target='_blank' title="https://github.com/open-policy-agent/opa" href="https://github.com/open-policy-agent/opa"><u>Open Policy Agent</u></a> (OPA), an open-source CNCF graduate project that was chosen by many prominent players in the industry (Such as Netflix, Pinterest, and Goldman Sachs) to solve their authorization needs.</p></div></li></ul><h2>A bit of background on authorization</h2><p>Enforcing authorization is a fundamental need for almost every product. While being critically important, it is also challenging to implement correctly. Rushing into development often leaves us with an inadequate solution that won’t hold up over time or complex code that is too hard to maintain - requiring repeated refactoring in the future.</p><p>There are various factors to consider when building an authorization layer, including its flexibility to keep up with future requirements, performance, and reliability with extensive usage.</p><p>To better understand this challenge, let’s first break down the basics: </p><img src="https://media.graphcms.com/resize=width:1546,height:809/XQjzZ480TyyhfmuFkqXD" alt="Example of a simple CMS website" title="Frame 4 (2).png" width="1546" height="809" /><p>Figure 1: A simple CMS website with 3 roles, 4 actions, and 1 resource. Users assigned to roles.</p><p>On this website, there are four users who are assigned three <strong>roles -</strong> a <u>viewer</u>, a <u>writer,</u> and an <u>editor</u>. <br><br>The roles can perform one of four <strong>actions</strong>: <u>view</u>, <u>create</u>, <u>edit</u>, and <u>publish</u> on one <strong>resource</strong>, an <u>article</u>. An arrow between nodes indicates that an action is supported (i.e. writer can create or edit), and a lack of an arrow indicates the user can’t perform the action (i.e. writer can’t publish).</p><p>Roles, actions, resources, and relationships are key in the world of authorization. If we generalize it, we get:</p><h4><strong>a [role] can/cannot perform [action] on a [resource] </strong></h4><p>The create_article method might look like that:</p><pre><code>function article create_article(user, content) { 
//insert article creation logic here
}</code></pre><p>Let’s look at different ways to ensure a user is authorized to create_article.</p><h2>Building an authorization layer</h2><p>There are three main methods for implementing an authorization layer:<br><br>You can <strong>build one on your own</strong>, or build one <strong>based on implementing existing elements from open source projects</strong> such as OPA or<strong> </strong>use a ready<strong> </strong><a title="https://www.permit.io/blog/authorization-as-a-service" href="https://www.permit.io/blog/authorization-as-a-service"><strong>authorization as a service</strong></a> provider. We&#39;ll discuss the first two options:</p><h3><strong>1. Building an authorization layer yourself</strong></h3><p>If you choose to create your own authorization layer, you would probably start with a simple inline check:</p><pre><code>function article create_article(user, content) {
   If (user.type == types.writer) {
     …
   } else { return false }
}</code></pre><p></p><img src="https://media.graphcms.com/resize=width:1438,height:723/vCf52GwcQxaGsGxjsuaq" alt="Inline implementation of permissions check" title="Frame 5.png" width="1438" height="723" /><p>Figure 2: Inline implementation of permissions check</p><p><br>Once other methods and classes need to check for permissions, the permission check will move to its own class and your method evolves:</p><pre><code>function article create_article(user, content) {
   if (permissions_service.check(user.role, action.create, article)) {
      …
   } else { return false }
}</code></pre><p><br>A permissions service class will be born, responsible for checking if [role] has permissions to perform [action] on [resource] based on a predefined set of checks:</p><pre><code>class permissions_service {
    function boolean check(role, action, resource) { … }
}</code></pre><p></p><img src="https://media.graphcms.com/resize=width:1521,height:724/Qj81w42TUe8Sbzt5xsIa" alt="Standalone service for permissions check" title="Frame 6.png" width="1521" height="724" /><p>Figure 3: Standalone service for permissions check</p><p><br>The advantages of this approach are:</p><ul><li><div><p><strong>It’s fast and straightforward to start, </strong>and as long as the code is simple, it is easy to extend.</p></div></li><li><div><p>It is easy to <strong>separate the permission logic from the function logic </strong>when things get complex. Once separated, maintaining and developing the permission microservice will not interfere with the logic.</p></div></li></ul><p>Some immediate problems arise when implementing authorization inline:</p><ul><li><div><p>The new microservice is <strong>tightly coupled to our requirements</strong>. As new requirements arise, a refactor will become inevitable.</p></div></li><li><div><p><strong>Policy changes require deployment</strong> and can slow us down. Deploying for every change can become a problem, especially when an authorization-related bug happens on production and requires an immediate solution. Unfortunately, these bugs tend to appear during nighttime or on weekends.</p></div></li><li><div><p>If our codebase includes microservices written in several languages, we must <strong>write and maintain separate wrappers</strong> for accessing the authorization service.</p></div></li></ul><p>Having a standalone microservice to handle authorization requests is a step in the right direction, but not the final step. Before we proceed to the following method, a question arises - </p><p></p><h4><strong>How generic can authorization service be?</strong></h4><p>While roles, actions, and resources are different from one application to another, the evaluation of the authorization rules remains the same -  It answers the question:<strong> </strong></p><h4><strong>is [X] allowed to perform [action Y] on [resource Z]?</strong> </h4><p>Implementation details are not relevant to this question.</p><p>In recent years, several open-source projects for general-purpose policy were created. These open-source projects are taking different implementation approaches for tackling the authorization challenge, including Google Zanzibar and OPA. In this article, we will focus on OPA.</p><p></p><h3><strong>2. Building authorization with OPA</strong></h3><p>OPA (Open Policy Agent) is an open-source project created as a general-purpose policy engine to <strong>serve any policy enforcement requirements without being dependent on implementation details</strong> - it can be used with any language and network protocol, supports any data type, and evaluates and returns answers quickly.</p><p>OPA is very efficient and built for performance - It keeps the policy and data for which it needs to evaluate the rules in the cache, and supports having multiple instances as sidecars to every microservice, thus avoiding network latency.<br><br>OPA’s policy rules are written in Rego - a high-level declarative (Datalog-like) language. Examples of Rego will follow soon.<br><br>Let us implement our create_article method using OPA. In order to keep the code simple to understand, we will use a code level function to wrap OPA’s check for permissions:</p><pre><code>function article create_article(user, content) {
   if (OPA_check(user.role, action.create, article)) {
       …
   } else { return false }
</code></pre><p><br>The function code will look similar to this:<br><br></p><pre><code>function OPA_check(user, action, resource) {
   const input = {
      user: user,
      action: action,
      resource: resource,
    };
    return await this.client.post&lt;OpaResult&gt;(&#39;allow&#39;, input).then((response) =&gt; {
const decision = response.data.allow || false;
return decision;
    }
}</code></pre><p></p><img src="https://media.graphcms.com/resize=width:1568,height:739/iYaAXoOQIKs9w9Be3NwZ" alt="Implementing permissions with OPA" title="Frame 7.png" width="1568" height="739" /><p></p><p>Figure 3: Implementing permissions with OPA</p><p></p><p>The difference lies within the <strong>OPA_check</strong> logic. For OPA to evaluate the rule, it requires Rego code that defines what user is allowed to act. Then, OPA.check triggers the evaluation of the code with our input details, and an immediate answer will return.<br></p><h4><strong>Rego code</strong></h4><p>For policy rules, OPA uses Rego, a high-level declarative language. Rego can be used to write any type of rule, including simple and complex rules with loop, function calls, and more. The Rego code for evaluating the content example will look like this:</p><pre><code>default allow = false
allow = true { 
	input.type == &quot;writer&quot;
    	input.action == &quot;create&quot;
    	input.resource == &quot;article&quot;
}</code></pre><p><br>The Rego code we just created is quite simple yet useful:</p><ul><li><div><p>Initially, we created the identifier ‘<strong>allow’</strong> and set its value to be<strong> ‘false’</strong>. We did this to ensure that the user will not get permissions even if one of our checks fails.</p></div></li><li><div><p>We wrote an inferred ‘if’ clause, represented by the curly brackets. We can read it like that: <strong>allow = true if all rules in the curly brackets are true.</strong></p></div></li><li><div><p>Between the lines in the curly brackets, there is an inferred AND. </p></div></li><li><div><p>To reach the values of the variables, we used the ‘<strong>input</strong>.’ prefix and made a string comparison. You can play with our example in the rego playground <a target='_blank' title="https://play.openpolicyagent.org/p/rNegVVfBRk" href="https://play.openpolicyagent.org/p/rNegVVfBRk"><u>here</u></a>.</p></div></li></ul><p>Rego is rather easy to read. For example, let’s add another user type, ‘<strong>intern’</strong>, that can create an article only if he is permitted (code is <a target='_blank' title="https://play.openpolicyagent.org/p/zLg1mALHSE" href="https://play.openpolicyagent.org/p/zLg1mALHSE"><u>here</u></a>):</p><pre><code>default allow = false
allow { 
    input.user.type == &quot;writer&quot;
    input.user.action == &quot;create&quot;
    input.user.resource.type == &quot;article&quot;
}
allow { 
    input.user.type == &quot;intern&quot;
    input.user.action == &quot;create&quot;
    input.user.resource.type == &quot;article&quot;
    input.user.resource.permitted == &quot;true&quot;
}</code></pre><p><br>In Rego, we implement <strong>‘OR’</strong> by adding another ‘if’ clause that sets <u>the same identifier</u>, ‘<strong>allow’</strong> in our case. Getting this new rule to production can happen without code changes or deployment.</p><p>Rego prefers the policy to be human-readable, even if it looks weird at first. The engine applies performance improvements to keep the rule evaluation fast - some policy rules that require low-latency results are evaluated evaluate in 1 millisecond regardless of their length. You can read more about Rego&#39;s performance <a title="https://www.openpolicyagent.org/docs/latest/policy-performance/" href="https://www.openpolicyagent.org/docs/latest/policy-performance/"><u>here</u></a>.</p><p>The advantages of using OPA as the policy microservice are:</p><ul><li><div><p><strong>OPA is implementation-agnostic</strong> and can support many internet protocols and programming languages simultaneously.</p></div></li><li><div><p>OPA policy code, Rego, <strong>can be changed without deployment</strong>. Moreover, Rego supports both fast and complex policy decisions.</p></div></li><li><div><p>Using Rego means that your policy is handled as code, known as <strong>policy-as-code</strong>. Having policy as code brings additional advantages: a single source of truth, policy versioning, better auditing, a transparent review process for policy changes, and more.</p></div></li><li><div><p><strong>OPA returns results quickly</strong> as OPA stores all the policy and the data it needs in its in-memory cache.</p></div></li><li><div><p>OPA supports ABAC (Attribute-Based Access Control) fine-grained permissions and is not limited to only roles as RBAC (Role-Based Access Control.)</p></div></li></ul><p>Using OPA as the policy engine is not perfect as well. Some of its shortcomings:</p><ul><li><div><p>Some rules rely on real-time user data (i.e., if the user is a subscriber or not). <strong>Real-time policy updates can be very complex to achieve with OPA</strong>.</p></div></li><li><div><p>Rules that rely on multiple data sources require bundling that is not straightforward.</p></div></li></ul><ul><li><div><p>It<strong> </strong>can be <strong>challenging to keep all OPAs in sync when running more than one OPA instance.</strong></p></div></li></ul><p>There are solutions to these shortcomings of OPA in the form of open-source projects (i.e <a title="http://www.opal.ac" href="http://www.opal.ac"><u>OPAL</u></a>, which offers an admin layer on top of OPA and serves real-time updates to OPA).</p><p></p><h2>Summary</h2><p>It can be challenging to create an authorization layer in a cloud environment. While tempting, building the authorization layer yourself will require a lot of time and effort from your team, and still might result in a solution that lacks the support of fundamental features (i.e. multiple language support, distributed architecture, real-time updates, decoupling code from policy, and more). If you go down this path, chances are it will lead you to unreadable code that’s hard to maintain that will eventually require refactoring</p><p>Choosing a generic authorization policy engine will prevent future refactors while providing great flexibility, multiple languages support, decoupling between code and policy, implementation agnostic approach, and high performance.</p><p><a target='_blank' title="http://openpolicyagent.org" href="http://openpolicyagent.org"><u>OPA</u></a>, an open-source CNCF graduate project, is used by many prominent players in the industry, such as Netflix, Pinterest, and Goldman Sachs, and is generic enough to support any policy requests. OPA supports both quick one-millisecond policy evaluations to complex policies that rely on external data sources.</p>]]></content>
        <author>
            <name>Daniel Bass</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Launching Permit.io]]></title>
        <id>announcing-permit</id>
        <link href="https://www.permit.io/blog/announcing-permit"/>
        <updated>2022-02-15T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Launching Permit.io out of stealth - the problem we are here to solve, how we intend to do that, and a little bit on what we think the future holds 🚀]]></summary>
        <content type="html"><![CDATA[<p>Throughout our long (~20 years) careers both Asaf (my awesome co-founder) and I found ourselves constantly rebuilding access control for our products. </p><p>At my previous company Rookout- We ended up rebuilding access control over five times; at every turn, we were met with unexpected demands for more roles, features, performance, compliance, security, and overall complexity.   </p><p>As developers who are passionate about developer tools, we knew that things had to change. Authorization, just like billing, authentication, and databases - is not something one should be building from scratch.</p><p>We realized this was a unique point in time where multiple events intersected to create the opportunity that is now Permit.io possible. The explosion of microservices combined with the growing maturity of DevSecOps and authentication (with standards like JWTs) have set the stage for the next step in the <a title="https://www.permit.io/blog/what-is-authorization#The%20IAM%20Waterfall" href="https://www.permit.io/blog/what-is-authorization#The%20IAM%20Waterfall"><u>IAM waterfall</u></a> - <strong>fullstack authorization and permissions</strong>.</p><p></p><h2>Fullstack Permissions</h2><p>As the space evolves, trends, <a title="https://www.permit.io/blog/5-best-practices-for-building-cloud-native-permissions" href="https://www.permit.io/blog/5-best-practices-for-building-cloud-native-permissions"><u>best practices</u></a>, and open-source standards (e.g. OPA, <a title="https://github.com/permitio/opal" href="https://github.com/permitio/opal"><u>OPAL</u></a>) began to emerge. At Permit we adopt and support these, being strong believers in decoupling policy and code. We also understand that it is not only about decoupling the technology - developers and their fellow stakeholders need end-to-end experiences. Access is the most critical experience of any product - and everyone needs to be able to affect and take part in it. <br><br>Fullstack permissions mean empowering developers and users, it means adding UI and low-code next to deep-code and APIs, and most importantly it means you can trust us to make authorization work for you, exactly how you want it -  and not just throw some APIs your way. </p><p></p><h2>An Interconnected Future </h2><p>While a major part of our story is about making developers’ life better - we also note that’s just the beginning, as glimpses of the future through companies like Facebook and Google hint at even greater complexities around the corner.<br>With more and more applications being used by other applications rather than by human users (Think of Apple’s Siri triggering IFFT to turn on your Xiamoi smart light-bulb), and machine learning agents on the rise, it is clear the matrix of access is only getting more complex.</p><p>And as more and more things become interconnected more rapidly, only by creating new standards for authorization, and layering artificial intelligence on top, will we be able to keep up with the needed pace.</p><p></p><h2>The beginning of an amazing journey</h2><p><a title="https://techcrunch.com/2022/02/15/permit-io-raises-6m-to-make-permissions-easier/" href="https://techcrunch.com/2022/02/15/permit-io-raises-6m-to-make-permissions-easier/">Today we’re excited to launch Permit.io out of stealth mode</a>, with the support of our amazing investors NFX and Rainfall, as well a long list of angels and advisors - all coming from the developer-tools space. <br>Our growing team is already supporting a large open-source project and SaaS service- running in the production environments of industry leaders. And is eager to bring permissions to support the future of software and the internet as an interconnected whole.</p>]]></content>
        <author>
            <name>Or Weis</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Authorization is changing - how we can harness the benefits?]]></title>
        <id>authorization-is-changing</id>
        <link href="https://www.permit.io/blog/authorization-is-changing"/>
        <updated>2022-02-13T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[What changed, both in terms of the challenges and the solutions, and how we can adapt to these changes?]]></summary>
        <content type="html"><![CDATA[<p>The landscape of authorization has changed drastically in the last few years - Today’s applications require complex authorization systems and call for well-designed, adaptive solutions. In this post we will try to answer what changed, both in terms of the challenges and the solutions, and how we can adapt to these changes.<br><br>Before we dive into this - let’s establish the space that we&#39;re going to be discussing:</p><h2><strong>The IAM landscape</strong></h2><p><strong>IAM </strong>(Identity Access Management) is composed of three separate parts: <strong>Identity management</strong>,<strong> Authentication </strong>(AuthN),<strong> </strong>and <strong>Authorization</strong> (AuthZ). </p><ul><li><div><strong>Identity management</strong><br>Identity management is about being able to tell who׳s part of your organization, what attributes they have, and which departments they belong to. This allows you to <strong>create identities </strong>that can be aggregated and managed in a unified interface.</div></li></ul><ul><li><div><strong>Authentication</strong><br>Authentication is all about <strong>verifying the identity</strong> of the person connecting to your product. These are designated to monitor who has access to the product itself. </div></li></ul><ul><li><div><strong>Authorization</strong><br>Once a user has logged in to the product, authorization handles deciding <strong>who </strong>can do <strong>what </strong>and in <strong>what context </strong>within the product.</div></li></ul><p><br>As you can see, each stage relies on information gathered from the previous one. ⁠A more detailed introduction to the IAM waterfall can be found <a title="https://www.permit.io/blog/what-is-authorization" href="https://www.permit.io/blog/what-is-authorization"><u>here</u></a>. </p><p></p><h2><strong>Building (and re-building) authorization </strong></h2><p>Up until recently, developers have mostly been building authorization by themselves from scratch. As a developer, you might think - <br><br>“Ok, so I’ll start off with two types of users: Admin, and non-admin, and make decisions based on this distinction”.</p><p>Then, a user comes in and asks you to create an editor role.<br>So you rebuild your authorization system to allow an editor role. </p><p>Later, stakeholders from your company ask you for access to audit logs, and the ability to monitor them on their side.<br>So you rebuild your authorization system to allow that as well. </p><p>Then sales approach you and ask you to create an impersonation tool that allows them to see the system from a different perspective. <br>And you rebuild again.<br><br>Another stakeholder asks you for their own back-office that will allow them to manage new users they onboard into the system. </p><p>You see where we’re going with this. </p><p></p><img src="https://media.graphcms.com/RmpPbdZoQwia5vHy5rkx" alt="circle of pain.png" title="circle of pain.png" width="1874" height="1860" /><p><br>As your product evolves, building authorization yourself requires you to keep rebuilding it time after time to adapt it. From the very beginning, you have to ask yourself - Who can access my application, work with it at the infrastructure level, manage it as the developer, or work with it as a user?  The answer to this question will help you determine how complex the authorization building process will be.</p><p></p><h2><strong>How microservices changed AuthZ</strong></h2><p>If you look at this issue in the context of the emergence of microservices, it becomes even more complicated. When you built a monolith application, you had the ability to bake in the decision-making process of who connects to what within the application into just one place - usually by using a  specific framework such as Spring, Django, or Python. As you start breaking an application into multiple services, you end up having to replicate the authorization code across each and every microservice. And each time you want to restructure, change something, or add another feature, you have to do it in each microservice separately. </p><p>The rising demand for increasingly advanced authorization, the rising complexity of the applications themselves, and their migration to microservices and cloud-native structures magnified the pain of building authorization into the application itself. </p><p>The good news is that the field of authorization is adapting, and new solutions to resolve these issues are beginning to develop. These become available now thanks to the overall evolution of the cloud space, both in technology and mindset. </p><p></p><h2><strong>Rethinking services, new technology, and a shift-left midset.</strong></h2><p>There have been a couple of major developments that allow us to view authorization differently: An <strong>advancement in technology</strong>, a <strong>change of approach towards microservices</strong>, and the emergence of <strong>shift-left</strong> and <strong>low/no-code developers</strong>. </p><p>In terms of <strong>technology</strong>, to create significant changes in authorization we needed the previous layers - identity management and authentication to be working well. Until we had SAML and SSO connect between identity management and authentication, that entire area wasn&#39;t stable enough to build upon. The maturity of those standards enabled the entire Authentication space to blossom almost a decade ago, and now again with Passwordless. Before we had standards like the JSON Web Token in the authentication layer, it was basically impossible to connect to it in a standardized way. JSON Web Tokens (JWT), which only became mature in recent years, are a great way to communicate from the authentication layer into the application, and specifically into the authorization layer. <br><br>The authentication process ends when the JWT is handed to the application - specifically, to the authorization layer within it. While the authentication layer provides claims that affect the access policy, it&#39;s still up to the authorization layer to translate and enforce those claims based on the JWT and, often, additional context data. </p><p>In terms of thinking about <strong>services</strong>, if you go back five years, people were still thinking things like billing, authentication, or databases, being core and critical, require developers to implement them themselves. Thanks to companies like Stripe, Auth0, and MongoDB, developers have realized how complex these issues are, and how problematic it is to try and build them yourself. Thus, a mindset of adopting critical services as part of an application you&#39;re building became legitimate. Moreover - it became a consensus that you<strong> have to</strong> adapt these kinds of solutions since the risk of making mistakes when trying to build them yourself just isn’t worth it. </p><p>The overall trend of <strong>shift-left</strong>, which has been discussed in the security sphere <em>ad nauseam</em>, and the increasing number of people who are becoming <strong>low/no-code</strong> developers (eg. product, security, compliance) makes it critical for us to enable them to work on such fundamental experiences as access control. </p><p>So what can be done about this?</p><p></p><h2><strong>Modern authorization, finally. </strong></h2><p>This new reality has created an understanding that new solutions to resolve these issues should be built. Thankfully, the developer community has started creating these solutions with open source projects (e.g. <a title="https://www.permit.io/blog/introduction-to-opa" href="https://www.permit.io/blog/introduction-to-opa"><u>OPA</u></a>, <a title="https://www.permit.io/blog/introduction-to-opal" href="https://www.permit.io/blog/introduction-to-opal"><u>OPAL</u></a>). This way, you can adopt them as building blocks into your application without paying anything, and more importantly, they allow you to implement practices that prevent you from repeating the mistakes of the past. </p><p>The most important matter here is that while building applications, we <strong>understand the complexities</strong> that come with creating a functional authorization layer, and <a title="https://www.permit.io/blog/5-best-practices-for-building-cloud-native-permissions" href="https://www.permit.io/blog/5-best-practices-for-building-cloud-native-permissions"><u><strong>the best practices </strong></u></a>that should be implemented while building it in order to avoid constantly having to rebuild them.</p><p>There are already<strong> good ready-made solutions</strong> (e.g. <a title="https://www.permit.io/" href="https://www.permit.io/"><u>Permit.io)</u></a>  out there - as open-source or as services that you can build upon while avoiding common mistakes. You can also approach this by building it yourself,  but if you choose to do so, you have to do it right.</p><p></p><h2><strong>Summary </strong></h2><p>The drastic changes in the landscape of authorization over the last few years make it necessary for us to change our mindset and adopt new best practices in order to avoid constantly rebuilding authorization. The advancement in technology, a change of approach towards microservices, and the emergence of shift-left and low/no-code developers created an environment in which we can adopt existing solutions and use them as building blocks for our applications.</p>]]></content>
        <author>
            <name>Daniel Bass</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[A Guide for an Awesome Custom Auth0 Universal login]]></title>
        <id>custom-auth0-universal-login</id>
        <link href="https://www.permit.io/blog/custom-auth0-universal-login"/>
        <updated>2022-01-24T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[A complete step by step guide to fully customize the auth0 login screen]]></summary>
        <content type="html"><![CDATA[<p>Your login and sign-up screens are the gateway to your app - the first thing a person sees before entering your actual application. So, they better look amazing, if you want an awesome app.</p><p>While creating our own login screen at Permit.io, I had to review and collect data from multiple different guides, so I finally decided to incorporate them into one unified guide that will help you transform your own login screen completely.<br><br>In this guide, we will cover:</p><ul><li><div><p><a title="#5_reasons" href="#5_reasons">5 reasons why you should customize the default Auth0 login</a></p></div></li><li><div><p><a title="#editing_login" href="#editing_login">How to edit the default Auth0 login template</a></p></div></li><li><div><p><a title="#edit_default_title" href="#edit_default_title">How to edit the Auth0 default title and description</a></p></div></li><li><div><p><a title="#unavailable" href="#unavailable">Which customization features are yet to be available</a></p></div></li></ul><p>Using Auth0 authentication has its advantages - It’s fast, secure, and highly functional. </p><p>That being said, you can’t have the first thing your user sees when entering your app look like this: </p><img src="https://media.graphcms.com/AwkBGsrCStaWcndv8M9B" alt="unnamed (1).png" title="unnamed (1).png" width="484" height="279" /><h2>5 reasons why you should customize the default Auth0 login -</h2><p>While functional, using the default Auth0 login screen has some key issues:</p><ul><li><div><p>While the login / sign-up screen is a crucial step in a user’s onboarding process, the default Auth0 login screen lacks some important elements - The company name is there, but <strong>the overall look is different</strong>. This makes the login screen seem like a <strong>foreign entity inside your application</strong>. And that’s not a good user experience. </p></div></li></ul><ul><li><div><p>The default option Auth0 provides in login through an <strong>external domain</strong> that belongs to Auth0, meaning each time someone wants to log in to use your application they are <strong>redirected to a domain outside that of your company</strong>. Your users might have no idea what Auth0 is, or why they are referred to this external website to provide their login information. This looks both unprofessional and unsecure. </p></div></li><li><div><p>This sense of unfamiliarity creates another issue: because the login screen doesn’t look like the rest of your company’s user interface, and it is based on a domain outside your company, <strong>it can be easily </strong><a title="https://auth0.com/blog/phishing-attacks-with-auth0-facts-first/" href="https://auth0.com/blog/phishing-attacks-with-auth0-facts-first/"><u><strong>interpreted by the user as a phishing attack</strong></u></a>.</p></div></li><li><div><p>The message displayed reads: “Log in to ‘Company Name’ to continue to ‘Application Name’”. Not only is this not the most inviting message, changing it is no trivial task (As we will see later on).</p></div></li><li><div><p>The login interface uses only a small percentage of your screen, the rest of it being just one color, making it look quite dull and uninviting on one of the most important screens in your entire app. </p></div></li></ul><p>While the good news is that most of these features are customizable, the bad news is that implementing these customizations is no easy feat, and far from intuitive. Hence this guide 😉</p><h2>What can we do about this?</h2><p>Overcoming these issues took me a while, but we were very pleased with the end result:</p><p></p><img src="https://media.graphcms.com/ZjHmV6eQq6tE1k9U88I9" alt="Component 1.png" title="Component 1.png" width="1000" height="783" /><p><br><strong>So how did we get here?</strong> Let’s review the steps:</p><h2>1. Enabling custom domains</h2><p>As we have stated before, having your login/signup based in a domain outside your company creates various issues. Apart from that, <strong>Auth0 only allows you to customize your login screen by using a custom domain</strong> - which is a paid feature. </p><p>To do this - </p><ul><li><div><p>Choose the correct tenant (most likely production).</p></div></li><li><div><p>In the left sidebar go to <strong>Branding </strong>&gt; <strong>Custom Domains</strong>.<br>(If you haven’t upgraded your plan to include custom domain support, you will need to do that first).</p></div></li></ul><img src="https://media.graphcms.com/resize=width:1600,height:433/KALBkGnhR26nzQkcA8U1" alt="Custom Domain" title="unnamed (2).png" width="1600" height="433" /><ul><li><div>Approve your custom domain through the instructions provided by Auth0 to prove that you actually own it (This includes adding some TXT entries to the domain).</div></li></ul><ul><li><div><p>This is what an approved custom domain should look like (notice the <strong>ready </strong>status):</p></div></li></ul><img src="https://media.graphcms.com/resize=width:1042,height:465/m2ssMbRJRwCIpFU5Ki1C" alt="Custom Domain Enabled" title="unnamed (3).png" width="1042" height="465" /><h2>2. Editing the login template</h2><p>Now that we have a custom domain, we can get to editing the login screen itself. </p><p>If you check out <a title="https://auth0.com/docs/brand-and-customize/universal-login-page-templates" href="https://auth0.com/docs/brand-and-customize/universal-login-page-templates"><u>Auth0’s documentation</u> </a>you will notice they suggest using <strong>POST requests</strong> to update the template. This means posting all of the code for the entire page every time we want to make the smallest of changes. That can be a huge hassle. </p><p>To overcome this issue, I used <a title="https://github.com/auth0/auth0-cli" href="https://github.com/auth0/auth0-cli"><u><strong>Auth0 CLI</strong></u></a><strong> </strong>(That’s still in beta, but works *almost* perfectly) which utilizes <a title="https://storybook.js.org/" href="https://storybook.js.org/"><u><strong>Storybook</strong></u></a>. Auth0 CLI<strong> </strong>allows you to edit the login template from your code editor while previewing those changes in Storybook <strong>as you go along</strong>. </p><p><strong>How to do this:</strong></p><ul><li><div><p>Download Auth0 CLI:<br><br>On Mac: </p><pre><code>[brew tap auth0/auth0-cli &amp;&amp; brew install auth0]</code></pre><p>On Linux:</p><pre><code>[brew tap auth0/auth0-cli &amp;&amp; brew install auth0]</code></pre><p>On windows (With Scoop):</p><pre><code>[scoop bucket add auth0 https://github.com/auth0/scoop-auth0-cli.git 
⁠scoop install auth0]</code></pre><p>Check <a title="https://github.com/auth0/auth0-cli" href="https://github.com/auth0/auth0-cli"><u>this link</u></a> for more options.</p></div></li></ul><ul><li><div><p>Login to your account using the following command: <br><br><code>auth0 login</code></p></div></li><li><div><p>Run the following command: <br><br><code>auth0 universal-login templates update</code></p></div></li><li><div><p>This will open your default code editor (I recommend <a title="https://stackoverflow.com/a/36644561/1037613" href="https://stackoverflow.com/a/36644561/1037613"><u>setting VSCode as your default editor</u></a>), and a Storybook window in your browser, previewing the current state of your login screen. </p></div></li><li><div><p>When you make changes in your code editor, you see them updated live in the Storybook preview window. </p><img src="https://media.graphcms.com/resize=width:1600,height:688/ltOFZwPJTBugFuSR1Ghq" alt="StoryBook Preview" title="unnamed (4).png" width="1600" height="688" /></div></li></ul><p><em>                                       This is how the StoryBook preview looks like</em></p><ul><li><div><p>Remember to add <code>{%- auth0:head -%}</code> in the HTML head tag <br>and <code>{%- auth0:widget -%}</code> where you want the Auth0 widget to be injected. <br><br>This is an example of a basic template that displays the Auth0 login:</p><pre><code>⁠html
&lt;!DOCTYPE html&gt;&lt;html&gt;
  &lt;head&gt;
    {%- auth0:head -%}
  &lt;/head&gt;
  &lt;body&gt;
    {%- auth0:widget -%}
  &lt;/body&gt;&lt;/html&gt;</code></pre></div></li><li><div><p>When you close the editor, Auth0 CLI will ask you if you want to update the login template. </p><img src="https://media.graphcms.com/resize=width:1406,height:114/LsfcaEhXSRZt9VQtayWQ" alt="Update Login Template" title="unnamed (5).png" width="1406" height="114" /></div></li></ul><ul><li><div><strong>Approve, and you’re done!</strong> <br></div></li></ul><h3>Important note:</h3><p>The authentication widget previewed on Storybook is <strong>not identical</strong> to the actual one that is going to appear on your website. These could also display a bit differently on mobile/different screens - so make sure to <strong>recheck everything in your real environment after updating your template</strong>. </p><p><strong></strong></p><img src="https://media.graphcms.com/resize=width:793,height:693/7oy1fic2Rw6v605ydN00" alt="Versus" title="Component 4.png" width="793" height="693" /><p><em>                     Note the Storybook preview (Left) vs. the actual version (right). <br></em></p><h2>3. Editing Auth0 widget default title and description</h2><p><u><strong>⁠</strong></u>In this part, I’ll explain how to change the default text templates provided in the Auth0 login screen through API management. The default text will look like this:</p><h6>Log in to `Company Name’ to continue to ‘Application Name’<br><strong>To do this:</strong></h6><ul><li><div><p>First, you will need to get your API management token: Go to <strong> Applications</strong> &gt; <strong>APIs</strong>, click on <strong>Auth0 Management API</strong>. Go to the <strong>API Explorer</strong> tag, and copy the token by clicking the copy icon on the right. </p><img src="https://media.graphcms.com/output=format:jpg/output=format:png/resize=width:32,height:35/2JpxJDWORluMTpWGEnCK" alt="Copy" title="unnamed (8).png" width="32" height="35" /><p></p><img src="https://media.graphcms.com/resize=width:1060,height:200/rBYXfW6aRM6BJDTdfG4w" alt="APIs" title="unnamed (9).png" width="1060" height="200" /></div></li></ul><p><br></p><img src="https://media.graphcms.com/resize=width:1077,height:386/oCXZ5rwS42zNSXZnXA7G" alt="Token" title="unnamed (10).png" width="1077" height="386" /><p></p><ul><li><div><p>Go to the <a title="https://auth0.com/docs/brand-and-customize/text-customization-new-universal-login/prompt-login" href="https://auth0.com/docs/brand-and-customize/text-customization-new-universal-login/prompt-login"><u>Auth0 “prompt: login” Documentation</u></a>, and get the names of the strings you want to change. For example, the key for the following login screen string:<br><br><code>Log in to ${companyName} to continue to ${clientName}</code><br><br>Is <code>description</code>.</p></div></li><li><div><p>Go to “Set custom text for a specific prompt” in <a title="https://auth0.com/docs/api/management/v2#!/Prompts/put_custom_text_by_language" href="https://auth0.com/docs/api/management/v2#!/Prompts/put_custom_text_by_language"><u>Auth0’s API management docs</u></a>.</p></div></li><li><div><p>On the top left side of the screen, click “<strong>Set API Token</strong>”, and paste the API token you copied. </p><img src="https://media.graphcms.com/YE7bnIGQYigFkOyotEVh" alt="unnamed (11).png" title="unnamed (11).png" width="184" height="57" /></div></li></ul><ul><li><div>Select the prompt you would like to make changes to (in our case: login)</div></li></ul><ul><li><div><p>Select the language (in our case: EN - English)</p></div></li><li><div><p>Under “body” - add all of the changes you wish to make in this prompt (in our case: description and title) </p></div></li></ul><img src="https://media.graphcms.com/resize=width:748,height:792/doYpD4L8R0ivVjxwciqI" alt="Custom Text" title="unnamed (12).png" width="748" height="792" /><p><strong>NOTE</strong>: If you want to change more than one prompt, you have to make both changes first, and then <strong>save them together</strong>. If you do them separately <strong>the first will revert to its original state</strong>.</p><ul><li><div><p>Click <strong>TRY </strong>to save your changes.</p></div></li></ul><img src="https://media.graphcms.com/resize=width:328,height:120/JspS44uiRqJS6L3Onehv" alt="Try" title="unnamed (13).png" width="328" height="120" /><p>You may want to repeat this process to edit your signup widget as well. To do this, locate the text you want to change <a title="https://auth0.com/docs/brand-and-customize/text-customization-new-universal-login/prompt-signup" href="https://auth0.com/docs/brand-and-customize/text-customization-new-universal-login/prompt-signup"><u>here</u></a>, and repeat the process while choosing <strong>signup </strong>instead of <strong>login <br></strong>in all the steps.</p><p></p><h2>4. Things you cannot do with Auth0 universal login</h2><p>As of the writing of this guide, a feature to <strong>change the login widget to request the user to repeat the password on signup </strong>is not yet available. <a title="https://github.com/auth0/lock/issues/61" href="https://github.com/auth0/lock/issues/61"><u>A GitHub issue for this</u></a> has been open since 2014, yet no relevant action was taken.</p><p><strong>I hope this guide enabled you to set up your own authentication via Auth0. </strong><br><br>Usually, once you have authentication set up, the next step is to do authorization!<br>Check this guide to <a title="https://www.permit.io/blog/add-rbac-authorization-to-auth0" href="https://www.permit.io/blog/add-rbac-authorization-to-auth0">adding RBAC authorization to Auth0</a>, or go to <a title="https://permit.io" href="https://permit.io"><u>Permit.io</u></a> to learn more about getting permissions as a service.<br><br>Got any other questions about Authentication or Authorization? <a title="https://io.permit.io/permitslack" href="https://io.permit.io/permitslack">Join our Slack Community</a>!</p><p>You can check out our own template <a title="https://gist.github.com/obsd/9f05d322a03f47d54b302754e9e000df" href="https://gist.github.com/obsd/9f05d322a03f47d54b302754e9e000df">on GitHub</a>.</p>]]></content>
        <author>
            <name>Oded Ben David</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[How to Implement Attribute Based Access Control (ABAC) using Open Policy Agent (OPA)]]></title>
        <id>implement-abac-using-opa</id>
        <link href="https://www.permit.io/blog/implement-abac-using-opa"/>
        <updated>2022-01-17T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[The Bikini Bottom guide to ABAC authorization models and their implementation with OPA]]></summary>
        <content type="html"><![CDATA[<p>Building authorization can be a complicated endeavor. There are different models for building authorization and different ways of implementing them. At the end of the day, only one thing matters - we want the <strong>right person</strong> to have the <strong>right access</strong> to the <strong>right asset</strong>. </p><p>For this purpose, we want to review a couple of <strong>authorization models</strong> (ABAC and RBAC), and then explain how (and why) you should implement them using <a title="https://www.permit.io/blog/introduction-to-opa" href="https://www.permit.io/blog/introduction-to-opa">Open Policy Agent (OPA)</a> - which allows you to create a separate microservice for authorization, decoupling our policy from our code.<br></p><h2><u>So why ABAC and RBAC?</u></h2><p><a title="https://www.permit.io/blog/rbac-with-permit" href="https://www.permit.io/blog/rbac-with-permit">RBAC </a>and <a title="https://www.permit.io/blog/what-is-abac" href="https://www.permit.io/blog/what-is-abac">ABAC</a> are the two most basic and commonly used authorization models, and they provide the baseline for most other complex and specific ones. Let’s start by getting to know them a little better:<br></p><h2><u>What is RBAC?</u></h2><p>Role-based access control (RBAC), is an authorization model used to determine access control based on <strong>predefined roles</strong>. Permissions are assigned onto roles (Like “Admin or “User”), and roles are assigned to users by the administrator. This structure allows you to easily understand who has access to what. </p><p>The combination of three elements - <strong>who </strong>(What role are they assigned?) can do <strong>what </strong>(What actions are they allowed to perform) with a <strong>resource </strong>(Which resources) is called a <strong>policy</strong>.</p><p>⁠<a title="https://www.permit.io/blog/implement-rbac-using-opa" href="https://www.permit.io/blog/implement-rbac-using-opa"><u><strong>You can also check out our tutorial on implementing RBAC in OPA</strong></u></a><br></p><h2><u>What is ABAC?</u></h2><p><a title="https://www.permit.io/blog/what-is-abac" href="https://www.permit.io/blog/what-is-abac">ABAC (Attribute-based access control)</a>, determines access based on a set of characteristics called “<strong>attributes</strong>”, rather than roles. Attributes include parameters such as a user’s role, security clearance, time of access, current time, location of the data, current organizational threat levels, resource creation date or ownership, data sensitivity, etc.</p><p>It&#39;s important to note that the attributes examined in ABAC are not just the user&#39;s - but of the accessed resource, the overall system, and anything else that is relevant in this context.</p><p>ABAC-based policies are based on a combination of four elements: <strong>who </strong>(The identity of the user) can do <strong>what </strong>(What actions are they allowed to perform) with a <strong>resource </strong>(Which resources) <strong>in what context</strong> (What are the circumstances required for the action to be performed).</p><h2><u>RBAC VS ABAC</u></h2><p>The choice between RBAC and ABAC depends on the needs of your organization -</p><p>RBAC provides a rather simple solution for determining authorization. Having evolved from RBAC, ABAC provides a more in-depth approach for authorization needed in order to prevent unauthorized access. While requiring more processing power and time, ABAC provides a more complex and detailed authorization method factoring a much greater number of variables.</p><p>In many cases, RBAC and ABAC can be used together hierarchically, with broad access enforced by RBAC protocols and more complex access managed by ABAC. That being said, it is important to choose relevant authorization methods tailored to your organization’s needs - so the authorization process is neither too simplistic nor too complex.</p><p>⁠You can learn more about the decision between RBAC and ABAC <a title="https://www.permit.io/blog/rbac-vs-abac" href="https://www.permit.io/blog/rbac-vs-abac">here</a>.</p><p>For the purpose of this post, we’ll assume you decided you want to set up your policies with ABAC. </p><h2><u>The challenge of setting up policies with ABAC </u></h2><p>In case you decide to set up your policies using ABAC, it is important to note the challenges you’ll have to face along the way: </p><p>The set of policies for each individual service has to be manually set up inside the service itself. This can be kind of a pain to do - as the amount of policies, users, and services grows, updating them in each relevant service becomes super tedious and time-consuming. Not only that, but considering policies change all the time - they have to be at least somewhat fluid. </p><p>Another issue can come from having the code of the authorization layer mixed in with the code of the application itself. This creates a situation where we struggle to upgrade, add capabilities, and monitor the code as it is replicated between different microservices. Each change would require us to refactor large areas of code that only drift further from one another as these microservices develop. </p><p><strong>So how can we solve these challenges?</strong></p><img src="https://media.graphcms.com/a8OkdWBqT3SqSKs0MWVO" alt="Plankton safe.gif" title="VGqn.gif" width="480" height="380" /><p><br>By creating a <strong>separate microservice for authorization</strong>, thus <strong>decoupling our policy from our code</strong>. Controlling access management centrally through a separate authorization service allows you to offer it as a service to every system that needs to check whether a user can or cannot access its resources. This can be done by using <a title="https://www.permit.io/blog/introduction-to-opa" href="https://www.permit.io/blog/introduction-to-opa">Open Policy Agent (OPA)</a>. <br></p><h2><u>What OPA gives us?</u></h2><ul><li><div>OPA unifies all policies across each individual service in one server.</div></li></ul><ul><li><div><p>Takes on the role of policy decision-making and enforcement from the service: The service queries OPA, OPA makes a decision and sends an output to the service, the service acts according to OPA’s reply. </p></div></li><li><div><p>It allows you to have a policy as code, that can be easily reviewed, edited, and rolled back.</p></div></li></ul><p>While we have a centralized authorization solution, the enforcement itself is still distributed - We have an OPA agent next to every microservice, providing decisions and enforcement with near-zero network latency. The OPA agents are distributed and can grow as the services scales. </p><img src="https://media.graphcms.com/TpsnHzIQSyKND0CiV4Lq" alt="Spongebob door.gif" title="RoHu.gif" width="480" height="306" /><p></p><h2>How to implement ABAC in OPA?</h2><p>With attribute-based access control, you make policy decisions using the attributes of <strong>users</strong>, <strong>objects</strong>, and <strong>actions</strong> involved in the request. For this, we need three types of information:</p><ul><li><div>Attributes for <strong>users</strong></div></li></ul><ul><li><div><p>Attributes for <strong>objects</strong></p></div></li><li><div><p>Logic dictating <strong>which attribute combinations are authorized</strong></p></div></li></ul><p>For example, let’s take the following attributes for our users:</p><p><code>Squid</code>:</p><ul><li><div>Joined the company 10 years ago</div></li><li><div>Is a cashier</div></li></ul><p><code>Pat</code>:</p><ul><li><div>Joined the company 6 months ago</div></li><li><div>Is a cashier </div></li></ul><p>We would also have attributes for the objects, in this case, menu items:</p><p><code>Burger</code>:</p><ul><li><div>Is sold on the menu</div></li><li><div>Costs 3$</div></li></ul><p><code>Shake</code>: </p><ul><li><div>Is sold on the menu</div></li><li><div>Costs 1$</div></li></ul><p>If we try and write up an example ABAC policy in English, it will look like this:</p><ul><li><div>Cashiers may process orders of up to 1$ total. </div></li><li><div>Cashiers with more than 1 year of experience may process orders of up to 10$ total. </div></li></ul><img src="https://media.graphcms.com/resize=width:990,height:650/RJvVphKCTeGhhxDukSFw" alt="Patrick phone.jpg" title="b057633c9701a8e2382f3ef8b17c7123.jpg" width="990" height="650" /><p><br>OPA supports ABAC policies as shown below:</p><pre><code>package abac

# User attributes
user_attributes := {
    &quot;Squid&quot;: {&quot;tenure&quot;: 10, &quot;title&quot;: &quot;cashier&quot;},
    &quot;Pat&quot;: {&quot;tenure&quot;: 0.5, &quot;title&quot;: &quot;cashier&quot;}
}

# Menu attributes
menu_attributes := {
    &quot;Burger&quot;: {&quot;items&quot;: &quot;Menu&quot;, &quot;price&quot;: 3},
    &quot;Shake&quot;: {&quot;items&quot;: &quot;Menu&quot;, &quot;price&quot;: 1}
}

default allow = false

# All cashiers may process orders of up to 1$ total
allow {
    # Lookup the user&#39;s attributes
    user := user_attributes[input.user]
    # Check that the user is a cashier
    user.title == &quot;cashier&quot;
    # Check that the item being sold is on the menu
    menu_attributes[input.ticker].items == &quot;Menu&quot;
    # Check that the processed amount is under 1$
    input.amount &lt;= 1

}

# Cashiers with 1=&gt; year of experience may ⁠process orders of up to 10$ total.
allow {
   # Lookup the user&#39;s attributes
    user := user_attributes[input.user]
    # Check that the user is a cashier
    user.title == &quot;cashier&quot;
    # Check that the item being sold is on the menu
    menu_attributes[input.ticker].items == &quot;Menu&quot;
    # Check that the user has at least 1 year of experience
    user.tenure &gt; 1
    # Check that the processed amount is under is under $10
    input.amount &lt;= 10
}</code></pre><p>⁠Now let’s review the following input:</p><pre><code>{
  &quot;user&quot;: &quot;Squid&quot;,
  &quot;menu&quot;: &quot;Burger&quot;,
  &quot;action&quot;: &quot;sell&quot;,
  &quot;amount&quot;: 2
}</code></pre><p><br>Querying the allow rule with the input above returns the following answer: <code>True</code>.</p><p></p><img src="https://media.graphcms.com/LQ1x92q3Rc6xdWC8olES" alt="Patrick board.gif" title="giphy.gif" width="540" height="304" /><p><strong><br>Congrats! You have successfully implemented ABAC in OPA! </strong><br><br>Let’s do a quick review of what we learned:</p><ul><li><div><strong>RBAC </strong>is an authorization model based on <strong>predefined roles</strong>, while <strong>ABAC </strong>determines access based on a set of characteristics called “<strong>attributes</strong>”. </div></li></ul><ul><li><div>While RBAC provides a rather simple solution for determining authorization that fits most organizations, ABAC is a more complex and detailed authorization method factoring in a much greater number of variables.</div></li></ul><ul><li><div>It is important to choose an authorization model that fits your organization&#39;s needs, so it’s <strong>neither too simple nor too complex</strong>.</div></li></ul><ul><li><div>The main challenges of setting up policies with RBAC are the requirement to manually set up the set of policies for each individual service, and having the code of the authorization layer mixed in with the code of the application itself. <strong>Both can be solved by using OPA</strong>.</div></li></ul><ul><li><div>OPA solves these issues by <strong>unifying all policies</strong> in one server, <strong>taking on the role of policy decision-making and enforcement</strong> from the service, and allowing you to manage <strong>policy as code</strong>. </div></li></ul><ul><li><div>We saw an example of how to <strong>successfully implement ABAC in OPA</strong> :)</div></li></ul><p>⁠Want to learn more? Join our ⁠<a title="https://io.permit.io/permitslack" href="https://io.permit.io/permitslack"><u>Slack channel</u></a> to ask questions and talk about authorization.</p>]]></content>
        <author>
            <name>Daniel Bass</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[How to Implement Role Based Access Control (RBAC) using Open Policy Agent (OPA)]]></title>
        <id>implement-rbac-using-opa</id>
        <link href="https://www.permit.io/blog/implement-rbac-using-opa"/>
        <updated>2022-01-11T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[The Bikini Bottom guide to RBAC authorization models and their implementation with OPA]]></summary>
        <content type="html"><![CDATA[<p>Building authorization can be a complicated endeavor. There are different models for building authorization and different ways of implementing them. At the end of the day, only one thing matters - we want the <strong>right person</strong> to have the <strong>right access</strong> to the <strong>right thing</strong>. </p><p>For this purpose, we want to review a couple of <strong>authorization models</strong> (RBAC and ABAC), and then explain how (and why) you should implement them using <a title="https://www.permit.io/blog/introduction-to-opa" href="https://www.permit.io/blog/introduction-to-opa">Open Policy Agent (OPA)</a> - which allows you to create a separate microservice for authorization, decoupling our policy from our code.</p><p></p><h2><u>So why RBAC and ABAC?</u></h2><p>RBAC and ABAC are the two most basic and commonly used authorization models, and they provide the baseline for most other complex and specific ones. Let’s start by getting to know them a little better:<br></p><h2><u>What is RBAC?</u></h2><p>Role-based access control (RBAC), is an authorization model used to determine access control based on <strong>predefined roles</strong>. Permissions are assigned onto roles (Like “Admin or “User”), and roles are assigned to users by the administrator. This structure allows you to easily understand who has access to what. </p><p>The combination of <strong>who </strong>(What role are they assigned?) can do <strong>what </strong>(What actions are they allowed to perform) with a <strong>resource </strong>(On which resources) is called a <strong>policy</strong>.<br></p><h2><u>What is ABAC?</u></h2><p>ABAC (Attribute-based access control), determines access based on a set of characteristics called “<strong>attributes</strong>”. Attributes include parameters such as a user’s role, security clearance, time of access, location of the data, current organizational threat levels, resource creation date or ownership, data sensitivity, etc.<br><br>You can learn more ABAC <a title="https://www.permit.io/blog/what-is-abac" href="https://www.permit.io/blog/what-is-abac">here</a>.<br><br><a title="https://www.permit.io/blog/implement-abac-using-opa" href="https://www.permit.io/blog/implement-abac-using-opa"><u><strong>Check out our tutorial on implementing ABAC in OPA</strong></u></a></p><p></p><h2><u>RBAC VS ABAC</u></h2><p>The choice between RBAC and ABAC depends on the needs of your organization -</p><p>RBAC provides a rather simple solution for determining authorization and is usually sufficient for most organizations. In some cases, a more in-depth approach for authorization is needed in order to prevent unauthorized access - This is where ABAC comes in. While requiring more processing power and time, ABAC provides a more complex and detailed authorization method factoring a much greater number of variables.</p><p>In many cases, RBAC and ABAC can be used together hierarchically, with broad access enforced by RBAC protocols and more complex access managed by ABAC. That being said, it is important to choose relevant authorization methods tailored to your organization’s needs - so the authorization process is <strong>neither too simplistic nor too complex</strong>.</p><p>⁠You can learn more about the decision between RBAC and ABAC <a title="https://www.permit.io/blog/rbac-vs-abac" href="https://www.permit.io/blog/rbac-vs-abac">here</a>.</p><p>For the purpose of this post, we’ll assume you decided you want to set up your policies with RBAC.<br></p><h2><u>The challenge of setting up policies with RBAC </u></h2><p>After you decide to set up your policies using RBAC, it is important to note the challenges you’ll have to face along the way: </p><p>The set of policies for each individual service has to be manually set up inside the service itself. This can be kind of a pain to do - as the amount of policies, users, and services grows, updating them in each relevant service becomes super tedious and time-consuming. Not only that, but considering the fact that policies change all the time - they have to be at least somewhat fluid. </p><p>Another issue can come from having the code of the authorization layer mixed in with the code of the application itself. This creates a situation where we struggle to upgrade, add capabilities and monitor the code as it is replicated between different microservices. Each change would require us to refactor large areas of code that only drift further from one another as these microservices develop. </p><p><strong>But how can we solve these challenges? </strong></p><img src="https://media.graphcms.com/4UqciNGIQnymXnblTZIq" alt="Plankton.gif" title="spongebob-plankton.gif" width="498" height="278" /><p><br>By creating a <strong>separate microservice for authorization</strong>, thus <strong>decoupling our policy from our code</strong>. Controlling access management centrally through a separate authorization service allows you to offer it as a service to every system that needs to check whether a user can or cannot access its resources. This can be done by using <a title="https://www.permit.io/blog/introduction-to-opa" href="https://www.permit.io/blog/introduction-to-opa">Open Policy Agent (OPA)</a>. </p><p></p><h2><u>What OPA gives us?</u></h2><ul><li><div>OPA unifies all policies across each individual service in one server.</div></li></ul><ul><li><div><p>Takes on the role of policy decision-making and enforcement from the service: ⁠The service queries OPA, OPA makes a decision and sends an output to the service, ⁠the service acts according to OPA’s reply. </p></div></li><li><div><p>It allows you to have a policy as code that can be easily reviewed, edited and rolled back.</p></div></li></ul><p>While we have a centralized authorization solution, the enforcement itself is still distributed - We have an OPA agent next to every microservice, providing decisions and enforcement with near-zero network latency. The OPA agents are distributed and can grow as the services scales. </p><img src="https://media.graphcms.com/B6S2XylIQGWkFAcCKxd0" alt="total control.gif" title="12c1882b1f22e3d8901e3b05ade02fb1.gif" width="320" height="240" /><p></p><h2>How to implement RBAC in OPA?</h2><p>In order to use RBAC, we need two types of information: </p><ul><li><div><p>Which <strong>users </strong>have which <strong>roles</strong></p></div></li><li><div><p>Which <strong>roles </strong>have which <strong>permissions</strong></p></div></li></ul><p>Once we provide RBAC with this information, we decide how to make an authorization decision; A user is assigned to a role and is authorized to do what the role permits. </p><p>For example, let us look at the following role assignments:</p><table><tbody><tr><td><p><strong>User</strong></p><p>(Who is performing the action)</p></td><td><p><strong>Role</strong></p><p>(What is the user’s assigned role)</p></td></tr><tr><td><p><code>Crab</code></p></td><td><p><code>Admin</code></p></td></tr><tr><td><p><code>Bob</code></p></td><td><p><code>Cook</code></p></td></tr><tr><td><p><code>Plankton</code></p></td><td><p><code>Villain</code></p></td></tr></tbody></table><p><br>And this role/permission assignment: </p><table><tbody><tr><td><p><strong>Role</strong></p></td><td><p><strong>Operation</strong></p><p>(What are they doing)</p></td><td><p><strong>Resource </strong></p><p>(What are they performing the action on)</p></td></tr><tr><td><p><code>Admin</code></p></td><td><p><code>Write</code></p></td><td><p><code>Secret formula</code></p></td></tr><tr><td><p><code>Admin</code></p></td><td><p><code>Read</code></p></td><td><p><code>Secret formula</code></p></td></tr><tr><td><p><code>Cook</code></p></td><td><p><code>Read</code></p></td><td><p><code>Secret formula</code></p></td></tr><tr><td><p><code>Villain</code></p></td><td><p><code>Want</code></p></td><td><p><code>Secret formula</code></p></td></tr></tbody></table><p></p><p>In this example, RBAC will make the following authorization decisions:</p><table><tbody><tr><td><p><strong>User</strong></p><p></p></td><td><p><strong>Operation</strong></p></td><td><p><strong>Resource</strong></p><p></p></td><td><p><strong>Decision</strong></p><p>(Should the action be allowed, and why?)</p></td></tr><tr><td><p><code>Crab</code></p></td><td><p><code>Write</code></p></td><td><p><code>Secret formula</code></p></td><td><p><code>Allow</code> because <code>Crab</code> is in <code>Admin</code></p></td></tr><tr><td><p><code>Bob</code></p></td><td><p><code>Read</code></p></td><td><p><code>Secret formula</code></p></td><td><p><code>Allow</code> because <code>Bob</code> is in <code>Cook</code></p></td></tr><tr><td><p><code>Villain</code></p></td><td><p><code>Read</code></p></td><td><p><code>Secret formula</code></p></td><td><p><code>Deny</code> because <code>Plankton</code> is in <code>Villain</code></p></td></tr><tr><td><p><code>Villain</code></p></td><td><p><code>Want</code></p></td><td><p><code>Secret formula</code></p></td><td><p><code>Allow</code> because <code>Plankton</code> is in <code>Villain</code></p></td></tr></tbody></table><p> </p><img src="https://media.graphcms.com/Ah7FLt9JTKGJX5JGggOF" alt="Plankton cheering.gif" title="23H6.gif" width="500" height="281" /><p></p><p>With OPA, you can write the following snippets to implement the example RBAC policy shown above:<br></p><pre><code>package rbac.authz

# Assigning user roles 

user_roles := {
    &quot;crab&quot;: [&quot;admin&quot;],
    &quot;bob&quot;: [&quot;cook&quot;],
    “plankton”:[“villain”]
}

# Role permission assignments
role_permissions := {
    &quot;cook&quot;:    [{&quot;action&quot;: &quot;read&quot;,  &quot;object&quot;: &quot;secret_formula&quot;}],
    &quot;admin&quot;:   [{&quot;action&quot;: &quot;read&quot;,  &quot;object&quot;: &quot;secret_formula&quot;},
                {&quot;action&quot;: &quot;write&quot;, &quot;object&quot;: &quot;secret_formula&quot;}],
    &quot;villain&quot;: [{&quot;action&quot;: &quot;want&quot;,  &quot;object&quot;: &quot;secret_formula&quot;}]
}

# Logic that implements RBAC.
default allow = false
allow {
    # Lookup the list of roles for the user
    roles := user_roles[input.user]
    # For each role in that list
    r := roles[_]
    # Lookup the permissions list for role r
    permissions := role_permissions[r]
    # For each permission
    p := permissions[_]
    # Check if the permission granted to r matches the user&#39;s request
    p == {&quot;action&quot;: input.action, &quot;object&quot;: input.object}
}
</code></pre><p>Querying the allow rule with the following input:</p><pre><code>{
  &quot;user&quot;: &quot;plankton&quot;,
  &quot;action&quot;: &quot;read&quot;,
  &quot;object&quot;: &quot;secret_formula&quot;
}</code></pre><p><br>Results in the response you’d expect: <code>False</code>.</p><p></p><img src="https://media.graphcms.com/sqDZ1KSQ3ev7mrIxObBz" alt="plankton-slow-clap.gif" title="plankton-slow-clap.gif" width="498" height="280" /><p><br><strong>Congrats! You have successfully implemented RBAC in OPA! </strong><br></p><h2>To sum things up:</h2><p><br>Let’s do a quick review of what we learned:</p><ul><li><div><p><strong>RBAC </strong>is an authorization model based on <strong>predefined roles</strong>, while <strong>ABAC </strong>determines access based on a set of characteristics called “<strong>attributes</strong>”. </p></div></li><li><div><p>While RBAC provides a rather simple solution for determining authorization that fits most organizations, ABAC is a more complex and detailed authorization method factoring in a much greater number of variables.</p></div></li><li><div><p>It is important to choose an authorization model that fits your organization&#39;s needs so that it’s <strong>neither too simple nor too complex</strong>.</p></div></li><li><div><p>The main challenges of setting up policies with RBAC are the requirement to manually set up the set of policies for each individual service and having the code of the authorization layer mixed in with the code of the application itself. <strong>Both can be solved by using OPA</strong>.</p></div></li><li><div><p>OPA solves these issues by <strong>unifying all policies</strong> in one server, <strong>taking on the role of policy decision-making and enforcement</strong> from the service, and allowing you to manage <strong>policy as code</strong>. </p></div></li><li><div><p>We saw an example of how to <strong>successfully implement RBAC in OPA</strong> :)</p></div></li></ul><p>Want to learn more? Join our ⁠<a title="https://opal-access.slack.com/join/shared_invite/zt-nz6yjgnp-RlP9rtOPwO0n0aH_vLbmBQ#/shared-invite/email" href="https://opal-access.slack.com/join/shared_invite/zt-nz6yjgnp-RlP9rtOPwO0n0aH_vLbmBQ#/shared-invite/email"><u>Slack channel</u></a> to ask questions and talk about authorization. </p>]]></content>
        <author>
            <name>Daniel Bass</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[The Case for Centralized IAM ]]></title>
        <id>the-case-for-centralized-iam</id>
        <link href="https://www.permit.io/blog/the-case-for-centralized-iam"/>
        <updated>2022-01-06T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Centralized IAM, and the benefits of implementing it in your organization. ]]></summary>
        <content type="html"><![CDATA[<h6>as inspired by Manual Garat of Booking.com</h6><p>⁠There have been some significant changes in the field of identity and access management (IAM) recently. In this context, we think it’s super important to discuss Centralized IAM, and the benefits of implementing it in your organization. </p><p>This article was inspired by an interview by DataBreachToday.com with<br>Manuel Garat - head of IAM at Booking.com Manuel’s role includes providing secure identity management, authentication, and authorization to approximately 20,000 users a year, and facing these challenges has highlighted the importance of Centralized IAM for him. </p><h2><strong>A new reality for Identity and access management</strong></h2><p>Several major changes have occurred in the past few years, posing new challenges in the field of IAM - influencing identity management, authentication, and most critically authorization. </p><p>The <strong>shift to cloud-based solutions</strong> has rendered us unable to rely on the service being hosted in our internal environment. Having our systems in the cloud makes them accessible to users which are external to our domain, and that requires us to validate every request done against those systems. This is not only a question of access (authentication) but also a question of what these users have access to (authorization). </p><p>More recently the threat landscape for identity, authentication, and access management has been particularly challenging during the ongoing pandemic. The creation of a <strong>decentralized workforce working from anywhere in the world</strong> has made it far easier to impersonate a user in your domain - thus creating an even greater need to ensure that the systems which are open for external access (which is most cloud-native systems nowadays) are being used exclusively by people we trust. </p><p>This new reality requires us to <strong>improve on existing identity verification practices and adopt new ones</strong>. </p><p>So far, organizations have mostly relied on recognizing a user as an employee in order to grant them access to the organization and its resources. Having employees all over the world - some of whom have never set foot in the actual office, requires us to validate if they are who they say they are. In this way, identity validation suddenly becomes super relevant. </p><p>Additionally, we require more flexible, multi-factor authentication and more mature authentication models. We are forced to create in-depth criteria for access - a lot more complex than just allowing certain users access, and that process needs to be automated. </p><h2>There are two main options when creating access management - </h2><ul><li><div>Deciding you have a set of good practices and delegating them to individual systems. </div></li><li><div>Controlling access management centrally, and offering it as a service to every system that needs to check whether a user can or cannot access its resources.</div></li></ul><p>When considering these two options, you might think: “We don’t need centralized access management - as the owners of the application and its resources we perfectly know who should get access”.</p><p>Here’s our take - you definitely do know who should get access, but <strong>you don&#39;t always know who shouldn&#39;t have access</strong>. That’s not something we can always be aware of - thus creating a need for it to be instead <strong>controlled centrally</strong>. </p><p>Just think of all the attributes we can have for both users and the services - country, department, billing status, usage quotas, errors, there are extensive criteria by which we might decide to allow or decline access. </p><p>Having your access management centralized allows you to <strong>centrally enforce segregation of duties, restrictions, and strategic restrictions all in one place</strong> - and be done with it. Otherwise, you need to make sure all other different systems (Which there could be hundreds of), and their microservices (Which can bring us to the thousands) are implementing those restrictions at the right time and in the right manner. </p><p>Another significant benefit of implementing a centralized authorization model is the fact that it allows <strong>validating the authorization models of applications</strong>. It is very typical to find applications that use overly broad permissions - which basically means users get a bit more access than they require. By centralizing the access management process you can validate those access control models, resulting in users having access to only what is necessary for them. </p><h2>The challenges of implementing a centralized model</h2><p>Implementing a centralized model of authorization is complex. Mostly because your customers are not going to be homogenous, so you will have to be very flexible in terms of integration. But there is an even larger challenge here in creating acceptance for this adoption from your technical audience. The value of moving to a centralized authorization model is not always easily perceived, so there is a lot of palletizing that you need to do in explaining the ‘why?’.</p><p>At the end of the day this is a critical aspect of any product - and unless we provide good user experiences for it - users won’t adopt it. <strong>It’s not just about building, it’s about building it right</strong>.</p><p>The good news is - Centralized IAM is also available as a service, which allows you to bake in permissions and access-control into any product, create a separate microservice for authorization, and provide controls and interfaces to various stakeholders and customers. </p><h2>Modern Authorization</h2><p>Modern systems which are highly composed of software are changing at high speed. The only hope of our controls, checks and balances to keep up is to be code-based themselves. One of the most important and recently popular practices in building cloud-native permissions is decoupling of policy and code. </p><h2>Decoupling Policy and Code</h2><p>Having the code of the authorization layer mixed in with the application code itself can be very problematic. Most importantly, it creates a situation where we struggle to upgrade, add capabilities and monitor the code overall as it is replicated between different microservices. Each change would require us to refactor large areas of code that only drift further from one another as these microservices develop. This can be avoided by decoupling our policy from our code by (ideally) creating a separate authorization microservice that will be used by the other services in order to fulfill their authorization needs. Open-source policy/permissions engines such as <a title="https://www.permit.io/blog/introduction-to-opa" href="https://www.permit.io/blog/introduction-to-opa">Open Policy Agent</a><a title="https://github.com/open-policy-agent/opa" href="https://github.com/open-policy-agent/opa"> (</a><a title="https://github.com/open-policy-agent/opa" href="https://github.com/open-policy-agent/opa">OPA</a><a title="https://github.com/open-policy-agent/opa" href="https://github.com/open-policy-agent/opa">)</a> or <a title="https://github.com/authzed/spicedb" href="https://github.com/authzed/spicedb">SpiceDB</a> for example allow us to manage authorization in a separate service. </p><p></p><img src="https://media.graphcms.com/resize=width:1135,height:672/ADlpfD2RIGlSO4huPMZk" alt="Centralized IAM" title="Centralized IAM.png" width="1135" height="672" /><p></p><h2>To sum things up</h2><p>The changes in the field of identity and access management require us to rethink our approach when it comes to centralizing it and implementing it in our organization. <br><br><strong>The main benefits of having centralized IAM are</strong>:</p><ul><li><div>Allowing us to apply access in one place, enforcing everything across your different systems in an organized manner - including segregation of duties, restrictions, and strategic restrictions.</div></li><li><div>It gives us an opportunity and the visibility to review and rethink the validity of the authorization models of our applications.</div></li></ul><p>In the words of Manuel - “<em>If you have your access management centralized, you can apply it once one in one place and be done with it</em>”. </p><p>See an in-depth interview with Manuel Garat, head of IAM at Booking.com<br>on this topic <a title="https://www.databreachtoday.com/making-case-for-centralized-iam-management-control-a-18008" href="https://www.databreachtoday.com/making-case-for-centralized-iam-management-control-a-18008">here</a>.</p>]]></content>
        <author>
            <name>Daniel Bass</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[5 best practices for building cloud-native permissions]]></title>
        <id>5-best-practices-for-building-cloud-native-permissions</id>
        <link href="https://www.permit.io/blog/5-best-practices-for-building-cloud-native-permissions"/>
        <updated>2021-11-23T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Cloud-native / microservice-based products are complex. Building access control and managing permissions for them is only getting worse by the pull request.]]></summary>
        <content type="html"><![CDATA[<p>Cloud-native / microservice-based products are complex, and so is building access-control and managing permissions for these products - it’s only getting worse by the pull request. Most developers end up building authorization or access-control for their products multiple times - forced to refactor with new customer, product, or security demands coming in. To make our lives a little easier, let&#39;s go over the unique challenges that building cloud-native permissions poses before us, and cover the five best practices for building them that can save you a lot of hassle.</p><h2>Things have changed</h2><p>We used to build authorization by using monolithic frameworks like Django or Spring that came with authorization or access-control baked-in, but these are no longer applicable when we create applications in the cloud-native space. There are a few reasons for that - Firstly, applications themselves are no longer monoliths - they&#39;re based on microservices and are becoming highly distributed. This becomes even more critical when you need to <strong>incorporate devices or instances that are deployed at the edge,</strong> which often need access-control too. Second, cloud-native applications tend to require the <strong>integration of third-party services</strong> (Such as billing, authentication, databases, analytics, etc.) and the ability to control access to them in addition to your own application&#39;s microservices. Third, more dynamic and distributed applications require us to use a bunch of <strong>different authorization models</strong> (e.g. <a title="https://www.permit.io/blog/rbac-with-permit" href="https://www.permit.io/blog/rbac-with-permit">RBAC</a>, <a title="https://www.permit.io/blog/what-is-abac" href="https://www.permit.io/blog/what-is-abac">ABAC</a>, <a title="https://www.permit.io/blog/what-is-rebac" href="https://www.permit.io/blog/what-is-rebac">ReBAC</a>), that are based on <strong>multiple data sources</strong>, and <strong>increasingly complex rules</strong> 📈. Lastly, security, privacy, and compliance demands are also rising (in the face of increasingly complex cyber threats ☠️) and becoming really complex. We find ourselves not only managing who should access the data but also <strong>how it is propagated between different services</strong>.</p><h2>The reality of modern authorization</h2><p>All of these new needs require us to adopt a different mindset when thinking about authorization:</p><ul><li><div>Authorization can no longer come as an afterthought - we have to plan it in advance.</div></li><li><div>Authorization is an ongoing endeavor - not something you solve once. It’s got to keep evolving along with your product.</div></li><li><div>Authorization is key in a customer’s experience - as it affects how users connect and invite others to the product. They won’t like it if it’s bad.</div></li><li><div>Authorization is connected to the bigger space of IAM</div></li></ul><h2>The 5 best practices</h2><p>To handle all of these changes, we want to share five of the best practices that will aid you in building cloud-native permissions - and leave you time to <strong>actually develop features</strong>, rather than just running around permissions all day 👍</p><h3>Decoupling policy and code:</h3><p>One of the most important and recently popular practices in building cloud-native permissions is decoupling of policy and code. Having the code of the authorization layer mixed in with the application code itself can be very problematic. Most importantly, it creates a situation where we struggle to upgrade, add capabilities and monitor the code overall as it is replicated between different microservices. Each change would require us to refactor large areas of code that only drift further from one another as these microservices develop. This can be avoided by decoupling our policy from our code by (ideally) <strong>creating a separate microservice for authorization</strong>, that will be used by the other services in order to fulfill their authorization needs. Open-source policy/permissions engines such as <a title="https://www.permit.io/blog/introduction-to-opa" href="https://www.permit.io/blog/introduction-to-opa">Open Policy Agent (OPA)</a> or <a title="https://github.com/authzed/spicedb" href="https://github.com/authzed/spicedb">SpiceDB</a> for example allow us to manage authorization in a separate service.</p><h3>Being event-driven:</h3><p>We want the application that we are building to be dynamic. Applications often utilize abilities such as user invites, role assignment, or the usage of 3rd party data sources - all of which require to be managed in a real-time fashion. Without it, our ability to make authorization decisions will be significantly reduced.<strong> This requires us to design our authorization layer to be event-driven</strong>. We want to create a reality where every time an event that affects authorization happens, it is immediately put through the system to ensure the authorization layer learns about it and remains in sync with the application and any relevant 3rd party data service. Ideally, to achieve this, we’d decouple the authorization data from the application data (as not all the data that is relevant for the application is relevant for authorization and vice versa), creating a lean model in our authorization layer and then keeping it in sync with our application and additional sources through real-time events. <a title="https://www.permit.io/blog/introduction-to-opal" href="https://www.permit.io/blog/introduction-to-opal">OPAL</a> (Open Policy Administration Layer), for example, is an open-source project that enables making OPA event-driven. This allows you to respond to policy and data changes, push live updates to your agents, and bring open policy up to the speed needed by live applications.</p><h3>Backoffice for stakeholders:</h3><p>The authorization layer is part of the product itself, and in product-focused companies, various stakeholders need to be able to connect to the access-control experience. These include (alongside developers) dev-ops, product managers, security, compliance, sales, marketing, etc. While building the authorization layer, we want to <strong>provide controls and interfaces to these various stakeholders through a back-office</strong>. This requires us to consider what different stakeholders would need from the access-control interface to our product from day one - that should keep everyone happy.</p><h3>Interfaces for customers:</h3><p>Similarly to the stakeholder’s requirements, we also need to think of our end-users/customers. <strong>Authorization is not only relevant in managing the product, but also for the product&#39;s end-user</strong>. If, for example, users require access to their own <a title="https://www.permit.io/blog/audit-logs" href="https://www.permit.io/blog/audit-logs">audit logs</a> (Something almost every B2B application user would ask) they should be able to see what they have done within the product with ease. Recognizing this need in advance calls for building the authorization layer in a way that enables it to latch on to different interfaces that cater to the needs of the end-users. The list of possible interfaces here is extremely long (and you can probably name a dozen you&#39;ve seen in multiple products). <a target='_blank' title="Permit.io" href="https://www.permit.io/">Permit.io</a>, which empowers developers to bake in permissions and access control into any product, provides many of these interfaces.</p><h3>GitOps:</h3><p>So we&#39;ve created a separate microservice to manage permissions, and we are able to deliver updates to it in an event-driven fashion. Now, how do we get around to managing those changes, applying versions, applying various checks and balances, and making sure that the code and data for the microservices comply with our demands and requirements? The answer is GitOps. <strong>Using GitOps allows us to create a pull request for every version change.</strong> Then, as our developers are updating the product and its access control, they can push a new commit with new code, have those go through the necessary tests and checks, and apply them to the authorization layer.</p><h2>The future of permissions</h2><p>With complexity on the rise and a constant stream of customer and security demands, building your product’s access control in a way that will be ready for the future, and won’t require heavy refactors or rewrites is critical. <strong>Creating a separate microservice for authorization, designing it to be event-driven, providing controls and interfaces to various stakeholders and customers, and </strong><a title="https://www.permit.io/blog/gitops-today-why-and-how" href="https://www.permit.io/blog/gitops-today-why-and-how"><strong>using GitOps</strong></a> allows us to create a product that is as ‘Future proof’ as possible for authorization, and prevents us from having to rebuild our authorization layer over and over (and over) again - no matter the requirements. <br><br>Want to learn more? Check out <a title="https://youtu.be/UbGb_iNVSFk" href="https://youtu.be/UbGb_iNVSFk"><strong>this video</strong></a> with <strong>Permit.io</strong>’s CEO, Or Weis, talking about building access control and permissions for cloud-native products at the CloudNative London Meetup.</p>]]></content>
        <author>
            <name>Or Weis</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[What is Authorization]]></title>
        <id>what-is-authorization</id>
        <link href="https://www.permit.io/blog/what-is-authorization"/>
        <updated>2021-11-22T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Authorization is the critical and most advanced part of Identity Access Management (IAM). Here are the differences between IM, AuthN, and AuthZ.]]></summary>
        <content type="html"><![CDATA[<h2>IAM</h2><img src="https://media.graphcms.com/output=format:webp/resize=width:60,height:60/RGhLoTiZTdmK2iOitPsc" alt="icon--1.png" title="icon--1.png" width="60" height="60" /><h3>Identity-Management</h3><p>Identity management (abbreviated as <code>IM</code>) solutions (such as Okta, and Azure Active-Directory) are used by organizations to keep track of the various identities they have, the organizational relationships between them (such as which department an employee belongs to), and systems the work with.</p><p>IM solutions provide protocols such as <a title="https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol" href="https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol">LDAP</a> to query this information, and provide standards such as <a title="https://en.wikipedia.org/wiki/Security_Assertion_Markup_Language" href="https://en.wikipedia.org/wiki/Security_Assertion_Markup_Language">SAML</a>, <a title="https://en.wikipedia.org/wiki/Single_sign-on" href="https://en.wikipedia.org/wiki/Single_sign-on">SSO</a> and <a title="https://en.wikipedia.org/wiki/OpenID" href="https://en.wikipedia.org/wiki/OpenID">OpenId</a> to authenticate against their directory.</p><p>IM solutions allow assigning roles, these are organizational roles, and shouldn&#39;t be confused with application roles (e.g. if an employee is an administrator in the IT department that doesn&#39;t mean he should be the administrator in the marketing solution the organization uses).</p><p>In general IM solutions often represent the customer side and its preferences.<br>Developers building applications with IAM should keep in mind the difference between the IM of their organization and that of their customers.</p><img src="https://media.graphcms.com/output=format:webp/resize=width:60,height:60/XcWV381QwCSExAf2iQ7g" alt="icon--2.png" title="icon--2.png" width="60" height="60" /><h3>Authentication</h3><p>Authentication (abbreviated as <code>AuthN</code>) solutions (such as Auth0, OneLogin, AWS Cognito, and KeyCloak) provide gateways into applications (mainly as log-in screens).<br>These solutions (as their name indicates) authenticate the incoming user&#39;s identity through a source of truth (such as its organization&#39;s IM solution), and allow/deny users from entering applications (this is the basic/limited <code>authorization</code> within authentication).</p><p>Modern authentication solutions gather the relevant information about the user into a passport like document called a <a title="https://en.wikipedia.org/wiki/JSON_Web_Token" href="https://en.wikipedia.org/wiki/JSON_Web_Token">JWT (Json-Web-Token)</a>. The <code>JWT</code> contains <code>claims</code> about the user (e.g. which department they belong to).<br>The Identity and claims are then signed cryptographically, allowing later recipients of the JWT (mainly the authorization layer and the application itself) to be able to make trustworthy decisions based on the user&#39;s identity without having to re-authenticate or re-query the IM solution. In web-based / cloud-native applications the JWT is propagated through the user&#39;s session (most commonly via HTTP headers).</p><img src="https://media.graphcms.com/resize=width:60,height:60/ZtbhxfFeQAKrtvJwNHU6" alt="icon--3.png" title="icon--3.png" width="60" height="60" /><h3>Authorization</h3><p>Authorization (abbreviated as <code>AuthZ</code>) controls access within a product. While IM and AuthN solutions work at the perimeter of a product (e.g. application, service, ...) <code>AuthZ</code> is responsible for all the complex patterns of access within the product itself. This is where you&#39;d most often run into roles, permissions, ownership, application users, invites, approval flows, and many more common patterns.<br><code>AuthZ</code> architectures (especially microservices ones) are most commonly broken down into two main components <code>policy-decision-point</code> (<a title="https://docs.permit.io/concepts/pdp/" href="https://docs.permit.io/concepts/pdp/">PDP</a>) and <code>policy-enforcement-point</code> (<a title="https://docs.permit.io/overview/permit-basics/#pep" href="https://docs.permit.io/overview/permit-basics/#pep">PEP</a>).<br>PDPs are used to create a unified plain with the same rules and same world-picture to answer authorization queries with the right decisions (mostly allow/deny or data filtering) across the applications.<br>PEPs are used as gateways before accessing content, data, services or features. These are often implemented as flow-control in code (i.e. <code>if</code>), or as part of reverse-proxies (e.g. Envoy) or API-gateways.</p><p>A key part of authorization is policy - i.e. the set of rules governing access within the solution. Common models for policy you probably have heard of are RBAC and ABAC.<br><a title="https://www.permit.io/blog/rbac-with-permit" href="https://www.permit.io/blog/rbac-with-permit"><strong>RBAC</strong> </a>- or Role Based Access Control - assigns roles to users, and permissions to roles, and uses those to decide who can do what. E.g. Simon is an Editor, Editors can change files, hence Simon can change the file.<br><a title="https://www.permit.io/blog/what-is-abac" href="https://www.permit.io/blog/what-is-abac"><strong>ABAC</strong> </a>- or Attribute Based Access Control - uses the attributes of both the solution and the user to make decisions. E.g. David works in New York (has the attribute of <code>location==&#39;new york&#39;</code>), only people outside of the US can use the GDPR interface, hence david can&#39;t use the feature.</p><p>There are many more models, and in general models such as RBAC are only tools to help think about the problem - developers shouldn&#39;t expect a specific basic model to cover all their needs (especially not in the future).</p><h2>The IAM Waterfall</h2><p>Let&#39;s put it all together - Identity Access Management works like a waterfall, starting at the customer&#39;s <code>Identity-Management</code> cascading down to <code>authentication</code> via <code>SSO</code> and finally via <code>JWT</code> to <code>authorization</code> and the application itself.<br></p><img src="https://media.graphcms.com/Z2HTJOLrQs61CUfscuNo" alt="The-IAM-Waterfall.png" title="The-IAM-Waterfall.png" width="1061" height="384" /><p></p><h2>Authorization vs. Authentication⁠</h2><p>As the names can be confusing here&#39;s an easy way to think about <code>AuthZ</code> vs <code>AuthN</code>:<br><code>AuthN</code> identifies who&#39;s at the door and whether they may enter, while <code>AuthZ</code> deals with deciding where can they go and what they can do when they are inside the house.</p><h2>Different levels of authorization</h2><p>⁠It&#39;s important to remember authorization is needed across the multiple layers:</p><ul><li><div>Physical authorization (e.g. locks on doors)</div></li><li><div>Network level authorization (e.g. Firewalls and Zero-trust networks )</div></li><li><div>Infrastructure level authorization (e.g. which service can talk to which service in our cloud)</div></li><li><div>Application level authorization (e.g. which users can interact with which users using which features) Each layer is a whole world onto itself and often will require different tools and solutions.</div></li></ul><h2>Fullstack authorization</h2><p>⁠It&#39;s important to remember authorization is not just the decision points and the enforcement points- but a whole stack of components. Including the back-office and interfaces the different stakeholders within(e.g. developers, security, product) and without(customers, partners, auditors) the organization need. Building authorization often requires building many interfaces on top, such as :</p><ul><li><div>User management</div></li><li><div>Policy editors</div></li><li><div>Role and permission assignment</div></li><li><div>Invites</div></li><li><div>Impersonation</div></li><li><div>Audit logs</div></li><li><div>...</div></li></ul><h2>Authorization is hard</h2><p>While authorization is commonly found in bottle-neck points of software (such as points of accessing databases, APIs, 3rd-party services, and triggering actions or change in a system), naturally as applications become more advanced they require more AuthZ checks.<br>Distributed applications and microservices in particular create more AuthZ points by design in the intersection between all the microservice, and so authorization challenges often grow exponentially as the software grows. Everyone often starts with a simple pattern for authorization (e.g. just two roles admin and user), and it&#39;s easy to overlook the complexity that will be added later. Combine that with increasingly complex models, expanding data plane, scale, cryptography, and ever coming new customer and security/compliance demands and you have a perfect recipe for constantly going back to the drawing board. We found that most companies end-up refactoring or completely rebuilding their authorization solutions every few months.<br>The best way to avoid constantly rebuilding authorization is to build on best practices, open-source, and of course complete services. Developers should avoid the temptation of building authorization on their own from scratch. Especially nowadays when there are so many great open-source options such as <a title="https://www.permit.io/blog/introduction-to-opa" href="https://www.permit.io/blog/introduction-to-opa">OPA</a>, <a title="https://www.permit.io/blog/introduction-to-opal" href="https://www.permit.io/blog/introduction-to-opal">OPAL</a>, ORY, and OSO.</p><h2>Where to start</h2><p>A good place to start is by reviewing what&#39;s available as open-source, even if just to learn the concepts.<br>You&#39;re welcome to <a title="https://io.permit.io/permitslack" href="https://io.permit.io/permitslack">join our community on Slack</a> to dive deeper and ask questions about authorization and IAM in general.</p>]]></content>
        <author>
            <name>Or Weis</name>
            <email>info@permit.io</email>
            <uri>https://permit.io</uri>
        </author>
    </entry>
</feed>